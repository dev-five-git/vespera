<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera","src","lib.rs"],"content":"//! Vespera - OpenAPI generation for Rust web frameworks\r\n//!\r\n//! This crate provides macros and utilities for generating OpenAPI documentation\r\n//! from your route definitions.\r\n\r\n// Re-export vespera_core types so users don't need to depend on vespera_core directly\r\npub mod schema {\r\n    pub use vespera_core::schema::*;\r\n}\r\n\r\npub mod route {\r\n    pub use vespera_core::route::*;\r\n}\r\n\r\npub mod openapi {\r\n    pub use vespera_core::openapi::*;\r\n}\r\n\r\n// Re-export macros from vespera_macro\r\npub use vespera_macro::{Schema, route, vespera};\r\n\r\n// Re-export axum for convenience\r\npub mod axum {\r\n    pub use axum::*;\r\n}\r\n\r\npub mod axum_extra {\r\n    pub use axum_extra::*;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_core","src","lib.rs"],"content":"//! Vespera Core - OpenAPI structure definitions\n//!\n//! Provides structures conforming to the OpenAPI 3.1 specification.\n\npub mod openapi;\npub mod route;\npub mod schema;\n\npub use openapi::*;\npub use route::*;\npub use schema::*;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_core","src","openapi.rs"],"content":"//! OpenAPI document structure definitions\n\nuse crate::route::PathItem;\nuse crate::schema::{Components, ExternalDocumentation};\nuse serde::{Deserialize, Serialize};\nuse std::collections::{BTreeMap, HashMap};\n\n/// OpenAPI document version\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Default)]\npub enum OpenApiVersion {\n    #[serde(rename = \"3.0.0\")]\n    V3_0_0,\n    #[serde(rename = \"3.0.1\")]\n    V3_0_1,\n    #[serde(rename = \"3.0.2\")]\n    V3_0_2,\n    #[serde(rename = \"3.0.3\")]\n    V3_0_3,\n    #[serde(rename = \"3.1.0\")]\n    #[default]\n    V3_1_0,\n}\n\n/// Contact information\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Contact {\n    /// Contact name\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub name: Option\u003cString\u003e,\n    /// Contact URL\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub url: Option\u003cString\u003e,\n    /// Contact email\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub email: Option\u003cString\u003e,\n}\n\n/// License information\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct License {\n    /// License name\n    pub name: String,\n    /// License URL\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub url: Option\u003cString\u003e,\n}\n\n/// API information\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Info {\n    /// API title\n    pub title: String,\n    /// API version\n    pub version: String,\n    /// API description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// Terms of service URL\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub terms_of_service: Option\u003cString\u003e,\n    /// Contact information\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub contact: Option\u003cContact\u003e,\n    /// License information\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub license: Option\u003cLicense\u003e,\n    /// Summary\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub summary: Option\u003cString\u003e,\n}\n\n/// Server variable\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ServerVariable {\n    /// Default value\n    pub default: String,\n    /// Enum values\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub r#enum: Option\u003cVec\u003cString\u003e\u003e,\n    /// Description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n}\n\n/// Server information\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Server {\n    /// Server URL\n    pub url: String,\n    /// Server description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// Server variables\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub variables: Option\u003cHashMap\u003cString, ServerVariable\u003e\u003e,\n}\n\n/// Tag definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Tag {\n    /// Tag name\n    pub name: String,\n    /// Tag description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// External documentation\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub external_docs: Option\u003cExternalDocumentation\u003e,\n}\n\n/// OpenAPI document (root structure)\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct OpenApi {\n    /// OpenAPI version\n    pub openapi: OpenApiVersion,\n    /// API information\n    pub info: Info,\n    /// Server list\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub servers: Option\u003cVec\u003cServer\u003e\u003e,\n    /// Path definitions\n    pub paths: BTreeMap\u003cString, PathItem\u003e,\n    /// Components (reusable components)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub components: Option\u003cComponents\u003e,\n    /// Security requirements\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub security: Option\u003cVec\u003cHashMap\u003cString, Vec\u003cString\u003e\u003e\u003e\u003e,\n    /// Tag definitions\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub tags: Option\u003cVec\u003cTag\u003e\u003e,\n    /// External documentation\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub external_docs: Option\u003cExternalDocumentation\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_core","src","route.rs"],"content":"//! Route-related structure definitions\n\nuse serde::{Deserialize, Serialize};\nuse std::collections::{BTreeMap, HashMap};\n\nuse crate::SchemaRef;\n\n/// HTTP method\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum HttpMethod {\n    Get,\n    Post,\n    Put,\n    Patch,\n    Delete,\n    Head,\n    Options,\n    Trace,\n}\n\nimpl From\u003c\u0026str\u003e for HttpMethod {\n    fn from(value: \u0026str) -\u003e Self {\n        match value.to_uppercase().as_str() {\n            \"GET\" =\u003e HttpMethod::Get,\n            \"POST\" =\u003e HttpMethod::Post,\n            \"PUT\" =\u003e HttpMethod::Put,\n            \"PATCH\" =\u003e HttpMethod::Patch,\n            \"DELETE\" =\u003e HttpMethod::Delete,\n            \"HEAD\" =\u003e HttpMethod::Head,\n            \"OPTIONS\" =\u003e HttpMethod::Options,\n            \"TRACE\" =\u003e HttpMethod::Trace,\n            _ =\u003e HttpMethod::Get, // default value\n        }\n    }\n}\n\n/// Parameter location in the request\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum ParameterLocation {\n    Query,\n    Header,\n    Path,\n    Cookie,\n}\n\n/// Parameter definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Parameter {\n    /// Parameter name\n    pub name: String,\n    /// Parameter location\n    pub r#in: ParameterLocation,\n    /// Parameter description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// Whether the parameter is required\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub required: Option\u003cbool\u003e,\n    /// Schema reference or inline schema\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub schema: Option\u003cSchemaRef\u003e,\n    /// Example value\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub example: Option\u003cserde_json::Value\u003e,\n}\n\n/// Request body definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct RequestBody {\n    /// Request body description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// Whether the request body is required\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub required: Option\u003cbool\u003e,\n    /// Schema per Content-Type\n    pub content: BTreeMap\u003cString, MediaType\u003e,\n}\n\n/// Media type definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MediaType {\n    /// Schema reference or inline schema\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub schema: Option\u003cSchemaRef\u003e,\n    /// Example\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub example: Option\u003cserde_json::Value\u003e,\n    /// Examples\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub examples: Option\u003cHashMap\u003cString, Example\u003e\u003e,\n}\n\n/// Example definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Example {\n    /// Example summary\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub summary: Option\u003cString\u003e,\n    /// Example description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// Example value\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub value: Option\u003cserde_json::Value\u003e,\n}\n\n/// Response definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Response {\n    /// Response description\n    pub description: String,\n    /// Header definitions\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub headers: Option\u003cHashMap\u003cString, Header\u003e\u003e,\n    /// Schema per Content-Type\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub content: Option\u003cBTreeMap\u003cString, MediaType\u003e\u003e,\n}\n\n/// Header definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Header {\n    /// Header description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// Schema reference or inline schema\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub schema: Option\u003cSchemaRef\u003e,\n}\n\n/// OpenAPI Operation definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Operation {\n    /// Operation ID (unique identifier)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub operation_id: Option\u003cString\u003e,\n    /// List of tags\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub tags: Option\u003cVec\u003cString\u003e\u003e,\n    /// Summary\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub summary: Option\u003cString\u003e,\n    /// Description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// List of parameters\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub parameters: Option\u003cVec\u003cParameter\u003e\u003e,\n    /// Request body\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub request_body: Option\u003cRequestBody\u003e,\n    /// Response definitions (status code -\u003e Response)\n    pub responses: BTreeMap\u003cString, Response\u003e,\n    /// Security requirements\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub security: Option\u003cVec\u003cHashMap\u003cString, Vec\u003cString\u003e\u003e\u003e\u003e,\n}\n\n/// Path Item definition (all HTTP methods for a specific path)\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PathItem {\n    /// GET method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub get: Option\u003cOperation\u003e,\n    /// POST method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub post: Option\u003cOperation\u003e,\n    /// PUT method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub put: Option\u003cOperation\u003e,\n    /// PATCH method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub patch: Option\u003cOperation\u003e,\n    /// DELETE method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub delete: Option\u003cOperation\u003e,\n    /// HEAD method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub head: Option\u003cOperation\u003e,\n    /// OPTIONS method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub options: Option\u003cOperation\u003e,\n    /// TRACE method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub trace: Option\u003cOperation\u003e,\n    /// Path parameters\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub parameters: Option\u003cVec\u003cParameter\u003e\u003e,\n    /// Summary\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub summary: Option\u003cString\u003e,\n    /// Description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n}\n\nimpl PathItem {\n    /// Set an operation for a specific HTTP method\n    pub fn set_operation(\u0026mut self, method: HttpMethod, operation: Operation) {\n        match method {\n            HttpMethod::Get =\u003e self.get = Some(operation),\n            HttpMethod::Post =\u003e self.post = Some(operation),\n            HttpMethod::Put =\u003e self.put = Some(operation),\n            HttpMethod::Patch =\u003e self.patch = Some(operation),\n            HttpMethod::Delete =\u003e self.delete = Some(operation),\n            HttpMethod::Head =\u003e self.head = Some(operation),\n            HttpMethod::Options =\u003e self.options = Some(operation),\n            HttpMethod::Trace =\u003e self.trace = Some(operation),\n        }\n    }\n\n    /// Get an operation for a specific HTTP method\n    pub fn get_operation(\u0026self, method: \u0026HttpMethod) -\u003e Option\u003c\u0026Operation\u003e {\n        match method {\n            HttpMethod::Get =\u003e self.get.as_ref(),\n            HttpMethod::Post =\u003e self.post.as_ref(),\n            HttpMethod::Put =\u003e self.put.as_ref(),\n            HttpMethod::Patch =\u003e self.patch.as_ref(),\n            HttpMethod::Delete =\u003e self.delete.as_ref(),\n            HttpMethod::Head =\u003e self.head.as_ref(),\n            HttpMethod::Options =\u003e self.options.as_ref(),\n            HttpMethod::Trace =\u003e self.trace.as_ref(),\n        }\n    }\n}\n\n/// Route information (for internal use)\n#[derive(Debug, Clone)]\npub struct RouteInfo {\n    /// HTTP method\n    pub method: HttpMethod,\n    /// Path\n    pub path: String,\n    /// Operation information\n    pub operation: Operation,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rstest::rstest;\n\n    #[rstest]\n    #[case(\"GET\", HttpMethod::Get)]\n    #[case(\"get\", HttpMethod::Get)]\n    #[case(\"Get\", HttpMethod::Get)]\n    #[case(\"POST\", HttpMethod::Post)]\n    #[case(\"post\", HttpMethod::Post)]\n    #[case(\"Post\", HttpMethod::Post)]\n    #[case(\"PUT\", HttpMethod::Put)]\n    #[case(\"put\", HttpMethod::Put)]\n    #[case(\"Put\", HttpMethod::Put)]\n    #[case(\"PATCH\", HttpMethod::Patch)]\n    #[case(\"patch\", HttpMethod::Patch)]\n    #[case(\"Patch\", HttpMethod::Patch)]\n    #[case(\"DELETE\", HttpMethod::Delete)]\n    #[case(\"delete\", HttpMethod::Delete)]\n    #[case(\"Delete\", HttpMethod::Delete)]\n    #[case(\"HEAD\", HttpMethod::Head)]\n    #[case(\"head\", HttpMethod::Head)]\n    #[case(\"Head\", HttpMethod::Head)]\n    #[case(\"OPTIONS\", HttpMethod::Options)]\n    #[case(\"options\", HttpMethod::Options)]\n    #[case(\"Options\", HttpMethod::Options)]\n    #[case(\"TRACE\", HttpMethod::Trace)]\n    #[case(\"trace\", HttpMethod::Trace)]\n    #[case(\"Trace\", HttpMethod::Trace)]\n    fn test_http_method_from_str(#[case] input: \u0026str, #[case] expected: HttpMethod) {\n        let result = HttpMethod::from(input);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_http_method_from_invalid_str() {\n        // Invalid method should default to Get\n        let result = HttpMethod::from(\"INVALID\");\n        assert_eq!(result, HttpMethod::Get);\n    }\n\n    #[test]\n    fn test_http_method_serialization() {\n        // Test serde serialization (should be UPPERCASE)\n        let method = HttpMethod::Get;\n        let serialized = serde_json::to_string(\u0026method).unwrap();\n        assert_eq!(serialized, \"\\\"GET\\\"\");\n\n        let method = HttpMethod::Post;\n        let serialized = serde_json::to_string(\u0026method).unwrap();\n        assert_eq!(serialized, \"\\\"POST\\\"\");\n\n        let method = HttpMethod::Delete;\n        let serialized = serde_json::to_string(\u0026method).unwrap();\n        assert_eq!(serialized, \"\\\"DELETE\\\"\");\n    }\n\n    #[test]\n    fn test_http_method_deserialization() {\n        // Test serde deserialization\n        let method: HttpMethod = serde_json::from_str(\"\\\"GET\\\"\").unwrap();\n        assert_eq!(method, HttpMethod::Get);\n\n        let method: HttpMethod = serde_json::from_str(\"\\\"POST\\\"\").unwrap();\n        assert_eq!(method, HttpMethod::Post);\n\n        let method: HttpMethod = serde_json::from_str(\"\\\"DELETE\\\"\").unwrap();\n        assert_eq!(method, HttpMethod::Delete);\n    }\n\n    #[test]\n    fn test_path_item_set_operation() {\n        let mut path_item = PathItem {\n            get: None,\n            post: None,\n            put: None,\n            patch: None,\n            delete: None,\n            head: None,\n            options: None,\n            trace: None,\n            parameters: None,\n            summary: None,\n            description: None,\n        };\n\n        let operation = Operation {\n            operation_id: Some(\"test_operation\".to_string()),\n            tags: None,\n            summary: None,\n            description: None,\n            parameters: None,\n            request_body: None,\n            responses: BTreeMap::new(),\n            security: None,\n        };\n\n        // Test setting GET operation\n        path_item.set_operation(HttpMethod::Get, operation.clone());\n        assert!(path_item.get.is_some());\n        assert_eq!(\n            path_item.get.as_ref().unwrap().operation_id,\n            Some(\"test_operation\".to_string())\n        );\n\n        // Test setting POST operation\n        let mut operation_post = operation.clone();\n        operation_post.operation_id = Some(\"post_operation\".to_string());\n        path_item.set_operation(HttpMethod::Post, operation_post);\n        assert!(path_item.post.is_some());\n        assert_eq!(\n            path_item.post.as_ref().unwrap().operation_id,\n            Some(\"post_operation\".to_string())\n        );\n\n        // Test setting PUT operation\n        let mut operation_put = operation.clone();\n        operation_put.operation_id = Some(\"put_operation\".to_string());\n        path_item.set_operation(HttpMethod::Put, operation_put);\n        assert!(path_item.put.is_some());\n\n        // Test setting PATCH operation\n        let mut operation_patch = operation.clone();\n        operation_patch.operation_id = Some(\"patch_operation\".to_string());\n        path_item.set_operation(HttpMethod::Patch, operation_patch);\n        assert!(path_item.patch.is_some());\n\n        // Test setting DELETE operation\n        let mut operation_delete = operation.clone();\n        operation_delete.operation_id = Some(\"delete_operation\".to_string());\n        path_item.set_operation(HttpMethod::Delete, operation_delete);\n        assert!(path_item.delete.is_some());\n\n        // Test setting HEAD operation\n        let mut operation_head = operation.clone();\n        operation_head.operation_id = Some(\"head_operation\".to_string());\n        path_item.set_operation(HttpMethod::Head, operation_head);\n        assert!(path_item.head.is_some());\n\n        // Test setting OPTIONS operation\n        let mut operation_options = operation.clone();\n        operation_options.operation_id = Some(\"options_operation\".to_string());\n        path_item.set_operation(HttpMethod::Options, operation_options);\n        assert!(path_item.options.is_some());\n\n        // Test setting TRACE operation\n        let mut operation_trace = operation;\n        operation_trace.operation_id = Some(\"trace_operation\".to_string());\n        path_item.set_operation(HttpMethod::Trace, operation_trace);\n        assert!(path_item.trace.is_some());\n    }\n\n    #[test]\n    fn test_path_item_get_operation() {\n        let mut path_item = PathItem {\n            get: None,\n            post: None,\n            put: None,\n            patch: None,\n            delete: None,\n            head: None,\n            options: None,\n            trace: None,\n            parameters: None,\n            summary: None,\n            description: None,\n        };\n\n        let operation = Operation {\n            operation_id: Some(\"test_operation\".to_string()),\n            tags: None,\n            summary: None,\n            description: None,\n            parameters: None,\n            request_body: None,\n            responses: BTreeMap::new(),\n            security: None,\n        };\n\n        // Initially, all operations should be None\n        assert!(path_item.get_operation(\u0026HttpMethod::Get).is_none());\n        assert!(path_item.get_operation(\u0026HttpMethod::Post).is_none());\n\n        // Set GET operation\n        path_item.set_operation(HttpMethod::Get, operation.clone());\n        let retrieved = path_item.get_operation(\u0026HttpMethod::Get);\n        assert!(retrieved.is_some());\n        assert_eq!(\n            retrieved.unwrap().operation_id,\n            Some(\"test_operation\".to_string())\n        );\n\n        // Set POST operation\n        let mut operation_post = operation.clone();\n        operation_post.operation_id = Some(\"post_operation\".to_string());\n        path_item.set_operation(HttpMethod::Post, operation_post);\n        let retrieved = path_item.get_operation(\u0026HttpMethod::Post);\n        assert!(retrieved.is_some());\n        assert_eq!(\n            retrieved.unwrap().operation_id,\n            Some(\"post_operation\".to_string())\n        );\n\n        // Test all methods\n        path_item.set_operation(HttpMethod::Put, operation.clone());\n        assert!(path_item.get_operation(\u0026HttpMethod::Put).is_some());\n\n        path_item.set_operation(HttpMethod::Patch, operation.clone());\n        assert!(path_item.get_operation(\u0026HttpMethod::Patch).is_some());\n\n        path_item.set_operation(HttpMethod::Delete, operation.clone());\n        assert!(path_item.get_operation(\u0026HttpMethod::Delete).is_some());\n\n        path_item.set_operation(HttpMethod::Head, operation.clone());\n        assert!(path_item.get_operation(\u0026HttpMethod::Head).is_some());\n\n        path_item.set_operation(HttpMethod::Options, operation.clone());\n        assert!(path_item.get_operation(\u0026HttpMethod::Options).is_some());\n\n        path_item.set_operation(HttpMethod::Trace, operation);\n        assert!(path_item.get_operation(\u0026HttpMethod::Trace).is_some());\n    }\n\n    #[test]\n    fn test_path_item_set_operation_overwrites() {\n        let mut path_item = PathItem {\n            get: None,\n            post: None,\n            put: None,\n            patch: None,\n            delete: None,\n            head: None,\n            options: None,\n            trace: None,\n            parameters: None,\n            summary: None,\n            description: None,\n        };\n\n        let operation1 = Operation {\n            operation_id: Some(\"first\".to_string()),\n            tags: None,\n            summary: None,\n            description: None,\n            parameters: None,\n            request_body: None,\n            responses: BTreeMap::new(),\n            security: None,\n        };\n\n        let operation2 = Operation {\n            operation_id: Some(\"second\".to_string()),\n            tags: None,\n            summary: None,\n            description: None,\n            parameters: None,\n            request_body: None,\n            responses: BTreeMap::new(),\n            security: None,\n        };\n\n        // Set first operation\n        path_item.set_operation(HttpMethod::Get, operation1);\n        assert_eq!(\n            path_item.get.as_ref().unwrap().operation_id,\n            Some(\"first\".to_string())\n        );\n\n        // Overwrite with second operation\n        path_item.set_operation(HttpMethod::Get, operation2);\n        assert_eq!(\n            path_item.get.as_ref().unwrap().operation_id,\n            Some(\"second\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_http_method_equality() {\n        let method1 = HttpMethod::Get;\n        let method2 = HttpMethod::Get;\n        let method3 = HttpMethod::Post;\n\n        assert_eq!(method1, method2);\n        assert_ne!(method1, method3);\n    }\n\n    #[test]\n    fn test_http_method_clone() {\n        let method = HttpMethod::Get;\n        let cloned = method.clone();\n        assert_eq!(method, cloned);\n    }\n\n    #[test]\n    fn test_http_method_hash() {\n        use std::collections::HashMap;\n\n        let mut map = HashMap::new();\n        map.insert(HttpMethod::Get, \"GET method\");\n        map.insert(HttpMethod::Post, \"POST method\");\n\n        assert_eq!(map.get(\u0026HttpMethod::Get), Some(\u0026\"GET method\"));\n        assert_eq!(map.get(\u0026HttpMethod::Post), Some(\u0026\"POST method\"));\n        assert_eq!(map.get(\u0026HttpMethod::Put), None);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":24,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":25,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":26,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":27,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":28,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":29,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":30,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":31,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":32,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":210,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":211,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":212,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":213,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":214,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":215,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":216,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":217,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":218,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":219,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":224,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":225,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":226,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":227,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":228,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":229,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":230,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":231,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":232,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":233,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":31,"coverable":31},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_core","src","schema.rs"],"content":"//! Schema-related structure definitions\r\n\r\nuse serde::{Deserialize, Serialize};\r\nuse std::collections::{BTreeMap, HashMap};\r\n\r\n/// Schema reference or inline schema\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(untagged)]\r\npub enum SchemaRef {\r\n    /// Schema reference (e.g., \"#/components/schemas/User\")\r\n    Ref(Reference),\r\n    /// Inline schema\r\n    Inline(Box\u003cSchema\u003e),\r\n}\r\n\r\n/// Reference definition\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Reference {\r\n    /// Reference path (e.g., \"#/components/schemas/User\")\r\n    #[serde(rename = \"$ref\")]\r\n    pub ref_path: String,\r\n}\r\n\r\nimpl Reference {\r\n    /// Create a new reference\r\n    pub fn new(ref_path: String) -\u003e Self {\r\n        Self { ref_path }\r\n    }\r\n\r\n    /// Create a component schema reference\r\n    pub fn schema(name: \u0026str) -\u003e Self {\r\n        Reference::new(format!(\"#/components/schemas/{}\", name))\r\n    }\r\n}\r\n\r\n/// JSON Schema type\r\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\r\n#[serde(rename_all = \"lowercase\")]\r\npub enum SchemaType {\r\n    String,\r\n    Number,\r\n    Integer,\r\n    Boolean,\r\n    Array,\r\n    Object,\r\n    Null,\r\n}\r\n\r\n/// Number format\r\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\r\n#[serde(rename_all = \"lowercase\")]\r\npub enum NumberFormat {\r\n    Float,\r\n    Double,\r\n    Int32,\r\n    Int64,\r\n}\r\n\r\n/// String format\r\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\r\n#[serde(rename_all = \"lowercase\")]\r\npub enum StringFormat {\r\n    Date,\r\n    DateTime,\r\n    Password,\r\n    Byte,\r\n    Binary,\r\n    Email,\r\n    Uuid,\r\n    Uri,\r\n    Hostname,\r\n    IpV4,\r\n    IpV6,\r\n}\r\n\r\n/// JSON Schema definition\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct Schema {\r\n    /// Schema reference ($ref) - if present, other fields are ignored\r\n    #[serde(rename = \"$ref\")]\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub ref_path: Option\u003cString\u003e,\r\n    /// Schema type\r\n    #[serde(rename = \"type\")]\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub schema_type: Option\u003cSchemaType\u003e,\r\n    /// Format (for numbers or strings)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub format: Option\u003cString\u003e,\r\n    /// Title\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub title: Option\u003cString\u003e,\r\n    /// Description\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub description: Option\u003cString\u003e,\r\n    /// Default value\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub default: Option\u003cserde_json::Value\u003e,\r\n    /// Example\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub example: Option\u003cserde_json::Value\u003e,\r\n    /// Examples\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub examples: Option\u003cVec\u003cserde_json::Value\u003e\u003e,\r\n\r\n    // Number constraints\r\n    /// Minimum value\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub minimum: Option\u003cf64\u003e,\r\n    /// Maximum value\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub maximum: Option\u003cf64\u003e,\r\n    /// Exclusive minimum\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub exclusive_minimum: Option\u003cbool\u003e,\r\n    /// Exclusive maximum\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub exclusive_maximum: Option\u003cbool\u003e,\r\n    /// Multiple of\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub multiple_of: Option\u003cf64\u003e,\r\n\r\n    // String constraints\r\n    /// Minimum length\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub min_length: Option\u003cusize\u003e,\r\n    /// Maximum length\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub max_length: Option\u003cusize\u003e,\r\n    /// Pattern (regex)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub pattern: Option\u003cString\u003e,\r\n\r\n    // Array constraints\r\n    /// Array item schema\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub items: Option\u003cBox\u003cSchemaRef\u003e\u003e,\r\n    /// Prefix items for tuple arrays (OpenAPI 3.1 / JSON Schema 2020-12)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub prefix_items: Option\u003cVec\u003cSchemaRef\u003e\u003e,\r\n    /// Minimum number of items\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub min_items: Option\u003cusize\u003e,\r\n    /// Maximum number of items\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub max_items: Option\u003cusize\u003e,\r\n    /// Unique items flag\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub unique_items: Option\u003cbool\u003e,\r\n\r\n    // Object constraints\r\n    /// Property definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub properties: Option\u003cBTreeMap\u003cString, SchemaRef\u003e\u003e,\r\n    /// List of required properties\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub required: Option\u003cVec\u003cString\u003e\u003e,\r\n    /// Whether additional properties are allowed (can be boolean or SchemaRef)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub additional_properties: Option\u003cserde_json::Value\u003e,\r\n    /// Minimum number of properties\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub min_properties: Option\u003cusize\u003e,\r\n    /// Maximum number of properties\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub max_properties: Option\u003cusize\u003e,\r\n\r\n    // General constraints\r\n    /// Enum values\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub r#enum: Option\u003cVec\u003cserde_json::Value\u003e\u003e,\r\n    /// All conditions must be satisfied (AND)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub all_of: Option\u003cVec\u003cSchemaRef\u003e\u003e,\r\n    /// At least one condition must be satisfied (OR)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub any_of: Option\u003cVec\u003cSchemaRef\u003e\u003e,\r\n    /// Exactly one condition must be satisfied (XOR)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub one_of: Option\u003cVec\u003cSchemaRef\u003e\u003e,\r\n    /// Condition must not be satisfied (NOT)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub not: Option\u003cBox\u003cSchemaRef\u003e\u003e,\r\n\r\n    /// Nullable flag\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub nullable: Option\u003cbool\u003e,\r\n    /// Read-only flag\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub read_only: Option\u003cbool\u003e,\r\n    /// Write-only flag\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub write_only: Option\u003cbool\u003e,\r\n    /// External documentation reference\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub external_docs: Option\u003cExternalDocumentation\u003e,\r\n\r\n    // JSON Schema 2020-12 dynamic references\r\n    /// Definitions ($defs) - reusable schema definitions\r\n    #[serde(rename = \"$defs\")]\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub defs: Option\u003cBTreeMap\u003cString, Schema\u003e\u003e,\r\n    /// Dynamic anchor ($dynamicAnchor) - defines a dynamic anchor\r\n    #[serde(rename = \"$dynamicAnchor\")]\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub dynamic_anchor: Option\u003cString\u003e,\r\n    /// Dynamic reference ($dynamicRef) - references a dynamic anchor\r\n    #[serde(rename = \"$dynamicRef\")]\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub dynamic_ref: Option\u003cString\u003e,\r\n}\r\n\r\nimpl Schema {\r\n    /// Create a new schema\r\n    pub fn new(schema_type: SchemaType) -\u003e Self {\r\n        Self {\r\n            ref_path: None,\r\n            schema_type: Some(schema_type),\r\n            format: None,\r\n            title: None,\r\n            description: None,\r\n            default: None,\r\n            example: None,\r\n            examples: None,\r\n            minimum: None,\r\n            maximum: None,\r\n            exclusive_minimum: None,\r\n            exclusive_maximum: None,\r\n            multiple_of: None,\r\n            min_length: None,\r\n            max_length: None,\r\n            pattern: None,\r\n            items: None,\r\n            prefix_items: None,\r\n            min_items: None,\r\n            max_items: None,\r\n            unique_items: None,\r\n            properties: None,\r\n            required: None,\r\n            additional_properties: None,\r\n            min_properties: None,\r\n            max_properties: None,\r\n            r#enum: None,\r\n            all_of: None,\r\n            any_of: None,\r\n            one_of: None,\r\n            not: None,\r\n            nullable: None,\r\n            read_only: None,\r\n            write_only: None,\r\n            external_docs: None,\r\n            defs: None,\r\n            dynamic_anchor: None,\r\n            dynamic_ref: None,\r\n        }\r\n    }\r\n\r\n    /// Create a string schema\r\n    pub fn string() -\u003e Self {\r\n        Self::new(SchemaType::String)\r\n    }\r\n\r\n    /// Create an integer schema\r\n    pub fn integer() -\u003e Self {\r\n        Self::new(SchemaType::Integer)\r\n    }\r\n\r\n    /// Create a number schema\r\n    pub fn number() -\u003e Self {\r\n        Self::new(SchemaType::Number)\r\n    }\r\n\r\n    /// Create a boolean schema\r\n    pub fn boolean() -\u003e Self {\r\n        Self::new(SchemaType::Boolean)\r\n    }\r\n\r\n    /// Create an array schema\r\n    pub fn array(items: SchemaRef) -\u003e Self {\r\n        Self {\r\n            items: Some(Box::new(items)),\r\n            ..Self::new(SchemaType::Array)\r\n        }\r\n    }\r\n\r\n    /// Create an object schema\r\n    pub fn object() -\u003e Self {\r\n        Self {\r\n            properties: Some(BTreeMap::new()),\r\n            required: Some(Vec::new()),\r\n            ..Self::new(SchemaType::Object)\r\n        }\r\n    }\r\n}\r\n\r\n/// External documentation reference\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct ExternalDocumentation {\r\n    /// Documentation description\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub description: Option\u003cString\u003e,\r\n    /// Documentation URL\r\n    pub url: String,\r\n}\r\n\r\n/// OpenAPI Components (reusable components)\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct Components {\r\n    /// Schema definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub schemas: Option\u003cBTreeMap\u003cString, Schema\u003e\u003e,\r\n    /// Response definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub responses: Option\u003cHashMap\u003cString, crate::route::Response\u003e\u003e,\r\n    /// Parameter definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub parameters: Option\u003cHashMap\u003cString, crate::route::Parameter\u003e\u003e,\r\n    /// Example definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub examples: Option\u003cHashMap\u003cString, crate::route::Example\u003e\u003e,\r\n    /// Request body definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub request_bodies: Option\u003cHashMap\u003cString, crate::route::RequestBody\u003e\u003e,\r\n    /// Header definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub headers: Option\u003cHashMap\u003cString, crate::route::Header\u003e\u003e,\r\n    /// Security scheme definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub security_schemes: Option\u003cHashMap\u003cString, SecurityScheme\u003e\u003e,\r\n}\r\n\r\n/// Security scheme type\r\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub enum SecuritySchemeType {\r\n    ApiKey,\r\n    Http,\r\n    MutualTls,\r\n    OAuth2,\r\n    OpenIdConnect,\r\n}\r\n\r\n/// Security scheme definition\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct SecurityScheme {\r\n    /// Security scheme type\r\n    pub r#type: SecuritySchemeType,\r\n    /// Description\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub description: Option\u003cString\u003e,\r\n    /// Name (for API Key)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub name: Option\u003cString\u003e,\r\n    /// Location (for API Key: query, header, cookie)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub r#in: Option\u003cString\u003e,\r\n    /// Scheme (for HTTP: bearer, basic, etc.)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub scheme: Option\u003cString\u003e,\r\n    /// Bearer format (for HTTP Bearer)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub bearer_format: Option\u003cString\u003e,\r\n}\r\n\r\n/// Builder trait for types that can be converted to OpenAPI Schema\r\npub trait SchemaBuilder: Sized {\r\n    // This trait is used as a marker for derive macro\r\n    // The actual schema conversion will be implemented separately\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use rstest::rstest;\r\n\r\n    #[rstest]\r\n    #[case(Schema::string(), SchemaType::String)]\r\n    #[case(Schema::integer(), SchemaType::Integer)]\r\n    #[case(Schema::number(), SchemaType::Number)]\r\n    #[case(Schema::boolean(), SchemaType::Boolean)]\r\n    fn primitive_helpers_set_schema_type(#[case] schema: Schema, #[case] expected: SchemaType) {\r\n        assert_eq!(schema.schema_type, Some(expected));\r\n    }\r\n\r\n    #[test]\r\n    fn array_helper_sets_type_and_items() {\r\n        let item_schema = Schema::boolean();\r\n        let schema = Schema::array(SchemaRef::Inline(Box::new(item_schema.clone())));\r\n\r\n        assert_eq!(schema.schema_type, Some(SchemaType::Array));\r\n        let items = schema.items.expect(\"items should be set\");\r\n        match *items {\r\n            SchemaRef::Inline(inner) =\u003e {\r\n                assert_eq!(inner.schema_type, Some(SchemaType::Boolean));\r\n            }\r\n            SchemaRef::Ref(_) =\u003e panic!(\"array helper should set inline items\"),\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn object_helper_initializes_collections() {\r\n        let schema = Schema::object();\r\n\r\n        assert_eq!(schema.schema_type, Some(SchemaType::Object));\r\n        let props = schema.properties.expect(\"properties should be initialized\");\r\n        assert!(props.is_empty());\r\n        let required = schema.required.expect(\"required should be initialized\");\r\n        assert!(required.is_empty());\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":31,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":32,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":216,"address":[],"length":0,"stats":{"Line":11745387828182253568}},{"line":219,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":260,"address":[],"length":0,"stats":{"Line":5692549928996306944}},{"line":261,"address":[],"length":0,"stats":{"Line":11385099857992613888}},{"line":265,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":266,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":270,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":271,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":275,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":276,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":280,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":282,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":288,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":290,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":291,"address":[],"length":0,"stats":{"Line":4035225266123964416}}],"covered":18,"coverable":18},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","args.rs"],"content":"pub struct RouteArgs {\r\n    pub method: Option\u003csyn::Ident\u003e,\r\n    pub path: Option\u003csyn::LitStr\u003e,\r\n    pub error_status: Option\u003csyn::ExprArray\u003e,\r\n    pub tags: Option\u003csyn::ExprArray\u003e,\r\n    pub description: Option\u003csyn::LitStr\u003e,\r\n}\r\n\r\nimpl syn::parse::Parse for RouteArgs {\r\n    fn parse(input: syn::parse::ParseStream) -\u003e syn::Result\u003cSelf\u003e {\r\n        let mut method: Option\u003csyn::Ident\u003e = None;\r\n        let mut path: Option\u003csyn::LitStr\u003e = None;\r\n        let mut error_status: Option\u003csyn::ExprArray\u003e = None;\r\n        let mut tags: Option\u003csyn::ExprArray\u003e = None;\r\n        let mut description: Option\u003csyn::LitStr\u003e = None;\r\n\r\n        // Parse comma-separated list of arguments\r\n        while !input.is_empty() {\r\n            let lookahead = input.lookahead1();\r\n\r\n            if lookahead.peek(syn::Ident) {\r\n                // Try to parse as method identifier (get, post, etc.)\r\n                let ident: syn::Ident = input.parse()?;\r\n                let ident_str = ident.to_string().to_lowercase();\r\n                match ident_str.as_str() {\r\n                    \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\" | \"head\" | \"options\" =\u003e {\r\n                        method = Some(ident);\r\n                    }\r\n                    \"path\" =\u003e {\r\n                        input.parse::\u003csyn::Token![=]\u003e()?;\r\n                        let lit: syn::LitStr = input.parse()?;\r\n                        path = Some(lit);\r\n                    }\r\n                    \"error_status\" =\u003e {\r\n                        input.parse::\u003csyn::Token![=]\u003e()?;\r\n                        let array: syn::ExprArray = input.parse()?;\r\n                        error_status = Some(array);\r\n                    }\r\n                    \"tags\" =\u003e {\r\n                        input.parse::\u003csyn::Token![=]\u003e()?;\r\n                        let array: syn::ExprArray = input.parse()?;\r\n                        tags = Some(array);\r\n                    }\r\n                    \"description\" =\u003e {\r\n                        input.parse::\u003csyn::Token![=]\u003e()?;\r\n                        let lit: syn::LitStr = input.parse()?;\r\n                        description = Some(lit);\r\n                    }\r\n                    _ =\u003e {\r\n                        return Err(lookahead.error());\r\n                    }\r\n                }\r\n\r\n                // Check if there's a comma\r\n                if input.peek(syn::Token![,]) {\r\n                    input.parse::\u003csyn::Token![,]\u003e()?;\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                return Err(lookahead.error());\r\n            }\r\n        }\r\n\r\n        Ok(RouteArgs {\r\n            method,\r\n            path,\r\n            error_status,\r\n            tags,\r\n            description,\r\n        })\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use rstest::rstest;\r\n\r\n    #[rstest]\r\n    // Method only\r\n    #[case(\"get\", true, Some(\"get\"), None, None)]\r\n    #[case(\"post\", true, Some(\"post\"), None, None)]\r\n    #[case(\"put\", true, Some(\"put\"), None, None)]\r\n    #[case(\"patch\", true, Some(\"patch\"), None, None)]\r\n    #[case(\"delete\", true, Some(\"delete\"), None, None)]\r\n    #[case(\"head\", true, Some(\"head\"), None, None)]\r\n    #[case(\"options\", true, Some(\"options\"), None, None)]\r\n    // Path only\r\n    #[case(\"path = \\\"/api\\\"\", true, None, Some(\"/api\"), None)]\r\n    #[case(\"path = \\\"/users\\\"\", true, None, Some(\"/users\"), None)]\r\n    #[case(\"path = \\\"/api/v1\\\"\", true, None, Some(\"/api/v1\"), None)]\r\n    // Method and path\r\n    #[case(\"get, path = \\\"/api\\\"\", true, Some(\"get\"), Some(\"/api\"), None)]\r\n    #[case(\"post, path = \\\"/users\\\"\", true, Some(\"post\"), Some(\"/users\"), None)]\r\n    #[case(\"path = \\\"/api\\\", get\", true, Some(\"get\"), Some(\"/api\"), None)]\r\n    // Error status only\r\n    #[case(\"error_status = [400]\", true, None, None, Some(vec![400]))]\r\n    #[case(\"error_status = [400, 404]\", true, None, None, Some(vec![400, 404]))]\r\n    #[case(\"error_status = [400, 404, 500]\", true, None, None, Some(vec![400, 404, 500]))]\r\n    // Method and error_status\r\n    #[case(\"get, error_status = [400]\", true, Some(\"get\"), None, Some(vec![400]))]\r\n    #[case(\"post, error_status = [400, 404]\", true, Some(\"post\"), None, Some(vec![400, 404]))]\r\n    // Path and error_status\r\n    #[case(\"path = \\\"/api\\\", error_status = [400]\", true, None, Some(\"/api\"), Some(vec![400]))]\r\n    // All three\r\n    #[case(\"get, path = \\\"/api\\\", error_status = [400]\", true, Some(\"get\"), Some(\"/api\"), Some(vec![400]))]\r\n    #[case(\"post, path = \\\"/users\\\", error_status = [400, 404]\", true, Some(\"post\"), Some(\"/users\"), Some(vec![400, 404]))]\r\n    #[case(\"path = \\\"/api\\\", get, error_status = [400]\", true, Some(\"get\"), Some(\"/api\"), Some(vec![400]))]\r\n    // Empty input\r\n    #[case(\"\", true, None, None, None)]\r\n    // Invalid cases\r\n    #[case(\"invalid\", false, None, None, None)]\r\n    #[case(\"path\", false, None, None, None)]\r\n    #[case(\"error_status\", false, None, None, None)]\r\n    #[case(\"get, invalid\", false, None, None, None)]\r\n    #[case(\"path =\", false, None, None, None)]\r\n    #[case(\"error_status =\", false, None, None, None)]\r\n    // Non-Ident tokens (should trigger line 40)\r\n    #[case(\"123\", false, None, None, None)]\r\n    #[case(\"\\\"string\\\"\", false, None, None, None)]\r\n    #[case(\"=\", false, None, None, None)]\r\n    #[case(\"[\", false, None, None, None)]\r\n    #[case(\"]\", false, None, None, None)]\r\n    #[case(\",\", false, None, None, None)]\r\n    #[case(\"get, 123\", false, None, None, None)]\r\n    #[case(\"get, =\", false, None, None, None)]\r\n    fn test_route_args_parse(\r\n        #[case] input: \u0026str,\r\n        #[case] should_parse: bool,\r\n        #[case] expected_method: Option\u003c\u0026str\u003e,\r\n        #[case] expected_path: Option\u003c\u0026str\u003e,\r\n        #[case] expected_error_status: Option\u003cVec\u003cu16\u003e\u003e,\r\n    ) {\r\n        let result = syn::parse_str::\u003cRouteArgs\u003e(input);\r\n\r\n        match (should_parse, result) {\r\n            (true, Ok(route_args)) =\u003e {\r\n                // Check method\r\n                if let Some(exp_method) = expected_method {\r\n                    assert!(\r\n                        route_args.method.is_some(),\r\n                        \"Expected method {} but got None for input: {}\",\r\n                        exp_method,\r\n                        input\r\n                    );\r\n                    assert_eq!(\r\n                        route_args.method.as_ref().unwrap().to_string(),\r\n                        exp_method,\r\n                        \"Method mismatch for input: {}\",\r\n                        input\r\n                    );\r\n                } else {\r\n                    assert!(\r\n                        route_args.method.is_none(),\r\n                        \"Expected no method but got {:?} for input: {}\",\r\n                        route_args.method,\r\n                        input\r\n                    );\r\n                }\r\n\r\n                // Check path\r\n                if let Some(exp_path) = expected_path {\r\n                    assert!(\r\n                        route_args.path.is_some(),\r\n                        \"Expected path {} but got None for input: {}\",\r\n                        exp_path,\r\n                        input\r\n                    );\r\n                    assert_eq!(\r\n                        route_args.path.as_ref().unwrap().value(),\r\n                        exp_path,\r\n                        \"Path mismatch for input: {}\",\r\n                        input\r\n                    );\r\n                } else {\r\n                    assert!(\r\n                        route_args.path.is_none(),\r\n                        \"Expected no path but got {:?} for input: {}\",\r\n                        route_args.path,\r\n                        input\r\n                    );\r\n                }\r\n\r\n                // Check error_status\r\n                if let Some(exp_status) = expected_error_status {\r\n                    assert!(\r\n                        route_args.error_status.is_some(),\r\n                        \"Expected error_status {:?} but got None for input: {}\",\r\n                        exp_status,\r\n                        input\r\n                    );\r\n                    let array = route_args.error_status.as_ref().unwrap();\r\n                    let mut status_codes = Vec::new();\r\n                    for elem in \u0026array.elems {\r\n                        if let syn::Expr::Lit(syn::ExprLit {\r\n                            lit: syn::Lit::Int(lit_int),\r\n                            ..\r\n                        }) = elem\r\n                            \u0026\u0026 let Ok(code) = lit_int.base10_parse::\u003cu16\u003e()\r\n                        {\r\n                            status_codes.push(code);\r\n                        }\r\n                    }\r\n                    assert_eq!(\r\n                        status_codes, exp_status,\r\n                        \"Error status mismatch for input: {}\",\r\n                        input\r\n                    );\r\n                } else {\r\n                    assert!(\r\n                        route_args.error_status.is_none(),\r\n                        \"Expected no error_status but got {:?} for input: {}\",\r\n                        route_args.error_status,\r\n                        input\r\n                    );\r\n                }\r\n            }\r\n            (false, Err(_)) =\u003e {\r\n                // Expected error, test passes\r\n            }\r\n            (true, Err(e)) =\u003e {\r\n                panic!(\r\n                    \"Expected successful parse but got error: {} for input: {}\",\r\n                    e, input\r\n                );\r\n            }\r\n            (false, Ok(_)) =\u003e {\r\n                panic!(\"Expected parse error but got success for input: {}\", input);\r\n            }\r\n        }\r\n    }\r\n\r\n    #[rstest]\r\n    // Tags only\r\n    #[case(\"tags = [\\\"users\\\"]\", true, vec![\"users\"])]\r\n    #[case(\"tags = [\\\"users\\\", \\\"admin\\\"]\", true, vec![\"users\", \"admin\"])]\r\n    #[case(\"tags = [\\\"api\\\", \\\"v1\\\", \\\"users\\\"]\", true, vec![\"api\", \"v1\", \"users\"])]\r\n    // Tags with method\r\n    #[case(\"get, tags = [\\\"users\\\"]\", true, vec![\"users\"])]\r\n    #[case(\"post, tags = [\\\"users\\\", \\\"create\\\"]\", true, vec![\"users\", \"create\"])]\r\n    // Tags with path\r\n    #[case(\"path = \\\"/api\\\", tags = [\\\"api\\\"]\", true, vec![\"api\"])]\r\n    // Tags with method and path\r\n    #[case(\"get, path = \\\"/users\\\", tags = [\\\"users\\\"]\", true, vec![\"users\"])]\r\n    // Empty tags array\r\n    #[case(\"tags = []\", true, vec![])]\r\n    fn test_route_args_parse_tags(\r\n        #[case] input: \u0026str,\r\n        #[case] should_parse: bool,\r\n        #[case] expected_tags: Vec\u003c\u0026str\u003e,\r\n    ) {\r\n        let result = syn::parse_str::\u003cRouteArgs\u003e(input);\r\n\r\n        match (should_parse, result) {\r\n            (true, Ok(route_args)) =\u003e {\r\n                if expected_tags.is_empty() {\r\n                    // Empty array should result in Some with empty vec\r\n                    if let Some(tags_array) = \u0026route_args.tags {\r\n                        assert!(tags_array.elems.is_empty());\r\n                    }\r\n                } else {\r\n                    assert!(\r\n                        route_args.tags.is_some(),\r\n                        \"Expected tags but got None for input: {}\",\r\n                        input\r\n                    );\r\n                    let tags_array = route_args.tags.as_ref().unwrap();\r\n                    let mut parsed_tags = Vec::new();\r\n                    for elem in \u0026tags_array.elems {\r\n                        if let syn::Expr::Lit(syn::ExprLit {\r\n                            lit: syn::Lit::Str(lit_str),\r\n                            ..\r\n                        }) = elem\r\n                        {\r\n                            parsed_tags.push(lit_str.value());\r\n                        }\r\n                    }\r\n                    assert_eq!(\r\n                        parsed_tags, expected_tags,\r\n                        \"Tags mismatch for input: {}\",\r\n                        input\r\n                    );\r\n                }\r\n            }\r\n            (false, Err(_)) =\u003e {\r\n                // Expected error, test passes\r\n            }\r\n            (true, Err(e)) =\u003e {\r\n                panic!(\r\n                    \"Expected successful parse but got error: {} for input: {}\",\r\n                    e, input\r\n                );\r\n            }\r\n            (false, Ok(_)) =\u003e {\r\n                panic!(\"Expected parse error but got success for input: {}\", input);\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":11,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":12,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":13,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":14,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":15,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":18,"address":[],"length":0,"stats":{"Line":10304235947423694848}},{"line":19,"address":[],"length":0,"stats":{"Line":11817445422220181504}},{"line":21,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":23,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":24,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":25,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":26,"address":[],"length":0,"stats":{"Line":8574853690513424384}},{"line":27,"address":[],"length":0,"stats":{"Line":5692549928996306944}},{"line":29,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":30,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":31,"address":[],"length":0,"stats":{"Line":7133701809754865664}},{"line":32,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":34,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":35,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":36,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":37,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":39,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":40,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":41,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":42,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":44,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":55,"address":[],"length":0,"stats":{"Line":17870283321406128126}},{"line":56,"address":[],"length":0,"stats":{"Line":14699749183737298943}},{"line":58,"address":[],"length":0,"stats":{"Line":6196953087261802495}},{"line":61,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":65,"address":[],"length":0,"stats":{"Line":6196953087261802495}},{"line":66,"address":[],"length":0,"stats":{"Line":12393906174523604990}},{"line":67,"address":[],"length":0,"stats":{"Line":12393906174523604990}},{"line":68,"address":[],"length":0,"stats":{"Line":12393906174523604990}},{"line":69,"address":[],"length":0,"stats":{"Line":6196953087261802495}},{"line":70,"address":[],"length":0,"stats":{"Line":6196953087261802495}}],"covered":38,"coverable":41},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","collector.rs"],"content":"//! Collector for routes and structs\r\n\r\nuse crate::file_utils::{collect_files, file_to_segments};\r\nuse crate::metadata::{CollectedMetadata, RouteMetadata};\r\nuse crate::route::{extract_doc_comment, extract_route_info};\r\nuse anyhow::{Context, Result};\r\nuse std::path::Path;\r\nuse syn::Item;\r\n\r\n/// Collect routes and structs from a folder\r\npub fn collect_metadata(folder_path: \u0026Path, folder_name: \u0026str) -\u003e Result\u003cCollectedMetadata\u003e {\r\n    let mut metadata = CollectedMetadata::new();\r\n\r\n    let files = collect_files(folder_path).with_context(|| {\r\n        format!(\r\n            \"Failed to collect files from wtf: {}\",\r\n            folder_path.display()\r\n        )\r\n    })?;\r\n\r\n    for file in files {\r\n        if !file.extension().map(|e| e == \"rs\").unwrap_or(false) {\r\n            continue;\r\n        }\r\n\r\n        let content = std::fs::read_to_string(\u0026file)\r\n            .with_context(|| format!(\"Failed to read file: {}\", file.display()))?;\r\n\r\n        let file_ast = syn::parse_file(\u0026content)\r\n            .with_context(|| format!(\"Failed to parse file: {}\", file.display()))?;\r\n\r\n        // Get module path\r\n        let segments = file\r\n            .strip_prefix(folder_path)\r\n            .map(|file_stem| file_to_segments(file_stem, folder_path))\r\n            .context(format!(\r\n                \"Failed to strip prefix from file: {} (base: {})\",\r\n                file.display(),\r\n                folder_path.display()\r\n            ))?;\r\n\r\n        let module_path = if folder_name.is_empty() {\r\n            segments.join(\"::\")\r\n        } else {\r\n            format!(\"{}::{}\", folder_name, segments.join(\"::\"))\r\n        };\r\n\r\n        let file_path = file.display().to_string();\r\n\r\n        // Collect routes\r\n        for item in \u0026file_ast.items {\r\n            if let Item::Fn(fn_item) = item\r\n                \u0026\u0026 let Some(route_info) = extract_route_info(\u0026fn_item.attrs)\r\n            {\r\n                let route_path = if let Some(custom_path) = \u0026route_info.path {\r\n                    let base = format!(\"/{}\", segments.join(\"/\"));\r\n                    let trimmed_base = base.trim_end_matches('/');\r\n                    format!(\"{}/{}\", trimmed_base, custom_path.trim_start_matches('/'))\r\n                } else {\r\n                    format!(\"/{}\", segments.join(\"/\"))\r\n                };\r\n                let route_path = route_path.replace('_', \"-\");\r\n\r\n                // Description priority: route attribute \u003e doc comment\r\n                let description = route_info\r\n                    .description\r\n                    .clone()\r\n                    .or_else(|| extract_doc_comment(\u0026fn_item.attrs));\r\n\r\n                metadata.routes.push(RouteMetadata {\r\n                    method: route_info.method,\r\n                    path: route_path,\r\n                    function_name: fn_item.sig.ident.to_string(),\r\n                    module_path: module_path.clone(),\r\n                    file_path: file_path.clone(),\r\n                    signature: quote::quote!(#fn_item).to_string(),\r\n                    error_status: route_info.error_status.clone(),\r\n                    tags: route_info.tags.clone(),\r\n                    description,\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    Ok(metadata)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use rstest::rstest;\r\n    use std::fs;\r\n    use tempfile::TempDir;\r\n\r\n    fn create_temp_file(dir: \u0026TempDir, filename: \u0026str, content: \u0026str) -\u003e std::path::PathBuf {\r\n        let file_path = dir.path().join(filename);\r\n        if let Some(parent) = file_path.parent() {\r\n            fs::create_dir_all(parent).expect(\"Failed to create parent directory\");\r\n        }\r\n        fs::write(\u0026file_path, content).expect(\"Failed to write temp file\");\r\n        file_path\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_empty_folder() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert!(metadata.routes.is_empty());\r\n        assert!(metadata.structs.is_empty());\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[rstest]\r\n    #[case::single_get_route(\r\n        \"routes\",\r\n        vec![(\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        )],\r\n        \"get\",\r\n        \"/users\",\r\n        \"get_users\",\r\n        \"routes::users\",\r\n    )]\r\n    #[case::single_post_route(\r\n        \"routes\",\r\n        vec![(\r\n            \"create_user.rs\",\r\n            r#\"\r\n#[route(post)]\r\npub fn create_user() -\u003e String {\r\n    \"created\".to_string()\r\n}\r\n\"#,\r\n        )],\r\n        \"post\",\r\n        \"/create-user\",\r\n        \"create_user\",\r\n        \"routes::create_user\",\r\n    )]\r\n    #[case::route_with_custom_path(\r\n        \"routes\",\r\n        vec![(\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get, path = \"/api/users\")]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        )],\r\n        \"get\",\r\n        \"/users/api/users\",\r\n        \"get_users\",\r\n        \"routes::users\",\r\n    )]\r\n    #[case::route_with_error_status(\r\n        \"routes\",\r\n        vec![(\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get, error_status = [400, 404])]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        )],\r\n        \"get\",\r\n        \"/users\",\r\n        \"get_users\",\r\n        \"routes::users\",\r\n    )]\r\n    #[case::nested_module(\r\n        \"routes\",\r\n        vec![(\r\n            \"api/users.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        )],\r\n        \"get\",\r\n        \"/api/users\",\r\n        \"get_users\",\r\n        \"routes::api::users\",\r\n    )]\r\n    #[case::deeply_nested_module(\r\n        \"routes\",\r\n        vec![(\r\n            \"api/v1/users.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        )],\r\n        \"get\",\r\n        \"/api/v1/users\",\r\n        \"get_users\",\r\n        \"routes::api::v1::users\",\r\n    )]\r\n    fn test_collect_metadata_routes(\r\n        #[case] folder_name: \u0026str,\r\n        #[case] files: Vec\u003c(\u0026str, \u0026str)\u003e,\r\n        #[case] expected_method: \u0026str,\r\n        #[case] expected_path: \u0026str,\r\n        #[case] expected_function_name: \u0026str,\r\n        #[case] expected_module_path: \u0026str,\r\n    ) {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n\r\n        for (filename, content) in \u0026files {\r\n            create_temp_file(\u0026temp_dir, filename, content);\r\n        }\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        let route = \u0026metadata.routes[0];\r\n        assert_eq!(route.method, expected_method);\r\n        assert_eq!(route.path, expected_path);\r\n        assert_eq!(route.function_name, expected_function_name);\r\n        assert_eq!(route.module_path, expected_module_path);\r\n        if let Some((first_filename, _)) = files.first() {\r\n            assert!(\r\n                route\r\n                    .file_path\r\n                    .contains(first_filename.split('/').next().unwrap())\r\n            );\r\n        }\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_single_struct() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 0);\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_struct_without_schema() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"user.rs\",\r\n            r#\"\r\npub struct User {\r\n    pub id: i32,\r\n    pub name: String,\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 0);\r\n        assert_eq!(metadata.structs.len(), 0);\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_route_and_struct() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"user.rs\",\r\n            r#\"\r\nuse vespera::Schema;\r\n\r\n#[derive(Schema)]\r\npub struct User {\r\n    pub id: i32,\r\n    pub name: String,\r\n}\r\n\r\n#[route(get)]\r\npub fn get_user() -\u003e User {\r\n    User { id: 1, name: \"Alice\".to_string() }\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 1);\r\n\r\n        let route = \u0026metadata.routes[0];\r\n        assert_eq!(route.function_name, \"get_user\");\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_multiple_routes() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\r\n#[route(post)]\r\npub fn create_users() -\u003e String {\r\n    \"created\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"posts.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_posts() -\u003e String {\r\n    \"posts\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 3);\r\n        assert_eq!(metadata.structs.len(), 0);\r\n\r\n        // Check all routes are present\r\n        let function_names: Vec\u003c\u0026str\u003e = metadata\r\n            .routes\r\n            .iter()\r\n            .map(|r| r.function_name.as_str())\r\n            .collect();\r\n        assert!(function_names.contains(\u0026\"get_users\"));\r\n        assert!(function_names.contains(\u0026\"create_users\"));\r\n        assert!(function_names.contains(\u0026\"get_posts\"));\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_multiple_structs() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"user.rs\",\r\n            r#\"\r\nuse vespera::Schema;\r\n\r\n#[derive(Schema)]\r\npub struct User {\r\n    pub id: i32,\r\n    pub name: String,\r\n}\r\n\"#,\r\n        );\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"post.rs\",\r\n            r#\"\r\nuse vespera::Schema;\r\n\r\n#[derive(Schema)]\r\npub struct Post {\r\n    pub id: i32,\r\n    pub title: String,\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 0);\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_with_mod_rs() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"mod.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn index() -\u003e String {\r\n    \"index\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 1);\r\n        let route = \u0026metadata.routes[0];\r\n        assert_eq!(route.function_name, \"index\");\r\n        assert_eq!(route.path, \"/\");\r\n        assert_eq!(route.module_path, \"routes::\");\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_empty_folder_name() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 1);\r\n        let route = \u0026metadata.routes[0];\r\n        assert_eq!(route.module_path, \"users\");\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_ignores_non_rs_files() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        create_temp_file(\u0026temp_dir, \"config.txt\", \"some config content\");\r\n\r\n        create_temp_file(\u0026temp_dir, \"readme.md\", \"# Readme\");\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        // Only .rs file should be processed\r\n        assert_eq!(metadata.routes.len(), 1);\r\n        assert_eq!(metadata.structs.len(), 0);\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_ignores_invalid_syntax() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"valid.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        create_temp_file(\u0026temp_dir, \"invalid.rs\", \"invalid rust syntax {\");\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name);\r\n\r\n        // Only valid file should be processed\r\n        assert!(metadata.is_err());\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_error_status() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get, error_status = [400, 404, 500])]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 1);\r\n        let route = \u0026metadata.routes[0];\r\n        assert_eq!(route.method, \"get\");\r\n        assert!(route.error_status.is_some());\r\n        let error_status = route.error_status.as_ref().unwrap();\r\n        assert_eq!(error_status.len(), 3);\r\n        assert!(error_status.contains(\u0026400));\r\n        assert!(error_status.contains(\u0026404));\r\n        assert!(error_status.contains(\u0026500));\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_all_http_methods() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"routes.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_handler() -\u003e String { \"get\".to_string() }\r\n\r\n#[route(post)]\r\npub fn post_handler() -\u003e String { \"post\".to_string() }\r\n\r\n#[route(put)]\r\npub fn put_handler() -\u003e String { \"put\".to_string() }\r\n\r\n#[route(patch)]\r\npub fn patch_handler() -\u003e String { \"patch\".to_string() }\r\n\r\n#[route(delete)]\r\npub fn delete_handler() -\u003e String { \"delete\".to_string() }\r\n\r\n#[route(head)]\r\npub fn head_handler() -\u003e String { \"head\".to_string() }\r\n\r\n#[route(options)]\r\npub fn options_handler() -\u003e String { \"options\".to_string() }\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 7);\r\n\r\n        let methods: Vec\u003c\u0026str\u003e = metadata.routes.iter().map(|r| r.method.as_str()).collect();\r\n        assert!(methods.contains(\u0026\"get\"));\r\n        assert!(methods.contains(\u0026\"post\"));\r\n        assert!(methods.contains(\u0026\"put\"));\r\n        assert!(methods.contains(\u0026\"patch\"));\r\n        assert!(methods.contains(\u0026\"delete\"));\r\n        assert!(methods.contains(\u0026\"head\"));\r\n        assert!(methods.contains(\u0026\"options\"));\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_collect_files_error() {\r\n        // Test: collect_files returns error (non-existent directory)\r\n        let non_existent_path = std::path::Path::new(\"/nonexistent/path/that/does/not/exist\");\r\n        let folder_name = \"routes\";\r\n\r\n        let result = collect_metadata(non_existent_path, folder_name);\r\n\r\n        // Should return error when collect_files fails\r\n        assert!(result.is_err());\r\n        let error_msg = result.unwrap_err().to_string();\r\n        assert!(error_msg.contains(\"Failed to collect files\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_file_read_error() {\r\n        // Test line 25: file read error\r\n        // This is difficult to test directly, but we can test with a file that becomes\r\n        // inaccessible. However, in practice, if the file exists, read_to_string usually succeeds.\r\n        // For coverage purposes, we'll create a scenario where the file might fail to read.\r\n        // Actually, this is hard to simulate reliably, so we'll skip this for now.\r\n        // The continue path is already covered by invalid syntax tests.\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_strip_prefix_error() {\r\n        // Test line 37: strip_prefix fails\r\n        // Note: This is a defensive programming path that is unlikely to be executed\r\n        // in practice because collect_files always returns files under folder_path.\r\n        // However, path normalization differences could theoretically cause this.\r\n        // For coverage purposes, we test the normal case where strip_prefix succeeds.\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        // Create a subdirectory\r\n        let sub_dir = temp_dir.path().join(\"routes\");\r\n        std::fs::create_dir_all(\u0026sub_dir).expect(\"Failed to create subdirectory\");\r\n\r\n        // Create a file in the subdirectory\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"routes/valid.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        // Collect metadata from the subdirectory\r\n        let metadata = collect_metadata(\u0026sub_dir, folder_name).unwrap();\r\n\r\n        // Should collect the route (strip_prefix succeeds in normal cases)\r\n        assert_eq!(metadata.routes.len(), 1);\r\n\r\n        // The continue path on line 37 is defensive code that handles edge cases\r\n        // where path normalization might cause strip_prefix to fail, but this is\r\n        // extremely rare in practice.\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_struct_without_derive() {\r\n        // Test line 81: attr.path().is_ident(\"derive\") returns false\r\n        // Struct with non-derive attributes should not be collected\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"user.rs\",\r\n            r#\"\r\n#[allow(dead_code)]\r\npub struct User {\r\n    pub id: i32,\r\n    pub name: String,\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        // Struct without Schema derive should not be collected\r\n        assert_eq!(metadata.structs.len(), 0);\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_struct_with_other_derive() {\r\n        // Test line 81: struct with other derive attributes (not Schema)\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"user.rs\",\r\n            r#\"\r\n#[derive(Debug, Clone)]\r\npub struct User {\r\n    pub id: i32,\r\n    pub name: String,\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        // Struct with only Debug/Clone derive (no Schema) should not be collected\r\n        assert_eq!(metadata.structs.len(), 0);\r\n\r\n        drop(temp_dir);\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":12,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":14,"address":[],"length":0,"stats":{"Line":10088063165309911040}},{"line":15,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":16,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":17,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":21,"address":[],"length":0,"stats":{"Line":7710162562058289152}},{"line":22,"address":[],"length":0,"stats":{"Line":13330654897016668160}},{"line":23,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":26,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":27,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":29,"address":[],"length":0,"stats":{"Line":7493989779944505344}},{"line":30,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":33,"address":[],"length":0,"stats":{"Line":7349874591868649472}},{"line":34,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":35,"address":[],"length":0,"stats":{"Line":9799832789158199296}},{"line":36,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":37,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":38,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":39,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":42,"address":[],"length":0,"stats":{"Line":7349874591868649472}},{"line":43,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":45,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":48,"address":[],"length":0,"stats":{"Line":7349874591868649472}},{"line":51,"address":[],"length":0,"stats":{"Line":7349874591868649471}},{"line":52,"address":[],"length":0,"stats":{"Line":4251398048237748223}},{"line":53,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":55,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":56,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":57,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":58,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":60,"address":[],"length":0,"stats":{"Line":10088063165309911040}},{"line":62,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":65,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":66,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":68,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":70,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":71,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":72,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":73,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":74,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":75,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":76,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":77,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":78,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":79,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":85,"address":[],"length":0,"stats":{"Line":2377900603251621888}}],"covered":47,"coverable":47},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","file_utils.rs"],"content":"use anyhow::{Context, Result};\nuse std::path::{Path, PathBuf};\n\npub fn collect_files(folder_path: \u0026Path) -\u003e Result\u003cVec\u003cPathBuf\u003e\u003e {\n    let mut files = Vec::new();\n    for entry in std::fs::read_dir(folder_path)\n        .with_context(|| format!(\"Failed to read directory: {}\", folder_path.display()))?\n    {\n        let entry = entry.with_context(|| \"Failed to read directory entry\")?;\n        let path = entry.path();\n        if path.is_file() {\n            files.push(folder_path.join(path));\n        } else if path.is_dir() {\n            files.extend(collect_files(\u0026folder_path.join(\u0026path))?);\n        }\n    }\n    Ok(files)\n}\n\npub fn file_to_segments(file: \u0026Path, base_path: \u0026Path) -\u003e Vec\u003cString\u003e {\n    let file_stem = if let Ok(file_stem) = file.strip_prefix(base_path) {\n        file_stem.display().to_string()\n    } else {\n        file.display().to_string()\n    };\n    let file_stem = file_stem.replace(\".rs\", \"\").replace(\"\\\\\", \"/\");\n    let mut segments: Vec\u003cString\u003e = file_stem\n        .split(\"/\")\n        .filter(|s| !s.is_empty())\n        .map(|s| s.to_string())\n        .collect();\n    if let Some(last) = segments.last()\n        \u0026\u0026 last == \"mod\"\n    {\n        segments.pop();\n    }\n    segments\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rstest::rstest;\n    use std::fs;\n    use std::path::PathBuf;\n    use tempfile::TempDir;\n\n    #[rstest]\n    // Simple file paths\n    #[case(\"routes/users.rs\", \"routes\", vec![\"users\"])]\n    #[case(\"routes/posts.rs\", \"routes\", vec![\"posts\"])]\n    #[case(\"routes/users.rs\", \"routes/\", vec![\"users\"])]\n    // Nested directories\n    #[case(\"routes/admin/users.rs\", \"routes\", vec![\"admin\", \"users\"])]\n    #[case(\"routes/api/v1/users.rs\", \"routes\", vec![\"api\", \"v1\", \"users\"])]\n    #[case(\"routes/admin/settings.rs\", \"routes\", vec![\"admin\", \"settings\"])]\n    // Deep nesting\n    #[case(\"routes/api/v1/users/profile.rs\", \"routes\", vec![\"api\", \"v1\", \"users\", \"profile\"])]\n    // mod.rs files\n    #[case(\"routes/mod.rs\", \"routes\", vec![])]\n    #[case(\"routes/admin/mod.rs\", \"routes\", vec![\"admin\"])]\n    #[case(\"routes/api/v1/mod.rs\", \"routes\", vec![\"api\", \"v1\"])]\n    // mod in middle (should not be removed)\n    #[case(\"routes/mod_users.rs\", \"routes\", vec![\"mod_users\"])]\n    // Windows-style paths (backslashes)\n    #[case(\"routes\\\\users.rs\", \"routes\", vec![\"users\"])]\n    #[case(\"routes\\\\admin\\\\users.rs\", \"routes\", vec![\"admin\", \"users\"])]\n    #[case(\"routes\\\\mod.rs\", \"routes\", vec![])]\n    // Files without .rs extension (should still work)\n    #[case(\"routes/users\", \"routes\", vec![\"users\"])]\n    #[case(\"routes/admin/users\", \"routes\", vec![\"admin\", \"users\"])]\n    // Empty segments\n    #[case(\"routes//users.rs\", \"routes\", vec![\"users\"])]\n    #[case(\"routes///admin//users.rs\", \"routes\", vec![\"admin\", \"users\"])]\n    // Base path not matching\n    #[case(\"/absolute/path/users.rs\", \"routes\", vec![\"absolute\", \"path\", \"users\"])]\n    #[case(\"different/path/users.rs\", \"routes\", vec![\"different\", \"path\", \"users\"])]\n    // Root level files\n    #[case(\"users.rs\", \".\", vec![\"users\"])]\n    #[case(\"mod.rs\", \".\", vec![])]\n    fn test_file_to_segments(\n        #[case] file_path: \u0026str,\n        #[case] base_path: \u0026str,\n        #[case] expected: Vec\u003c\u0026str\u003e,\n    ) {\n        // Normalize paths by replacing backslashes with forward slashes\n        // This ensures tests work cross-platform (Windows uses \\, Unix uses /)\n        let normalized_file_path = file_path.replace(\"\\\\\", \"/\");\n        let normalized_base_path = base_path.replace(\"\\\\\", \"/\");\n        let file = PathBuf::from(normalized_file_path);\n        let base = PathBuf::from(normalized_base_path);\n        let result = file_to_segments(\u0026file, \u0026base);\n        let expected_vec: Vec\u003cString\u003e = expected.iter().map(|s| s.to_string()).collect();\n        assert_eq!(\n            result, expected_vec,\n            \"Failed for file: {}, base: {}\",\n            file_path, base_path\n        );\n    }\n\n    fn create_test_structure(\n        temp_dir: \u0026TempDir,\n        structure: \u0026[(\u0026str, bool)],\n    ) -\u003e Result\u003c(), std::io::Error\u003e {\n        // (path, is_file)\n        for (path, is_file) in structure {\n            let full_path = temp_dir.path().join(path);\n            if *is_file {\n                if let Some(parent) = full_path.parent() {\n                    fs::create_dir_all(parent)?;\n                }\n                fs::write(\u0026full_path, \"test content\")?;\n            } else {\n                fs::create_dir_all(\u0026full_path)?;\n            }\n        }\n        Ok(())\n    }\n\n    fn normalize_paths(paths: \u0026[PathBuf], base: \u0026Path) -\u003e Vec\u003cString\u003e {\n        let mut normalized: Vec\u003cString\u003e = paths\n            .iter()\n            .map(|p| {\n                p.strip_prefix(base)\n                    .unwrap_or(p)\n                    .to_string_lossy()\n                    .replace(\"\\\\\", \"/\")\n            })\n            .collect();\n        normalized.sort();\n        normalized\n    }\n\n    #[rstest]\n    // Empty directory\n    #[case(vec![], vec![])]\n    // Single file\n    #[case(vec![(\"file1.rs\", true)], vec![\"file1.rs\"])]\n    // Multiple files in root\n    #[case(\n        vec![(\"file1.rs\", true), (\"file2.rs\", true), (\"file3.rs\", true)],\n        vec![\"file1.rs\", \"file2.rs\", \"file3.rs\"]\n    )]\n    // Single nested directory with file\n    #[case(\n        vec![(\"subdir\", false), (\"subdir/file.rs\", true)],\n        vec![\"subdir/file.rs\"]\n    )]\n    // Multiple nested directories\n    #[case(\n        vec![\n            (\"dir1\", false),\n            (\"dir1/file1.rs\", true),\n            (\"dir2\", false),\n            (\"dir2/file2.rs\", true),\n        ],\n        vec![\"dir1/file1.rs\", \"dir2/file2.rs\"]\n    )]\n    // Deep nesting\n    #[case(\n        vec![\n            (\"a\", false),\n            (\"a/b\", false),\n            (\"a/b/c\", false),\n            (\"a/b/c/file.rs\", true),\n        ],\n        vec![\"a/b/c/file.rs\"]\n    )]\n    // Mixed structure\n    #[case(\n        vec![\n            (\"root.rs\", true),\n            (\"dir1\", false),\n            (\"dir1/file1.rs\", true),\n            (\"dir1/file2.rs\", true),\n            (\"dir2\", false),\n            (\"dir2/subdir\", false),\n            (\"dir2/subdir/file.rs\", true),\n        ],\n        vec![\"dir1/file1.rs\", \"dir1/file2.rs\", \"dir2/subdir/file.rs\", \"root.rs\"]\n    )]\n    // Files with different extensions\n    #[case(\n        vec![\n            (\"file.rs\", true),\n            (\"file.txt\", true),\n            (\"file.md\", true),\n        ],\n        vec![\"file.md\", \"file.rs\", \"file.txt\"]\n    )]\n    // Empty subdirectories (should be ignored)\n    #[case(\n        vec![\n            (\"empty_dir\", false),\n            (\"file.rs\", true),\n        ],\n        vec![\"file.rs\"]\n    )]\n    fn test_collect_files(#[case] structure: Vec\u003c(\u0026str, bool)\u003e, #[case] expected_files: Vec\u003c\u0026str\u003e) {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        create_test_structure(\u0026temp_dir, \u0026structure).expect(\"Failed to create test structure\");\n\n        let result = collect_files(temp_dir.path()).expect(\"collect_files failed\");\n        let mut normalized_result = normalize_paths(\u0026result, temp_dir.path());\n        normalized_result.sort();\n\n        let mut expected_normalized: Vec\u003cString\u003e =\n            expected_files.iter().map(|s| s.to_string()).collect();\n        expected_normalized.sort();\n\n        assert_eq!(\n            normalized_result, expected_normalized,\n            \"Failed for structure: {:?}\",\n            structure\n        );\n\n        temp_dir.close().expect(\"Failed to close temp dir\");\n    }\n\n    #[test]\n    fn test_collect_files_nonexistent_directory() {\n        let nonexistent = PathBuf::from(\"/nonexistent/path/that/does/not/exist\");\n        let result = collect_files(\u0026nonexistent);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_collect_files_recursive_deep() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n\n        // Create a very deep nested structure\n        let mut path = temp_dir.path().to_path_buf();\n        for i in 0..5 {\n            path = path.join(format!(\"level{}\", i));\n            fs::create_dir_all(\u0026path).expect(\"Failed to create nested dir\");\n        }\n\n        // Create a file at the deepest level\n        let file_path = path.join(\"deep_file.rs\");\n        fs::write(\u0026file_path, \"content\").expect(\"Failed to write file\");\n\n        let result = collect_files(temp_dir.path()).expect(\"collect_files failed\");\n        assert_eq!(result.len(), 1);\n        assert!(result[0].ends_with(\"deep_file.rs\"));\n\n        temp_dir.close().expect(\"Failed to close temp dir\");\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":4827858800541171712}},{"line":5,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":6,"address":[],"length":0,"stats":{"Line":15132094747964866560}},{"line":7,"address":[],"length":0,"stats":{"Line":5548434740920451072}},{"line":9,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":10,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":11,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":12,"address":[],"length":0,"stats":{"Line":15852670688344145920}},{"line":13,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":14,"address":[],"length":0,"stats":{"Line":6052837899185946623}},{"line":17,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":20,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":21,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":22,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":24,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":26,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":27,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":29,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":30,"address":[],"length":0,"stats":{"Line":15420325124116578304}},{"line":32,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":33,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":35,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":37,"address":[],"length":0,"stats":{"Line":4035225266123964416}}],"covered":23,"coverable":23},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","lib.rs"],"content":"mod args;\nmod collector;\nmod file_utils;\nmod metadata;\nmod method;\nmod openapi_generator;\nmod parser;\nmod route;\n\nuse proc_macro::TokenStream;\nuse proc_macro2::Span;\nuse quote::quote;\nuse std::path::Path;\nuse std::sync::{LazyLock, Mutex};\nuse syn::LitStr;\nuse syn::bracketed;\nuse syn::parse::{Parse, ParseStream};\nuse syn::punctuated::Punctuated;\n\nuse crate::collector::collect_metadata;\nuse crate::metadata::{CollectedMetadata, StructMetadata};\nuse crate::method::http_method_to_token_stream;\nuse crate::openapi_generator::generate_openapi_doc_with_metadata;\nuse vespera_core::openapi::Server;\nuse vespera_core::route::HttpMethod;\n\n/// route attribute macro\n#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -\u003e TokenStream {\n    // Validate attribute arguments\n    if let Err(e) = syn::parse::\u003cargs::RouteArgs\u003e(attr) {\n        return e.to_compile_error().into();\n    }\n\n    // Validate that item is a function\n    let item_fn = match syn::parse::\u003csyn::ItemFn\u003e(item.clone()) {\n        Ok(f) =\u003e f,\n        Err(e) =\u003e {\n            return syn::Error::new(e.span(), \"route attribute can only be applied to functions\")\n                .to_compile_error()\n                .into();\n        }\n    };\n\n    // Validate function is pub\n    if !matches!(item_fn.vis, syn::Visibility::Public(_)) {\n        return syn::Error::new_spanned(item_fn.sig.fn_token, \"route function must be public\")\n            .to_compile_error()\n            .into();\n    }\n\n    // Validate function is async\n    if item_fn.sig.asyncness.is_none() {\n        return syn::Error::new_spanned(item_fn.sig.fn_token, \"route function must be async\")\n            .to_compile_error()\n            .into();\n    }\n\n    item\n}\n\n// Schema Storage global variable\nstatic SCHEMA_STORAGE: LazyLock\u003cMutex\u003cVec\u003cStructMetadata\u003e\u003e\u003e =\n    LazyLock::new(|| Mutex::new(Vec::new()));\n\n/// Derive macro for Schema\n#[proc_macro_derive(Schema)]\npub fn derive_schema(input: TokenStream) -\u003e TokenStream {\n    let input = syn::parse_macro_input!(input as syn::DeriveInput);\n    let name = \u0026input.ident;\n    let generics = \u0026input.generics;\n\n    let mut schema_storage = SCHEMA_STORAGE.lock().unwrap();\n    schema_storage.push(StructMetadata {\n        name: name.to_string(),\n        definition: quote::quote!(#input).to_string(),\n    });\n\n    // Mark both struct and enum as having SchemaBuilder\n    // For generic types, include the generic parameters in the impl\n    // The actual schema generation will be done at runtime\n    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n    let expanded = quote! {\n        impl #impl_generics vespera::schema::SchemaBuilder for #name #ty_generics #where_clause {}\n    };\n\n    TokenStream::from(expanded)\n}\n\n/// Server configuration for OpenAPI\n#[derive(Clone)]\nstruct ServerConfig {\n    url: String,\n    description: Option\u003cString\u003e,\n}\n\nstruct AutoRouterInput {\n    dir: Option\u003cLitStr\u003e,\n    openapi: Option\u003cVec\u003cLitStr\u003e\u003e,\n    title: Option\u003cLitStr\u003e,\n    version: Option\u003cLitStr\u003e,\n    docs_url: Option\u003cLitStr\u003e,\n    redoc_url: Option\u003cLitStr\u003e,\n    servers: Option\u003cVec\u003cServerConfig\u003e\u003e,\n}\n\nimpl Parse for AutoRouterInput {\n    fn parse(input: ParseStream) -\u003e syn::Result\u003cSelf\u003e {\n        let mut dir = None;\n        let mut openapi = None;\n        let mut title = None;\n        let mut version = None;\n        let mut docs_url = None;\n        let mut redoc_url = None;\n        let mut servers = None;\n\n        while !input.is_empty() {\n            let lookahead = input.lookahead1();\n\n            if lookahead.peek(syn::Ident) {\n                let ident: syn::Ident = input.parse()?;\n                let ident_str = ident.to_string();\n\n                match ident_str.as_str() {\n                    \"dir\" =\u003e {\n                        input.parse::\u003csyn::Token![=]\u003e()?;\n                        dir = Some(input.parse()?);\n                    }\n                    \"openapi\" =\u003e {\n                        openapi = Some(parse_openapi_values(input)?);\n                    }\n                    \"docs_url\" =\u003e {\n                        input.parse::\u003csyn::Token![=]\u003e()?;\n                        docs_url = Some(input.parse()?);\n                    }\n                    \"redoc_url\" =\u003e {\n                        input.parse::\u003csyn::Token![=]\u003e()?;\n                        redoc_url = Some(input.parse()?);\n                    }\n                    \"title\" =\u003e {\n                        input.parse::\u003csyn::Token![=]\u003e()?;\n                        title = Some(input.parse()?);\n                    }\n                    \"version\" =\u003e {\n                        input.parse::\u003csyn::Token![=]\u003e()?;\n                        version = Some(input.parse()?);\n                    }\n                    \"servers\" =\u003e {\n                        servers = Some(parse_servers_values(input)?);\n                    }\n                    _ =\u003e {\n                        return Err(syn::Error::new(\n                            ident.span(),\n                            format!(\n                                \"unknown field: `{}`. Expected `dir`, `openapi`, `title`, `version`, `docs_url`, `redoc_url`, or `servers`\",\n                                ident_str\n                            ),\n                        ));\n                    }\n                }\n            } else if lookahead.peek(syn::LitStr) {\n                // If just a string, treat it as dir (for backward compatibility)\n                dir = Some(input.parse()?);\n            } else {\n                return Err(lookahead.error());\n            }\n\n            if input.peek(syn::Token![,]) {\n                input.parse::\u003csyn::Token![,]\u003e()?;\n            } else {\n                break;\n            }\n        }\n\n        Ok(AutoRouterInput {\n            dir: dir.or_else(|| {\n                std::env::var(\"VESPERA_DIR\")\n                    .map(|f| LitStr::new(\u0026f, Span::call_site()))\n                    .ok()\n            }),\n            openapi: openapi.or_else(|| {\n                std::env::var(\"VESPERA_OPENAPI\")\n                    .map(|f| vec![LitStr::new(\u0026f, Span::call_site())])\n                    .ok()\n            }),\n            title: title.or_else(|| {\n                std::env::var(\"VESPERA_TITLE\")\n                    .map(|f| LitStr::new(\u0026f, Span::call_site()))\n                    .ok()\n            }),\n            version: version\n                .or_else(|| {\n                    std::env::var(\"VESPERA_VERSION\")\n                        .map(|f| LitStr::new(\u0026f, Span::call_site()))\n                        .ok()\n                })\n                .or_else(|| {\n                    std::env::var(\"CARGO_PKG_VERSION\")\n                        .map(|f| LitStr::new(\u0026f, Span::call_site()))\n                        .ok()\n                }),\n            docs_url: docs_url.or_else(|| {\n                std::env::var(\"VESPERA_DOCS_URL\")\n                    .map(|f| LitStr::new(\u0026f, Span::call_site()))\n                    .ok()\n            }),\n            redoc_url: redoc_url.or_else(|| {\n                std::env::var(\"VESPERA_REDOC_URL\")\n                    .map(|f| LitStr::new(\u0026f, Span::call_site()))\n                    .ok()\n            }),\n            servers: servers.or_else(|| {\n                std::env::var(\"VESPERA_SERVER_URL\")\n                    .ok()\n                    .filter(|url| url.starts_with(\"http://\") || url.starts_with(\"https://\"))\n                    .map(|url| {\n                        vec![ServerConfig {\n                            url,\n                            description: std::env::var(\"VESPERA_SERVER_DESCRIPTION\").ok(),\n                        }]\n                    })\n            }),\n        })\n    }\n}\n\nfn parse_openapi_values(input: ParseStream) -\u003e syn::Result\u003cVec\u003cLitStr\u003e\u003e {\n    input.parse::\u003csyn::Token![=]\u003e()?;\n\n    if input.peek(syn::token::Bracket) {\n        let content;\n        let _ = bracketed!(content in input);\n        let entries: Punctuated\u003cLitStr, syn::Token![,]\u003e =\n            content.parse_terminated(|input| input.parse::\u003cLitStr\u003e(), syn::Token![,])?;\n        Ok(entries.into_iter().collect())\n    } else {\n        let single: LitStr = input.parse()?;\n        Ok(vec![single])\n    }\n}\n\n/// Validate that a URL starts with http:// or https://\nfn validate_server_url(url: \u0026LitStr) -\u003e syn::Result\u003cString\u003e {\n    let url_value = url.value();\n    if !url_value.starts_with(\"http://\") \u0026\u0026 !url_value.starts_with(\"https://\") {\n        return Err(syn::Error::new(\n            url.span(),\n            format!(\n                \"invalid server URL: `{}`. URL must start with `http://` or `https://`\",\n                url_value\n            ),\n        ));\n    }\n    Ok(url_value)\n}\n\n/// Parse server values in various formats:\n/// - `servers = \"url\"` - single URL\n/// - `servers = [\"url1\", \"url2\"]` - multiple URLs (strings only)\n/// - `servers = [(\"url\", \"description\")]` - tuple format with descriptions\n/// - `servers = [{url = \"...\", description = \"...\"}]` - struct-like format\n/// - `servers = {url = \"...\", description = \"...\"}` - single server struct-like format\nfn parse_servers_values(input: ParseStream) -\u003e syn::Result\u003cVec\u003cServerConfig\u003e\u003e {\n    use syn::token::{Brace, Paren};\n\n    input.parse::\u003csyn::Token![=]\u003e()?;\n\n    if input.peek(syn::token::Bracket) {\n        // Array format: [...]\n        let content;\n        let _ = bracketed!(content in input);\n\n        let mut servers = Vec::new();\n\n        while !content.is_empty() {\n            if content.peek(Paren) {\n                // Parse tuple: (\"url\", \"description\")\n                let tuple_content;\n                syn::parenthesized!(tuple_content in content);\n                let url: LitStr = tuple_content.parse()?;\n                let url_value = validate_server_url(\u0026url)?;\n                let description = if tuple_content.peek(syn::Token![,]) {\n                    tuple_content.parse::\u003csyn::Token![,]\u003e()?;\n                    Some(tuple_content.parse::\u003cLitStr\u003e()?.value())\n                } else {\n                    None\n                };\n                servers.push(ServerConfig {\n                    url: url_value,\n                    description,\n                });\n            } else if content.peek(Brace) {\n                // Parse struct-like: {url = \"...\", description = \"...\"}\n                let server = parse_server_struct(\u0026content)?;\n                servers.push(server);\n            } else {\n                // Parse simple string: \"url\"\n                let url: LitStr = content.parse()?;\n                let url_value = validate_server_url(\u0026url)?;\n                servers.push(ServerConfig {\n                    url: url_value,\n                    description: None,\n                });\n            }\n\n            if content.peek(syn::Token![,]) {\n                content.parse::\u003csyn::Token![,]\u003e()?;\n            } else {\n                break;\n            }\n        }\n\n        Ok(servers)\n    } else if input.peek(syn::token::Brace) {\n        // Single struct-like format: servers = {url = \"...\", description = \"...\"}\n        let server = parse_server_struct(input)?;\n        Ok(vec![server])\n    } else {\n        // Single string: servers = \"url\"\n        let single: LitStr = input.parse()?;\n        let url_value = validate_server_url(\u0026single)?;\n        Ok(vec![ServerConfig {\n            url: url_value,\n            description: None,\n        }])\n    }\n}\n\n/// Parse a single server in struct-like format: {url = \"...\", description = \"...\"}\nfn parse_server_struct(input: ParseStream) -\u003e syn::Result\u003cServerConfig\u003e {\n    let content;\n    syn::braced!(content in input);\n\n    let mut url: Option\u003cString\u003e = None;\n    let mut description: Option\u003cString\u003e = None;\n\n    while !content.is_empty() {\n        let ident: syn::Ident = content.parse()?;\n        let ident_str = ident.to_string();\n\n        match ident_str.as_str() {\n            \"url\" =\u003e {\n                content.parse::\u003csyn::Token![=]\u003e()?;\n                let url_lit: LitStr = content.parse()?;\n                url = Some(validate_server_url(\u0026url_lit)?);\n            }\n            \"description\" =\u003e {\n                content.parse::\u003csyn::Token![=]\u003e()?;\n                description = Some(content.parse::\u003cLitStr\u003e()?.value());\n            }\n            _ =\u003e {\n                return Err(syn::Error::new(\n                    ident.span(),\n                    format!(\n                        \"unknown field: `{}`. Expected `url` or `description`\",\n                        ident_str\n                    ),\n                ));\n            }\n        }\n\n        if content.peek(syn::Token![,]) {\n            content.parse::\u003csyn::Token![,]\u003e()?;\n        } else {\n            break;\n        }\n    }\n\n    let url = url.ok_or_else(|| {\n        syn::Error::new(\n            proc_macro2::Span::call_site(),\n            \"server config requires `url` field\",\n        )\n    })?;\n\n    Ok(ServerConfig { url, description })\n}\n\n#[proc_macro]\npub fn vespera(input: TokenStream) -\u003e TokenStream {\n    let input = syn::parse_macro_input!(input as AutoRouterInput);\n\n    let folder_name = input\n        .dir\n        .map(|f| f.value())\n        .unwrap_or_else(|| \"routes\".to_string());\n\n    let openapi_file_names = input\n        .openapi\n        .unwrap_or_default()\n        .into_iter()\n        .map(|f| f.value())\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let title = input.title.map(|t| t.value());\n    let version = input.version.map(|v| v.value());\n    let docs_url = input.docs_url.map(|u| u.value());\n    let redoc_url = input.redoc_url.map(|u| u.value());\n    let servers = input.servers.map(|svrs| {\n        svrs.into_iter()\n            .map(|s| Server {\n                url: s.url,\n                description: s.description,\n                variables: None,\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e()\n    });\n\n    let folder_path = find_folder_path(\u0026folder_name);\n\n    if !folder_path.exists() {\n        return syn::Error::new(\n            Span::call_site(),\n            format!(\"Folder not found: {}\", folder_name),\n        )\n        .to_compile_error()\n        .into();\n    }\n\n    let mut metadata = match collect_metadata(\u0026folder_path, \u0026folder_name) {\n        Ok(metadata) =\u003e metadata,\n        Err(e) =\u003e {\n            return syn::Error::new(\n                Span::call_site(),\n                format!(\"Failed to collect metadata: {}\", e),\n            )\n            .to_compile_error()\n            .into();\n        }\n    };\n    let schemas = SCHEMA_STORAGE.lock().unwrap().clone();\n\n    metadata.structs.extend(schemas);\n\n    let mut docs_info = None;\n    let mut redoc_info = None;\n\n    if !openapi_file_names.is_empty() || docs_url.is_some() || redoc_url.is_some() {\n        // Generate OpenAPI document using collected metadata\n\n        // Serialize to JSON\n        let json_str = match serde_json::to_string_pretty(\u0026generate_openapi_doc_with_metadata(\n            title, version, servers, \u0026metadata,\n        )) {\n            Ok(json) =\u003e json,\n            Err(e) =\u003e {\n                return syn::Error::new(\n                    Span::call_site(),\n                    format!(\"Failed to serialize OpenAPI document: {}\", e),\n                )\n                .to_compile_error()\n                .into();\n            }\n        };\n        for openapi_file_name in \u0026openapi_file_names {\n            // create directory if not exists\n            let file_path = Path::new(openapi_file_name);\n            if let Some(parent) = file_path.parent() {\n                std::fs::create_dir_all(parent).expect(\"Failed to create parent directory\");\n            }\n\n            if let Err(e) = std::fs::write(file_path, \u0026json_str) {\n                return syn::Error::new(\n                    Span::call_site(),\n                    format!(\n                        \"Failed to write OpenAPI document to {}: {}\",\n                        openapi_file_name, e\n                    ),\n                )\n                .to_compile_error()\n                .into();\n            }\n        }\n        if let Some(docs_url) = docs_url {\n            docs_info = Some((docs_url, json_str.clone()));\n        }\n        if let Some(redoc_url) = redoc_url {\n            redoc_info = Some((redoc_url, json_str));\n        }\n    }\n\n    generate_router_code(\u0026metadata, docs_info, redoc_info).into()\n}\n\nfn find_folder_path(folder_name: \u0026str) -\u003e std::path::PathBuf {\n    let root = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n    let path = format!(\"{}/src/{}\", root, folder_name);\n    let path = Path::new(\u0026path);\n    if path.exists() \u0026\u0026 path.is_dir() {\n        return path.to_path_buf();\n    }\n\n    Path::new(folder_name).to_path_buf()\n}\n\nfn generate_router_code(\n    metadata: \u0026CollectedMetadata,\n    docs_info: Option\u003c(String, String)\u003e,\n    redoc_info: Option\u003c(String, String)\u003e,\n) -\u003e proc_macro2::TokenStream {\n    let mut router_nests = Vec::new();\n\n    for route in \u0026metadata.routes {\n        let http_method = HttpMethod::from(route.method.as_str());\n        let method_path = http_method_to_token_stream(http_method);\n        let path = \u0026route.path;\n        let module_path = \u0026route.module_path;\n        let function_name = \u0026route.function_name;\n\n        let mut p: syn::punctuated::Punctuated\u003csyn::PathSegment, syn::Token![::]\u003e =\n            syn::punctuated::Punctuated::new();\n        p.push(syn::PathSegment {\n            ident: syn::Ident::new(\"crate\", Span::call_site()),\n            arguments: syn::PathArguments::None,\n        });\n        p.extend(\n            module_path\n                .split(\"::\")\n                .filter_map(|s| {\n                    if s.is_empty() {\n                        None\n                    } else {\n                        Some(syn::PathSegment {\n                            ident: syn::Ident::new(s, Span::call_site()),\n                            arguments: syn::PathArguments::None,\n                        })\n                    }\n                })\n                .collect::\u003cVec\u003csyn::PathSegment\u003e\u003e(),\n        );\n        let func_name = syn::Ident::new(function_name, Span::call_site());\n        router_nests.push(quote!(\n            .route(#path, #method_path(#p::#func_name))\n        ));\n    }\n\n    if let Some((docs_url, spec)) = docs_info {\n        let method_path = http_method_to_token_stream(HttpMethod::Get);\n\n        let html = format!(\n            r#\"\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"UTF-8\"\u003e\n  \u003ctitle\u003eSwagger UI\u003c/title\u003e\n  \u003clink rel=\"stylesheet\" href=\"https://unpkg.com/swagger-ui-dist/swagger-ui.css\" /\u003e\n\u003c/head\u003e\n\u003cbody style=\"margin: 0; padding: 0;\"\u003e\n\u003cdiv id=\"swagger-ui\"\u003e\u003c/div\u003e\n\n\u003cscript src=\"https://unpkg.com/swagger-ui-dist/swagger-ui-bundle.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"https://unpkg.com/swagger-ui-dist/swagger-ui-standalone-preset.js\"\u003e\u003c/script\u003e\n\n\u003cscript\u003e\n  const openapiSpec = {spec_json};\n\n  window.onload = () =\u003e {{\n    SwaggerUIBundle({{\n      spec: openapiSpec,\n      dom_id: \"\\#swagger-ui\",\n      presets: [\n        SwaggerUIBundle.presets.apis,\n        SwaggerUIStandalonePreset\n      ],\n      layout: \"StandaloneLayout\"\n    }});\n  }};\n\u003c/script\u003e\n\n\u003c/body\u003e\n\u003c/html\u003e\n\"#,\n            spec_json = spec\n        )\n        .replace(\"\\n\", \"\");\n\n        router_nests.push(quote!(\n            .route(#docs_url, #method_path(|| async { vespera::axum::response::Html(#html) }))\n        ));\n    }\n\n    if let Some((redoc_url, spec)) = redoc_info {\n        let method_path = http_method_to_token_stream(HttpMethod::Get);\n\n        let html = format!(\n            r#\"\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"UTF-8\"\u003e\n  \u003ctitle\u003eReDoc\u003c/title\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e\n  \u003cstyle\u003e\n    body {{\n      margin: 0;\n      padding: 0;\n    }}\n  \u003c/style\u003e\n  \u003clink rel=\"stylesheet\" href=\"https://unpkg.com/redoc/bundles/redoc.standalone.css\" /\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003cdiv id=\"redoc-container\"\u003e\u003c/div\u003e\n  \u003cscript src=\"https://unpkg.com/redoc/bundles/redoc.standalone.js\"\u003e\u003c/script\u003e\n  \u003cscript\u003e\n    const openapiSpec = {spec_json};\n    Redoc.init(openapiSpec, {{}}, document.getElementById(\"redoc-container\"));\n  \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n\"#,\n            spec_json = spec\n        )\n        .replace(\"\\n\", \"\");\n\n        router_nests.push(quote!(\n            .route(#redoc_url, #method_path(|| async { vespera::axum::response::Html(#html) }))\n        ));\n    }\n\n    quote! {\n        vespera::axum::Router::new()\n            #( #router_nests )*\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rstest::rstest;\n    use std::fs;\n    use tempfile::TempDir;\n\n    fn create_temp_file(dir: \u0026TempDir, filename: \u0026str, content: \u0026str) -\u003e std::path::PathBuf {\n        let file_path = dir.path().join(filename);\n        if let Some(parent) = file_path.parent() {\n            fs::create_dir_all(parent).expect(\"Failed to create parent directory\");\n        }\n        fs::write(\u0026file_path, content).expect(\"Failed to write temp file\");\n        file_path\n    }\n\n    #[test]\n    fn test_generate_router_code_empty() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let folder_name = \"routes\";\n\n        let result = generate_router_code(\n            \u0026collect_metadata(temp_dir.path(), folder_name).unwrap(),\n            None,\n            None,\n        );\n        let code = result.to_string();\n\n        // Should generate empty router\n        // quote! generates \"vespera :: axum :: Router :: new ()\" format\n        assert!(\n            code.contains(\"Router\") \u0026\u0026 code.contains(\"new\"),\n            \"Code should contain Router::new(), got: {}\",\n            code\n        );\n        assert!(\n            !code.contains(\"route\"),\n            \"Code should not contain route, got: {}\",\n            code\n        );\n\n        drop(temp_dir);\n    }\n\n    #[rstest]\n    #[case::single_get_route(\n        \"routes\",\n        vec![(\n            \"users.rs\",\n            r#\"\n#[route(get)]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#,\n        )],\n        \"get\",\n        \"/users\",\n        \"routes::users::get_users\",\n    )]\n    #[case::single_post_route(\n        \"routes\",\n        vec![(\n            \"create_user.rs\",\n            r#\"\n#[route(post)]\npub fn create_user() -\u003e String {\n    \"created\".to_string()\n}\n\"#,\n        )],\n        \"post\",\n        \"/create-user\",\n        \"routes::create_user::create_user\",\n    )]\n    #[case::single_put_route(\n        \"routes\",\n        vec![(\n            \"update_user.rs\",\n            r#\"\n#[route(put)]\npub fn update_user() -\u003e String {\n    \"updated\".to_string()\n}\n\"#,\n        )],\n        \"put\",\n        \"/update-user\",\n        \"routes::update_user::update_user\",\n    )]\n    #[case::single_delete_route(\n        \"routes\",\n        vec![(\n            \"delete_user.rs\",\n            r#\"\n#[route(delete)]\npub fn delete_user() -\u003e String {\n    \"deleted\".to_string()\n}\n\"#,\n        )],\n        \"delete\",\n        \"/delete-user\",\n        \"routes::delete_user::delete_user\",\n    )]\n    #[case::single_patch_route(\n        \"routes\",\n        vec![(\n            \"patch_user.rs\",\n            r#\"\n#[route(patch)]\npub fn patch_user() -\u003e String {\n    \"patched\".to_string()\n}\n\"#,\n        )],\n        \"patch\",\n        \"/patch-user\",\n        \"routes::patch_user::patch_user\",\n    )]\n    #[case::route_with_custom_path(\n        \"routes\",\n        vec![(\n            \"users.rs\",\n            r#\"\n#[route(get, path = \"/api/users\")]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#,\n        )],\n        \"get\",\n        \"/users/api/users\",\n        \"routes::users::get_users\",\n    )]\n    #[case::nested_module(\n        \"routes\",\n        vec![(\n            \"api/users.rs\",\n            r#\"\n#[route(get)]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#,\n        )],\n        \"get\",\n        \"/api/users\",\n        \"routes::api::users::get_users\",\n    )]\n    #[case::deeply_nested_module(\n        \"routes\",\n        vec![(\n            \"api/v1/users.rs\",\n            r#\"\n#[route(get)]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#,\n        )],\n        \"get\",\n        \"/api/v1/users\",\n        \"routes::api::v1::users::get_users\",\n    )]\n    fn test_generate_router_code_single_route(\n        #[case] folder_name: \u0026str,\n        #[case] files: Vec\u003c(\u0026str, \u0026str)\u003e,\n        #[case] expected_method: \u0026str,\n        #[case] expected_path: \u0026str,\n        #[case] expected_function_path: \u0026str,\n    ) {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n\n        for (filename, content) in files {\n            create_temp_file(\u0026temp_dir, filename, content);\n        }\n\n        let result = generate_router_code(\n            \u0026collect_metadata(temp_dir.path(), folder_name).unwrap(),\n            None,\n            None,\n        );\n        let code = result.to_string();\n\n        // Check router initialization (quote! generates \"vespera :: axum :: Router :: new ()\")\n        assert!(\n            code.contains(\"Router\") \u0026\u0026 code.contains(\"new\"),\n            \"Code should contain Router::new(), got: {}\",\n            code\n        );\n\n        // Check route method\n        assert!(\n            code.contains(expected_method),\n            \"Code should contain method: {}, got: {}\",\n            expected_method,\n            code\n        );\n\n        // Check route path\n        assert!(\n            code.contains(expected_path),\n            \"Code should contain path: {}, got: {}\",\n            expected_path,\n            code\n        );\n\n        // Check function path (quote! adds spaces, so we check for parts)\n        let function_parts: Vec\u003c\u0026str\u003e = expected_function_path.split(\"::\").collect();\n        for part in \u0026function_parts {\n            if !part.is_empty() {\n                assert!(\n                    code.contains(part),\n                    \"Code should contain function part: {}, got: {}\",\n                    part,\n                    code\n                );\n            }\n        }\n\n        drop(temp_dir);\n    }\n\n    #[test]\n    fn test_generate_router_code_multiple_routes() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let folder_name = \"routes\";\n\n        // Create multiple route files\n        create_temp_file(\n            \u0026temp_dir,\n            \"users.rs\",\n            r#\"\n#[route(get)]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#,\n        );\n\n        create_temp_file(\n            \u0026temp_dir,\n            \"create_user.rs\",\n            r#\"\n#[route(post)]\npub fn create_user() -\u003e String {\n    \"created\".to_string()\n}\n\"#,\n        );\n\n        create_temp_file(\n            \u0026temp_dir,\n            \"update_user.rs\",\n            r#\"\n#[route(put)]\npub fn update_user() -\u003e String {\n    \"updated\".to_string()\n}\n\"#,\n        );\n\n        let result = generate_router_code(\n            \u0026collect_metadata(temp_dir.path(), folder_name).unwrap(),\n            None,\n            None,\n        );\n        let code = result.to_string();\n\n        // Check router initialization (quote! generates \"vespera :: axum :: Router :: new ()\")\n        assert!(code.contains(\"Router\") \u0026\u0026 code.contains(\"new\"));\n\n        // Check all routes are present\n        assert!(code.contains(\"get_users\"));\n        assert!(code.contains(\"create_user\"));\n        assert!(code.contains(\"update_user\"));\n\n        // Check methods\n        assert!(code.contains(\"get\"));\n        assert!(code.contains(\"post\"));\n        assert!(code.contains(\"put\"));\n\n        // Count route calls (quote! generates \". route (\" with spaces)\n        // Count occurrences of \". route (\" pattern\n        let route_count = code.matches(\". route (\").count();\n        assert_eq!(\n            route_count, 3,\n            \"Should have 3 route calls, got: {}, code: {}\",\n            route_count, code\n        );\n\n        drop(temp_dir);\n    }\n\n    #[test]\n    fn test_generate_router_code_same_path_different_methods() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let folder_name = \"routes\";\n\n        // Create routes with same path but different methods\n        create_temp_file(\n            \u0026temp_dir,\n            \"users.rs\",\n            r#\"\n#[route(get)]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\n#[route(post)]\npub fn create_users() -\u003e String {\n    \"created\".to_string()\n}\n\"#,\n        );\n\n        let result = generate_router_code(\n            \u0026collect_metadata(temp_dir.path(), folder_name).unwrap(),\n            None,\n            None,\n        );\n        let code = result.to_string();\n\n        // Check router initialization (quote! generates \"vespera :: axum :: Router :: new ()\")\n        assert!(code.contains(\"Router\") \u0026\u0026 code.contains(\"new\"));\n\n        // Check both routes are present\n        assert!(code.contains(\"get_users\"));\n        assert!(code.contains(\"create_users\"));\n\n        // Check methods\n        assert!(code.contains(\"get\"));\n        assert!(code.contains(\"post\"));\n\n        // Should have 2 routes (quote! generates \". route (\" with spaces)\n        let route_count = code.matches(\". route (\").count();\n        assert_eq!(\n            route_count, 2,\n            \"Should have 2 routes, got: {}, code: {}\",\n            route_count, code\n        );\n\n        drop(temp_dir);\n    }\n\n    #[test]\n    fn test_generate_router_code_with_mod_rs() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let folder_name = \"routes\";\n\n        // Create mod.rs file\n        create_temp_file(\n            \u0026temp_dir,\n            \"mod.rs\",\n            r#\"\n#[route(get)]\npub fn index() -\u003e String {\n    \"index\".to_string()\n}\n\"#,\n        );\n\n        let result = generate_router_code(\n            \u0026collect_metadata(temp_dir.path(), folder_name).unwrap(),\n            None,\n            None,\n        );\n        let code = result.to_string();\n\n        // Check router initialization (quote! generates \"vespera :: axum :: Router :: new ()\")\n        assert!(code.contains(\"Router\") \u0026\u0026 code.contains(\"new\"));\n\n        // Check route is present\n        assert!(code.contains(\"index\"));\n\n        // Path should be / (mod.rs maps to root, segments is empty)\n        // quote! generates \"\\\"/\\\"\"\n        assert!(code.contains(\"\\\"/\\\"\"));\n\n        drop(temp_dir);\n    }\n\n    #[test]\n    fn test_generate_router_code_empty_folder_name() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let folder_name = \"\";\n\n        create_temp_file(\n            \u0026temp_dir,\n            \"users.rs\",\n            r#\"\n#[route(get)]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#,\n        );\n\n        let result = generate_router_code(\n            \u0026collect_metadata(temp_dir.path(), folder_name).unwrap(),\n            None,\n            None,\n        );\n        let code = result.to_string();\n\n        // Check router initialization (quote! generates \"vespera :: axum :: Router :: new ()\")\n        assert!(code.contains(\"Router\") \u0026\u0026 code.contains(\"new\"));\n\n        // Check route is present\n        assert!(code.contains(\"get_users\"));\n\n        // Module path should not have double colons\n        assert!(!code.contains(\"::users::users\"));\n\n        drop(temp_dir);\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":501,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":503,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":504,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":505,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":506,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":507,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":508,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":510,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":511,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":512,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":513,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":514,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":516,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":517,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":518,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":519,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":520,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":521,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":523,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":524,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":525,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":529,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":531,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":532,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":537,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":936748722493063168}}],"covered":28,"coverable":304},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","metadata.rs"],"content":"//! Metadata collection and storage for routes and schemas\n\nuse serde::{Deserialize, Serialize};\n\n/// Route metadata\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RouteMetadata {\n    /// HTTP method\n    pub method: String,\n    /// Route path\n    pub path: String,\n    /// Function name\n    pub function_name: String,\n    /// Module path\n    pub module_path: String,\n    /// File path\n    pub file_path: String,\n    /// Function signature (as string for serialization)\n    pub signature: String,\n    /// Additional error status codes from error_status attribute\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub error_status: Option\u003cVec\u003cu16\u003e\u003e,\n    /// Tags for OpenAPI grouping\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub tags: Option\u003cVec\u003cString\u003e\u003e,\n    /// Description for OpenAPI (from route attribute or doc comment)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n}\n\n/// Struct metadata\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StructMetadata {\n    /// Struct name\n    pub name: String,\n    /// Struct definition (as string for serialization)\n    pub definition: String,\n}\n\n/// Collected metadata\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CollectedMetadata {\n    /// Routes\n    pub routes: Vec\u003cRouteMetadata\u003e,\n    /// Structs\n    pub structs: Vec\u003cStructMetadata\u003e,\n}\n\nimpl CollectedMetadata {\n    pub fn new() -\u003e Self {\n        Self {\n            routes: Vec::new(),\n            structs: Vec::new(),\n        }\n    }\n}\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":52,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":53,"address":[],"length":0,"stats":{"Line":3602879701896396800}}],"covered":3,"coverable":3},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","method.rs"],"content":"use proc_macro2::TokenStream;\nuse quote::quote;\nuse vespera_core::route::HttpMethod;\n\n/// Convert HttpMethod to axum routing TokenStream\npub fn http_method_to_token_stream(method: HttpMethod) -\u003e TokenStream {\n    match method {\n        HttpMethod::Get =\u003e quote! { vespera::axum::routing::get },\n        HttpMethod::Post =\u003e quote! { vespera::axum::routing::post },\n        HttpMethod::Put =\u003e quote! { vespera::axum::routing::put },\n        HttpMethod::Patch =\u003e quote! { vespera::axum::routing::patch },\n        HttpMethod::Delete =\u003e quote! { vespera::axum::routing::delete },\n        HttpMethod::Head =\u003e quote! { vespera::axum::routing::head },\n        HttpMethod::Options =\u003e quote! { vespera::axum::routing::options },\n        HttpMethod::Trace =\u003e quote! { vespera::axum::routing::trace },\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rstest::rstest;\n\n    #[rstest]\n    #[case(HttpMethod::Get, \"get\")]\n    #[case(HttpMethod::Post, \"post\")]\n    #[case(HttpMethod::Put, \"put\")]\n    #[case(HttpMethod::Patch, \"patch\")]\n    #[case(HttpMethod::Delete, \"delete\")]\n    #[case(HttpMethod::Head, \"head\")]\n    #[case(HttpMethod::Options, \"options\")]\n    #[case(HttpMethod::Trace, \"trace\")]\n    fn test_http_method_to_token_stream(\n        #[case] method: HttpMethod,\n        #[case] expected_method_name: \u0026str,\n    ) {\n        let result = http_method_to_token_stream(method);\n        let code = result.to_string();\n\n        // Check that the code contains the expected method name\n        // quote! generates \"vespera :: axum :: routing :: get\" format\n        assert!(\n            code.contains(expected_method_name),\n            \"Code should contain method name: {}, got: {}\",\n            expected_method_name,\n            code\n        );\n\n        // Check that it contains the routing path\n        assert!(\n            code.contains(\"routing\"),\n            \"Code should contain 'routing', got: {}\",\n            code\n        );\n\n        // Check that it contains the axum path\n        assert!(\n            code.contains(\"axum\"),\n            \"Code should contain 'axum', got: {}\",\n            code\n        );\n\n        // Check that it contains the vespera path\n        assert!(\n            code.contains(\"vespera\"),\n            \"Code should contain 'vespera', got: {}\",\n            code\n        );\n    }\n\n    #[test]\n    fn test_http_method_to_token_stream_all_methods() {\n        // Test that all methods generate valid TokenStreams\n        let methods = vec![\n            HttpMethod::Get,\n            HttpMethod::Post,\n            HttpMethod::Put,\n            HttpMethod::Patch,\n            HttpMethod::Delete,\n            HttpMethod::Head,\n            HttpMethod::Options,\n            HttpMethod::Trace,\n        ];\n\n        for method in methods {\n            let result = http_method_to_token_stream(method.clone());\n            let code = result.to_string();\n\n            // Each should generate a valid TokenStream\n            assert!(\n                !code.is_empty(),\n                \"TokenStream should not be empty for {:?}\",\n                method\n            );\n            assert!(\n                code.contains(\"routing\"),\n                \"TokenStream should contain 'routing' for {:?}, got: {}\",\n                method,\n                code\n            );\n        }\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":7,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":8,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":9,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":10,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":11,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":12,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":13,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":15,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":10,"coverable":10},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","openapi_generator.rs"],"content":"//! OpenAPI document generator\n\nuse std::collections::{BTreeMap, BTreeSet};\nuse vespera_core::{\n    openapi::{Info, OpenApi, OpenApiVersion, Server, Tag},\n    route::{HttpMethod, PathItem},\n    schema::Components,\n};\n\nuse crate::metadata::CollectedMetadata;\nuse crate::parser::{\n    build_operation_from_function, extract_default, extract_field_rename, extract_rename_all,\n    parse_enum_to_schema, parse_struct_to_schema, rename_field,\n};\n\n/// Generate OpenAPI document from collected metadata\npub fn generate_openapi_doc_with_metadata(\n    title: Option\u003cString\u003e,\n    version: Option\u003cString\u003e,\n    servers: Option\u003cVec\u003cServer\u003e\u003e,\n    metadata: \u0026CollectedMetadata,\n) -\u003e OpenApi {\n    let mut paths: BTreeMap\u003cString, PathItem\u003e = BTreeMap::new();\n    let mut schemas: BTreeMap\u003cString, vespera_core::schema::Schema\u003e = BTreeMap::new();\n    let mut known_schema_names: std::collections::HashMap\u003cString, String\u003e =\n        std::collections::HashMap::new();\n    let mut struct_definitions: std::collections::HashMap\u003cString, String\u003e =\n        std::collections::HashMap::new();\n    let mut all_tags: BTreeSet\u003cString\u003e = BTreeSet::new();\n\n    // First, register all schema names and store struct definitions\n    for struct_meta in \u0026metadata.structs {\n        let schema_name = struct_meta.name.clone();\n        known_schema_names.insert(schema_name.clone(), schema_name);\n        struct_definitions.insert(struct_meta.name.clone(), struct_meta.definition.clone());\n    }\n\n    // Then, parse all struct and enum schemas (now they can reference each other)\n    for struct_meta in \u0026metadata.structs {\n        let parsed = syn::parse_str::\u003csyn::Item\u003e(\u0026struct_meta.definition).unwrap();\n        let mut schema = match \u0026parsed {\n            syn::Item::Struct(struct_item) =\u003e {\n                parse_struct_to_schema(struct_item, \u0026known_schema_names, \u0026struct_definitions)\n            }\n            syn::Item::Enum(enum_item) =\u003e {\n                parse_enum_to_schema(enum_item, \u0026known_schema_names, \u0026struct_definitions)\n            }\n            _ =\u003e {\n                // Fallback to struct parsing for backward compatibility\n                parse_struct_to_schema(\n                    \u0026syn::parse_str(\u0026struct_meta.definition).unwrap(),\n                    \u0026known_schema_names,\n                    \u0026struct_definitions,\n                )\n            }\n        };\n\n        // Process default values for struct fields\n        if let syn::Item::Struct(struct_item) = \u0026parsed {\n            // Find the file where this struct is defined\n            // Try to find a route file that contains this struct\n            let struct_file = metadata\n                .routes\n                .iter()\n                .find_map(|route| {\n                    // Check if the file contains the struct definition\n                    if let Ok(file_content) = std::fs::read_to_string(\u0026route.file_path) {\n                        // Check if the struct name appears in the file (more specific check)\n                        // Look for \"struct StructName\" pattern\n                        let struct_pattern = format!(\"struct {}\", struct_meta.name);\n                        if file_content.contains(\u0026struct_pattern) {\n                            return Some(route.file_path.clone());\n                        }\n                    }\n                    None\n                })\n                .or_else(|| {\n                    // Fallback: try all route files to find the struct\n                    for route in \u0026metadata.routes {\n                        if let Ok(file_content) = std::fs::read_to_string(\u0026route.file_path) {\n                            let struct_pattern = format!(\"struct {}\", struct_meta.name);\n                            if file_content.contains(\u0026struct_pattern) {\n                                return Some(route.file_path.clone());\n                            }\n                        }\n                    }\n                    // Last resort: use first route file if available\n                    metadata.routes.first().map(|r| r.file_path.clone())\n                });\n\n            if let Some(file_path) = struct_file\n                \u0026\u0026 let Ok(file_content) = std::fs::read_to_string(\u0026file_path)\n                \u0026\u0026 let Ok(file_ast) = syn::parse_file(\u0026file_content)\n            {\n                // Process default functions for struct fields\n                process_default_functions(struct_item, \u0026file_ast, \u0026mut schema);\n            }\n        }\n\n        let schema_name = struct_meta.name.clone();\n        schemas.insert(schema_name.clone(), schema);\n    }\n\n    // Process routes from metadata\n    for route_meta in \u0026metadata.routes {\n        // Try to parse the file to get the actual function\n        let content = match std::fs::read_to_string(\u0026route_meta.file_path) {\n            Ok(content) =\u003e content,\n            Err(e) =\u003e {\n                eprintln!(\n                    \"Warning: Failed to read file {}: {}\",\n                    route_meta.file_path, e\n                );\n                continue;\n            }\n        };\n\n        let file_ast = match syn::parse_file(\u0026content) {\n            Ok(ast) =\u003e ast,\n            Err(e) =\u003e {\n                eprintln!(\n                    \"Warning: Failed to parse file {}: {}\",\n                    route_meta.file_path, e\n                );\n                continue;\n            }\n        };\n\n        for item in file_ast.items {\n            if let syn::Item::Fn(fn_item) = item\n                \u0026\u0026 fn_item.sig.ident == route_meta.function_name\n            {\n                let method = HttpMethod::from(route_meta.method.as_str());\n\n                // Collect tags for global tags list\n                if let Some(tags) = \u0026route_meta.tags {\n                    for tag in tags {\n                        all_tags.insert(tag.clone());\n                    }\n                }\n\n                // Build operation from function signature\n                let mut operation = build_operation_from_function(\n                    \u0026fn_item.sig,\n                    \u0026route_meta.path,\n                    \u0026known_schema_names,\n                    \u0026struct_definitions,\n                    route_meta.error_status.as_deref(),\n                    route_meta.tags.as_deref(),\n                );\n\n                // Set description from metadata\n                if let Some(desc) = \u0026route_meta.description {\n                    operation.description = Some(desc.clone());\n                }\n\n                // Get or create PathItem\n                let path_item = paths\n                    .entry(route_meta.path.clone())\n                    .or_insert_with(|| PathItem {\n                        get: None,\n                        post: None,\n                        put: None,\n                        patch: None,\n                        delete: None,\n                        head: None,\n                        options: None,\n                        trace: None,\n                        parameters: None,\n                        summary: None,\n                        description: None,\n                    });\n\n                // Set operation for the method\n                path_item.set_operation(method, operation);\n                break;\n            }\n        }\n    }\n\n    // Build OpenAPI document\n    OpenApi {\n        openapi: OpenApiVersion::V3_1_0,\n        info: Info {\n            title: title.unwrap_or_else(|| \"API\".to_string()),\n            version: version.unwrap_or_else(|| \"1.0.0\".to_string()),\n            description: None,\n            terms_of_service: None,\n            contact: None,\n            license: None,\n            summary: None,\n        },\n        servers: servers.or_else(|| {\n            Some(vec![Server {\n                url: \"http://localhost:3000\".to_string(),\n                description: None,\n                variables: None,\n            }])\n        }),\n        paths,\n        components: Some(Components {\n            schemas: if schemas.is_empty() {\n                None\n            } else {\n                Some(schemas)\n            },\n            responses: None,\n            parameters: None,\n            examples: None,\n            request_bodies: None,\n            headers: None,\n            security_schemes: None,\n        }),\n        security: None,\n        tags: if all_tags.is_empty() {\n            None\n        } else {\n            Some(\n                all_tags\n                    .into_iter()\n                    .map(|name| Tag {\n                        name,\n                        description: None,\n                        external_docs: None,\n                    })\n                    .collect(),\n            )\n        },\n        external_docs: None,\n    }\n}\n\n/// Process default functions for struct fields\n/// This function extracts default values from functions specified in #[serde(default = \"function_name\")]\nfn process_default_functions(\n    struct_item: \u0026syn::ItemStruct,\n    file_ast: \u0026syn::File,\n    schema: \u0026mut vespera_core::schema::Schema,\n) {\n    use syn::Fields;\n    use vespera_core::schema::SchemaRef;\n\n    // Extract rename_all from struct level\n    let struct_rename_all = extract_rename_all(\u0026struct_item.attrs);\n\n    // Get properties from schema\n    let properties = match \u0026mut schema.properties {\n        Some(props) =\u003e props,\n        None =\u003e return, // No properties to process\n    };\n\n    // Process each field in the struct\n    if let Fields::Named(fields_named) = \u0026struct_item.fields {\n        for field in \u0026fields_named.named {\n            // Extract default function name\n            let default_info = match extract_default(\u0026field.attrs) {\n                Some(Some(func_name)) =\u003e func_name, // default = \"function_name\"\n                Some(None) =\u003e {\n                    // Simple default (no function) - we can set type-specific defaults\n                    let rust_field_name = field\n                        .ident\n                        .as_ref()\n                        .map(|i| i.to_string())\n                        .unwrap_or_else(|| \"unknown\".to_string());\n\n                    let field_name = if let Some(renamed) = extract_field_rename(\u0026field.attrs) {\n                        renamed\n                    } else {\n                        rename_field(\u0026rust_field_name, struct_rename_all.as_deref())\n                    };\n\n                    // Set type-specific default for simple default\n                    if let Some(prop_schema_ref) = properties.get_mut(\u0026field_name)\n                        \u0026\u0026 let SchemaRef::Inline(prop_schema) = prop_schema_ref\n                        \u0026\u0026 prop_schema.default.is_none()\n                        \u0026\u0026 let Some(default_value) = get_type_default(\u0026field.ty)\n                    {\n                        prop_schema.default = Some(default_value);\n                    }\n                    continue;\n                }\n                None =\u003e continue, // No default attribute\n            };\n\n            // Find the function in the file AST\n            let func = find_function_in_file(file_ast, \u0026default_info);\n            if let Some(func_item) = func {\n                // Extract default value from function body\n                if let Some(default_value) = extract_default_value_from_function(func_item) {\n                    // Get the field name (with rename applied)\n                    let rust_field_name = field\n                        .ident\n                        .as_ref()\n                        .map(|i| i.to_string())\n                        .unwrap_or_else(|| \"unknown\".to_string());\n\n                    let field_name = if let Some(renamed) = extract_field_rename(\u0026field.attrs) {\n                        renamed\n                    } else {\n                        rename_field(\u0026rust_field_name, struct_rename_all.as_deref())\n                    };\n\n                    // Set default value in schema\n                    if let Some(prop_schema_ref) = properties.get_mut(\u0026field_name)\n                        \u0026\u0026 let SchemaRef::Inline(prop_schema) = prop_schema_ref\n                    {\n                        prop_schema.default = Some(default_value);\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Find a function by name in the file AST\nfn find_function_in_file\u003c'a\u003e(\n    file_ast: \u0026'a syn::File,\n    function_name: \u0026str,\n) -\u003e Option\u003c\u0026'a syn::ItemFn\u003e {\n    for item in \u0026file_ast.items {\n        if let syn::Item::Fn(fn_item) = item\n            \u0026\u0026 fn_item.sig.ident == function_name\n        {\n            return Some(fn_item);\n        }\n    }\n    None\n}\n\n/// Extract default value from function body\n/// This tries to extract literal values from common patterns like:\n/// - \"value\".to_string() -\u003e \"value\"\n/// - 42 -\u003e 42\n/// - true -\u003e true\n/// - vec![] -\u003e []\nfn extract_default_value_from_function(func: \u0026syn::ItemFn) -\u003e Option\u003cserde_json::Value\u003e {\n    // Try to find return statement or expression\n    for stmt in \u0026func.block.stmts {\n        if let syn::Stmt::Expr(expr, _) = stmt {\n            // Direct expression (like \"value\".to_string())\n            if let Some(value) = extract_value_from_expr(expr) {\n                return Some(value);\n            }\n            // Or return statement\n            if let syn::Expr::Return(ret) = expr\n                \u0026\u0026 let Some(expr) = \u0026ret.expr\n                \u0026\u0026 let Some(value) = extract_value_from_expr(expr)\n            {\n                return Some(value);\n            }\n        }\n    }\n\n    None\n}\n\n/// Extract value from expression\nfn extract_value_from_expr(expr: \u0026syn::Expr) -\u003e Option\u003cserde_json::Value\u003e {\n    use syn::{Expr, ExprLit, ExprMacro, Lit};\n\n    match expr {\n        // Literal values\n        Expr::Lit(ExprLit { lit, .. }) =\u003e match lit {\n            Lit::Str(s) =\u003e Some(serde_json::Value::String(s.value())),\n            Lit::Int(i) =\u003e {\n                if let Ok(val) = i.base10_parse::\u003ci64\u003e() {\n                    Some(serde_json::Value::Number(val.into()))\n                } else {\n                    None\n                }\n            }\n            Lit::Float(f) =\u003e {\n                if let Ok(val) = f.base10_parse::\u003cf64\u003e() {\n                    Some(serde_json::Value::Number(\n                        serde_json::Number::from_f64(val).unwrap_or(serde_json::Number::from(0)),\n                    ))\n                } else {\n                    None\n                }\n            }\n            Lit::Bool(b) =\u003e Some(serde_json::Value::Bool(b.value)),\n            _ =\u003e None,\n        },\n        // Method calls like \"value\".to_string()\n        Expr::MethodCall(method_call) =\u003e {\n            if method_call.method == \"to_string\" {\n                // Get the receiver (the string literal)\n                // Try direct match first\n                if let Expr::Lit(ExprLit {\n                    lit: Lit::Str(s), ..\n                }) = method_call.receiver.as_ref()\n                {\n                    return Some(serde_json::Value::String(s.value()));\n                }\n                // Try to extract from nested expressions (e.g., if the receiver is wrapped)\n                if let Some(value) = extract_value_from_expr(method_call.receiver.as_ref()) {\n                    return Some(value);\n                }\n            }\n            None\n        }\n        // Macro calls like vec![]\n        Expr::Macro(ExprMacro { mac, .. }) =\u003e {\n            if mac.path.is_ident(\"vec\") {\n                // Try to parse vec![] as empty array\n                return Some(serde_json::Value::Array(vec![]));\n            }\n            None\n        }\n        _ =\u003e None,\n    }\n}\n\n/// Get type-specific default value for simple #[serde(default)]\nfn get_type_default(ty: \u0026syn::Type) -\u003e Option\u003cserde_json::Value\u003e {\n    use syn::Type;\n    match ty {\n        Type::Path(type_path) =\u003e {\n            if let Some(segment) = type_path.path.segments.last() {\n                match segment.ident.to_string().as_str() {\n                    \"String\" =\u003e Some(serde_json::Value::String(String::new())),\n                    \"i8\" | \"i16\" | \"i32\" | \"i64\" | \"u8\" | \"u16\" | \"u32\" | \"u64\" =\u003e {\n                        Some(serde_json::Value::Number(serde_json::Number::from(0)))\n                    }\n                    \"f32\" | \"f64\" =\u003e Some(serde_json::Value::Number(\n                        serde_json::Number::from_f64(0.0).unwrap_or(serde_json::Number::from(0)),\n                    )),\n                    \"bool\" =\u003e Some(serde_json::Value::Bool(false)),\n                    _ =\u003e None,\n                }\n            } else {\n                None\n            }\n        }\n        _ =\u003e None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::metadata::{CollectedMetadata, RouteMetadata, StructMetadata};\n    use rstest::rstest;\n    use std::fs;\n    use std::path::PathBuf;\n    use tempfile::TempDir;\n\n    fn create_temp_file(dir: \u0026TempDir, filename: \u0026str, content: \u0026str) -\u003e PathBuf {\n        let file_path = dir.path().join(filename);\n        fs::write(\u0026file_path, content).expect(\"Failed to write temp file\");\n        file_path\n    }\n\n    #[test]\n    fn test_generate_openapi_empty_metadata() {\n        let metadata = CollectedMetadata::new();\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        assert_eq!(doc.openapi, OpenApiVersion::V3_1_0);\n        assert_eq!(doc.info.title, \"API\");\n        assert_eq!(doc.info.version, \"1.0.0\");\n        assert!(doc.paths.is_empty());\n        assert!(doc.components.as_ref().unwrap().schemas.is_none());\n        assert_eq!(doc.servers.as_ref().unwrap().len(), 1);\n        assert_eq!(\n            doc.servers.as_ref().unwrap()[0].url,\n            \"http://localhost:3000\"\n        );\n    }\n\n    #[rstest]\n    #[case(None, None, \"API\", \"1.0.0\")]\n    #[case(Some(\"My API\".to_string()), None, \"My API\", \"1.0.0\")]\n    #[case(None, Some(\"2.0.0\".to_string()), \"API\", \"2.0.0\")]\n    #[case(Some(\"Test API\".to_string()), Some(\"3.0.0\".to_string()), \"Test API\", \"3.0.0\")]\n    fn test_generate_openapi_title_version(\n        #[case] title: Option\u003cString\u003e,\n        #[case] version: Option\u003cString\u003e,\n        #[case] expected_title: \u0026str,\n        #[case] expected_version: \u0026str,\n    ) {\n        let metadata = CollectedMetadata::new();\n\n        let doc = generate_openapi_doc_with_metadata(title, version, None, \u0026metadata);\n\n        assert_eq!(doc.info.title, expected_title);\n        assert_eq!(doc.info.version, expected_version);\n    }\n\n    #[test]\n    fn test_generate_openapi_with_route() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n\n        // Create a test route file\n        let route_content = r#\"\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#;\n        let route_file = create_temp_file(\u0026temp_dir, \"users.rs\", route_content);\n\n        let mut metadata = CollectedMetadata::new();\n        metadata.routes.push(RouteMetadata {\n            method: \"GET\".to_string(),\n            path: \"/users\".to_string(),\n            function_name: \"get_users\".to_string(),\n            module_path: \"test::users\".to_string(),\n            file_path: route_file.to_string_lossy().to_string(),\n            signature: \"fn get_users() -\u003e String\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        });\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        assert!(doc.paths.contains_key(\"/users\"));\n        let path_item = doc.paths.get(\"/users\").unwrap();\n        assert!(path_item.get.is_some());\n        let operation = path_item.get.as_ref().unwrap();\n        assert_eq!(operation.operation_id, Some(\"get_users\".to_string()));\n    }\n\n    #[test]\n    fn test_generate_openapi_with_struct() {\n        let mut metadata = CollectedMetadata::new();\n        metadata.structs.push(StructMetadata {\n            name: \"User\".to_string(),\n            definition: \"struct User { id: i32, name: String }\".to_string(),\n        });\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        assert!(doc.components.as_ref().unwrap().schemas.is_some());\n        let schemas = doc.components.as_ref().unwrap().schemas.as_ref().unwrap();\n        assert!(schemas.contains_key(\"User\"));\n    }\n\n    #[test]\n    fn test_generate_openapi_with_enum() {\n        let mut metadata = CollectedMetadata::new();\n        metadata.structs.push(StructMetadata {\n            name: \"Status\".to_string(),\n            definition: \"enum Status { Active, Inactive, Pending }\".to_string(),\n        });\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        assert!(doc.components.as_ref().unwrap().schemas.is_some());\n        let schemas = doc.components.as_ref().unwrap().schemas.as_ref().unwrap();\n        assert!(schemas.contains_key(\"Status\"));\n    }\n\n    #[test]\n    fn test_generate_openapi_with_enum_with_data() {\n        // Test enum with data (tuple and struct variants) to ensure full coverage\n        let mut metadata = CollectedMetadata::new();\n        metadata.structs.push(StructMetadata {\n            name: \"Message\".to_string(),\n            definition: \"enum Message { Text(String), User { id: i32, name: String } }\".to_string(),\n        });\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        assert!(doc.components.as_ref().unwrap().schemas.is_some());\n        let schemas = doc.components.as_ref().unwrap().schemas.as_ref().unwrap();\n        assert!(schemas.contains_key(\"Message\"));\n    }\n\n    #[test]\n    fn test_generate_openapi_with_enum_and_route() {\n        // Test enum used in route to ensure enum parsing is called in route context\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let route_content = r#\"\npub fn get_status() -\u003e Status {\n    Status::Active\n}\n\"#;\n        let route_file = create_temp_file(\u0026temp_dir, \"status_route.rs\", route_content);\n\n        let mut metadata = CollectedMetadata::new();\n        metadata.structs.push(StructMetadata {\n            name: \"Status\".to_string(),\n            definition: \"enum Status { Active, Inactive }\".to_string(),\n        });\n        metadata.routes.push(RouteMetadata {\n            method: \"GET\".to_string(),\n            path: \"/status\".to_string(),\n            function_name: \"get_status\".to_string(),\n            module_path: \"test::status_route\".to_string(),\n            file_path: route_file.to_string_lossy().to_string(),\n            signature: \"fn get_status() -\u003e Status\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        });\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        // Check enum schema\n        assert!(doc.components.as_ref().unwrap().schemas.is_some());\n        let schemas = doc.components.as_ref().unwrap().schemas.as_ref().unwrap();\n        assert!(schemas.contains_key(\"Status\"));\n\n        // Check route\n        assert!(doc.paths.contains_key(\"/status\"));\n    }\n\n    #[test]\n    #[should_panic(expected = \"expected `struct`\")]\n    fn test_generate_openapi_with_fallback_item() {\n        // Test fallback case for non-struct, non-enum items (lines 46-48)\n        // Use a const item which will be parsed as syn::Item::Const first\n        // This triggers the fallback case (_ branch) which tries to parse as struct\n        // The fallback will fail to parse const as struct, causing a panic\n        // This test verifies that the fallback path (46-48) is executed\n        let mut metadata = CollectedMetadata::new();\n        metadata.structs.push(StructMetadata {\n            name: \"Config\".to_string(),\n            // This will be parsed as syn::Item::Const, triggering the fallback case\n            definition: \"const CONFIG: i32 = 42;\".to_string(),\n        });\n\n        // This should panic when fallback tries to parse const as struct\n        let _doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n    }\n\n    #[test]\n    fn test_generate_openapi_with_route_and_struct() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let route_content = r#\"\nuse crate::user::User;\n\npub fn get_user() -\u003e User {\n    User { id: 1, name: \"Alice\".to_string() }\n}\n\"#;\n        let route_file = create_temp_file(\u0026temp_dir, \"user_route.rs\", route_content);\n\n        let mut metadata = CollectedMetadata::new();\n        metadata.structs.push(StructMetadata {\n            name: \"User\".to_string(),\n            definition: \"struct User { id: i32, name: String }\".to_string(),\n        });\n        metadata.routes.push(RouteMetadata {\n            method: \"GET\".to_string(),\n            path: \"/user\".to_string(),\n            function_name: \"get_user\".to_string(),\n            module_path: \"test::user_route\".to_string(),\n            file_path: route_file.to_string_lossy().to_string(),\n            signature: \"fn get_user() -\u003e User\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        });\n\n        let doc = generate_openapi_doc_with_metadata(\n            Some(\"Test API\".to_string()),\n            Some(\"1.0.0\".to_string()),\n            None,\n            \u0026metadata,\n        );\n\n        // Check struct schema\n        assert!(doc.components.as_ref().unwrap().schemas.is_some());\n        let schemas = doc.components.as_ref().unwrap().schemas.as_ref().unwrap();\n        assert!(schemas.contains_key(\"User\"));\n\n        // Check route\n        assert!(doc.paths.contains_key(\"/user\"));\n        let path_item = doc.paths.get(\"/user\").unwrap();\n        assert!(path_item.get.is_some());\n    }\n\n    #[test]\n    fn test_generate_openapi_multiple_routes() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n\n        let route1_content = r#\"\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#;\n        let route1_file = create_temp_file(\u0026temp_dir, \"users.rs\", route1_content);\n\n        let route2_content = r#\"\npub fn create_user() -\u003e String {\n    \"created\".to_string()\n}\n\"#;\n        let route2_file = create_temp_file(\u0026temp_dir, \"create_user.rs\", route2_content);\n\n        let mut metadata = CollectedMetadata::new();\n        metadata.routes.push(RouteMetadata {\n            method: \"GET\".to_string(),\n            path: \"/users\".to_string(),\n            function_name: \"get_users\".to_string(),\n            module_path: \"test::users\".to_string(),\n            file_path: route1_file.to_string_lossy().to_string(),\n            signature: \"fn get_users() -\u003e String\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        });\n        metadata.routes.push(RouteMetadata {\n            method: \"POST\".to_string(),\n            path: \"/users\".to_string(),\n            function_name: \"create_user\".to_string(),\n            module_path: \"test::create_user\".to_string(),\n            file_path: route2_file.to_string_lossy().to_string(),\n            signature: \"fn create_user() -\u003e String\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        });\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        assert_eq!(doc.paths.len(), 1); // Same path, different methods\n        let path_item = doc.paths.get(\"/users\").unwrap();\n        assert!(path_item.get.is_some());\n        assert!(path_item.post.is_some());\n    }\n\n    #[rstest]\n    // Test file read failures\n    #[case::route_file_read_failure(\n        None,\n        Some(RouteMetadata {\n            method: \"GET\".to_string(),\n            path: \"/users\".to_string(),\n            function_name: \"get_users\".to_string(),\n            module_path: \"test::users\".to_string(),\n            file_path: \"/nonexistent/route.rs\".to_string(),\n            signature: \"fn get_users() -\u003e String\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        }),\n        false, // struct should not be added\n        false, // route should not be added\n    )]\n    #[case::route_file_parse_failure(\n        None,\n        Some(RouteMetadata {\n            method: \"GET\".to_string(),\n            path: \"/users\".to_string(),\n            function_name: \"get_users\".to_string(),\n            module_path: \"test::users\".to_string(),\n            file_path: \"\".to_string(), // Will be set to temp file with invalid syntax\n            signature: \"fn get_users() -\u003e String\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        }),\n        false, // struct should not be added\n        false, // route should not be added\n    )]\n    fn test_generate_openapi_file_errors(\n        #[case] struct_meta: Option\u003cStructMetadata\u003e,\n        #[case] route_meta: Option\u003cRouteMetadata\u003e,\n        #[case] expect_struct: bool,\n        #[case] expect_route: bool,\n    ) {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let mut metadata = CollectedMetadata::new();\n\n        // Handle struct metadata\n        if let Some(struct_m) = struct_meta {\n            // If file_path is empty, create invalid syntax file\n            metadata.structs.push(struct_m);\n        }\n\n        // Handle route metadata\n        if let Some(mut route_m) = route_meta {\n            // If file_path is empty, create invalid syntax file\n            if route_m.file_path.is_empty() {\n                let invalid_file =\n                    create_temp_file(\u0026temp_dir, \"invalid_route.rs\", \"invalid rust syntax {\");\n                route_m.file_path = invalid_file.to_string_lossy().to_string();\n            }\n            metadata.routes.push(route_m);\n        }\n\n        // Should not panic, just skip invalid files\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        // Check struct\n        if expect_struct {\n            assert!(doc.components.as_ref().unwrap().schemas.is_some());\n            let schemas = doc.components.as_ref().unwrap().schemas.as_ref().unwrap();\n            assert!(schemas.contains_key(\"User\"));\n        } else if let Some(schemas) = doc.components.as_ref().unwrap().schemas.as_ref() {\n            assert!(!schemas.contains_key(\"User\"));\n        }\n\n        // Check route\n        if expect_route {\n            assert!(doc.paths.contains_key(\"/users\"));\n        } else {\n            assert!(!doc.paths.contains_key(\"/users\"));\n        }\n\n        // Ensure TempDir is properly closed\n        drop(temp_dir);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":23,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":24,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":25,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":26,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":27,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":28,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":29,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":32,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":33,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":34,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":35,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":39,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":40,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":41,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":43,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":46,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":53,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":59,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":62,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":63,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":65,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":77,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":79,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":80,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":81,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":82,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":91,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":92,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":93,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":96,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":100,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":101,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":105,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":107,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":108,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":109,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":110,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":111,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":114,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":118,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":119,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":120,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":121,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":122,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":125,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":129,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":130,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":131,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":133,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":136,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":137,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":138,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":144,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":145,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":146,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":147,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":148,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":149,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":153,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":154,"address":[],"length":0,"stats":{"Line":18302628885633695744}},{"line":158,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":159,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":160,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":161,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":162,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":163,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":164,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":165,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":166,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":167,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":168,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":169,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":170,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":171,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":175,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":176,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":193,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":215,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":235,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":244,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":247,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":248,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":254,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":256,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}}],"covered":96,"coverable":184},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","is_keyword_type.rs"],"content":"use syn::{Type, TypePath};\r\n\r\n#[allow(dead_code)]\r\npub enum KeywordType {\r\n    HeaderMap,\r\n    StatusCode,\r\n    Json,\r\n    Path,\r\n    Query,\r\n    Header,\r\n    TypedHeader,\r\n    Result,\r\n}\r\n\r\nimpl KeywordType {\r\n    pub fn as_str(\u0026self) -\u003e \u0026str {\r\n        match self {\r\n            KeywordType::HeaderMap =\u003e \"HeaderMap\",\r\n            KeywordType::StatusCode =\u003e \"StatusCode\",\r\n            KeywordType::Json =\u003e \"Json\",\r\n            KeywordType::Path =\u003e \"Path\",\r\n            KeywordType::Query =\u003e \"Query\",\r\n            KeywordType::Header =\u003e \"Header\",\r\n            KeywordType::TypedHeader =\u003e \"TypedHeader\",\r\n            KeywordType::Result =\u003e \"Result\",\r\n        }\r\n    }\r\n}\r\n\r\npub fn is_keyword_type(ty: \u0026Type, keyword: \u0026KeywordType) -\u003e bool {\r\n    if let Type::Path(type_path) = ty {\r\n        is_keyword_type_by_type_path(type_path, keyword)\r\n    } else {\r\n        false\r\n    }\r\n}\r\n\r\npub fn is_keyword_type_by_type_path(ty: \u0026TypePath, keyword: \u0026KeywordType) -\u003e bool {\r\n    ty.path.segments.last().unwrap().ident == keyword.as_str()\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use rstest::rstest;\r\n    use syn::parse_str;\r\n\r\n    fn syn_type(ty: \u0026str) -\u003e Type {\r\n        parse_str::\u003cType\u003e(ty).expect(\"Failed to parse type\")\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\"HeaderMap\", KeywordType::HeaderMap, true)]\r\n    #[case(\"StatusCode\", KeywordType::StatusCode, true)]\r\n    #[case(\"Json\", KeywordType::Json, true)]\r\n    #[case(\"Path\", KeywordType::Path, true)]\r\n    #[case(\"Query\", KeywordType::Query, true)]\r\n    #[case(\"Header\", KeywordType::Header, true)]\r\n    #[case(\"TypedHeader\", KeywordType::TypedHeader, true)]\r\n    #[case(\"String\", KeywordType::HeaderMap, false)]\r\n    #[case(\"HeaderMap\", KeywordType::Json, false)]\r\n    #[case(\"axum::http::HeaderMap\", KeywordType::HeaderMap, true)]\r\n    #[case(\"axum::http::StatusCode\", KeywordType::StatusCode, true)]\r\n    #[case(\"othermod::Json\", KeywordType::Json, true)]\r\n    #[case(\"CustomType\", KeywordType::Path, false)]\r\n    #[case(\"Result\", KeywordType::Result, true)]\r\n    #[case(\"Result\u003cString, String\u003e\", KeywordType::Result, true)]\r\n    #[case(\"!\", KeywordType::Result, false)]\r\n    fn test_is_keyword_type(\r\n        #[case] ty_str: \u0026str,\r\n        #[case] keyword: KeywordType,\r\n        #[case] expected: bool,\r\n    ) {\r\n        let ty = syn_type(ty_str);\r\n        assert_eq!(is_keyword_type(\u0026ty, \u0026keyword), expected);\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":17,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":18,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":19,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":21,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":30,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":31,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":32,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":38,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":39,"address":[],"length":0,"stats":{"Line":10808639105689190400}}],"covered":16,"coverable":16},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","mod.rs"],"content":"mod is_keyword_type;\nmod operation;\nmod parameters;\nmod path;\nmod request_body;\nmod response;\nmod schema;\npub use operation::build_operation_from_function;\npub use schema::{\n    extract_default, extract_field_rename, extract_rename_all, parse_enum_to_schema,\n    parse_struct_to_schema, rename_field,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","operation.rs"],"content":"use std::collections::BTreeMap;\n\nuse syn::{FnArg, PatType, Type};\nuse vespera_core::{\n    route::{MediaType, Operation, Parameter, ParameterLocation, RequestBody, Response},\n    schema::{Schema, SchemaRef},\n};\n\nuse super::{\n    parameters::parse_function_parameter, path::extract_path_parameters,\n    request_body::parse_request_body, response::parse_return_type,\n    schema::parse_type_to_schema_ref_with_schemas,\n};\n\n/// Build Operation from function signature\npub fn build_operation_from_function(\n    sig: \u0026syn::Signature,\n    path: \u0026str,\n    known_schemas: \u0026std::collections::HashMap\u003cString, String\u003e,\n    struct_definitions: \u0026std::collections::HashMap\u003cString, String\u003e,\n    error_status: Option\u003c\u0026[u16]\u003e,\n    tags: Option\u003c\u0026[String]\u003e,\n) -\u003e Operation {\n    let path_params = extract_path_parameters(path);\n    let mut parameters = Vec::new();\n    let mut request_body = None;\n    let mut path_extractor_type: Option\u003cType\u003e = None;\n\n    // First pass: find Path\u003cT\u003e extractor and extract its type\n    for input in \u0026sig.inputs {\n        if let FnArg::Typed(PatType { ty, .. }) = input\n            \u0026\u0026 let Type::Path(type_path) = ty.as_ref()\n        {\n            let path_segments = \u0026type_path.path;\n            if !path_segments.segments.is_empty() {\n                let segment = path_segments.segments.last().unwrap();\n                if segment.ident == \"Path\"\n                    \u0026\u0026 let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\n                    \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first()\n                {\n                    path_extractor_type = Some(inner_ty.clone());\n                    break;\n                }\n            }\n        }\n    }\n\n    // Generate path parameters from path string (not from function signature)\n    // This is the primary source of truth for path parameters\n    if !path_params.is_empty() {\n        if let Some(ty) = path_extractor_type {\n            // Check if it's a tuple type\n            if let Type::Tuple(tuple) = ty {\n                // For tuple types, match each path parameter with tuple element type\n                for (idx, param_name) in path_params.iter().enumerate() {\n                    if let Some(elem_ty) = tuple.elems.get(idx) {\n                        parameters.push(Parameter {\n                            name: param_name.clone(),\n                            r#in: ParameterLocation::Path,\n                            description: None,\n                            required: Some(true),\n                            schema: Some(parse_type_to_schema_ref_with_schemas(\n                                elem_ty,\n                                known_schemas,\n                                struct_definitions,\n                            )),\n                            example: None,\n                        });\n                    } else {\n                        // If tuple doesn't have enough elements, use String as default\n                        parameters.push(Parameter {\n                            name: param_name.clone(),\n                            r#in: ParameterLocation::Path,\n                            description: None,\n                            required: Some(true),\n                            schema: Some(parse_type_to_schema_ref_with_schemas(\n                                \u0026syn::parse_str::\u003cType\u003e(\"String\").unwrap(),\n                                known_schemas,\n                                struct_definitions,\n                            )),\n                            example: None,\n                        });\n                    }\n                }\n            } else {\n                // Single path parameter\n                if path_params.len() == 1 {\n                    parameters.push(Parameter {\n                        name: path_params[0].clone(),\n                        r#in: ParameterLocation::Path,\n                        description: None,\n                        required: Some(true),\n                        schema: Some(parse_type_to_schema_ref_with_schemas(\n                            \u0026ty,\n                            known_schemas,\n                            struct_definitions,\n                        )),\n                        example: None,\n                    });\n                } else {\n                    // Multiple path parameters but single type - use String for all\n                    for param_name in \u0026path_params {\n                        parameters.push(Parameter {\n                            name: param_name.clone(),\n                            r#in: ParameterLocation::Path,\n                            description: None,\n                            required: Some(true),\n                            schema: Some(parse_type_to_schema_ref_with_schemas(\n                                \u0026ty,\n                                known_schemas,\n                                struct_definitions,\n                            )),\n                            example: None,\n                        });\n                    }\n                }\n            }\n        } else {\n            // No Path extractor found, but path has parameters - use String as default\n            for param_name in \u0026path_params {\n                parameters.push(Parameter {\n                    name: param_name.clone(),\n                    r#in: ParameterLocation::Path,\n                    description: None,\n                    required: Some(true),\n                    schema: Some(parse_type_to_schema_ref_with_schemas(\n                        \u0026syn::parse_str::\u003cType\u003e(\"String\").unwrap(),\n                        known_schemas,\n                        struct_definitions,\n                    )),\n                    example: None,\n                });\n            }\n        }\n    }\n\n    // Parse function parameters (skip Path extractor as we already handled it)\n    for input in \u0026sig.inputs {\n        // Check if it's a request body (Json\u003cT\u003e)\n        if let Some(body) = parse_request_body(input, known_schemas, struct_definitions) {\n            request_body = Some(body);\n        } else {\n            // Skip Path extractor - we already handled path parameters above\n            let is_path_extractor = if let FnArg::Typed(PatType { ty, .. }) = input\n                \u0026\u0026 let Type::Path(type_path) = ty.as_ref()\n                \u0026\u0026 !\u0026type_path.path.segments.is_empty()\n            {\n                let segment = \u0026type_path.path.segments.last().unwrap();\n                segment.ident == \"Path\"\n            } else {\n                false\n            };\n\n            if !is_path_extractor\n                \u0026\u0026 let Some(params) =\n                    parse_function_parameter(input, \u0026path_params, known_schemas, struct_definitions)\n            {\n                parameters.extend(params);\n            }\n        }\n    }\n\n    // Fallback: if last arg is String/\u0026str and no body yet, treat as text/plain body\n    if request_body.is_none()\n        \u0026\u0026 let Some(FnArg::Typed(PatType { ty, .. })) = sig.inputs.last()\n    {\n        let is_string = match ty.as_ref() {\n            Type::Path(type_path) =\u003e type_path\n                .path\n                .segments\n                .last()\n                .map(|s| s.ident == \"String\" || s.ident == \"str\")\n                .unwrap_or(false),\n            Type::Reference(type_ref) =\u003e {\n                if let Type::Path(p) = type_ref.elem.as_ref() {\n                    p.path\n                        .segments\n                        .last()\n                        .map(|s| s.ident == \"String\" || s.ident == \"str\")\n                        .unwrap_or(false)\n                } else {\n                    false\n                }\n            }\n            _ =\u003e false,\n        };\n\n        if is_string {\n            let mut content = BTreeMap::new();\n            content.insert(\n                \"text/plain\".to_string(),\n                MediaType {\n                    schema: Some(SchemaRef::Inline(Box::new(Schema::string()))),\n                    example: None,\n                    examples: None,\n                },\n            );\n            request_body = Some(RequestBody {\n                description: None,\n                content,\n                required: Some(true),\n            });\n        }\n    }\n\n    // Parse return type - may return multiple responses (for Result types)\n    let mut responses = parse_return_type(\u0026sig.output, known_schemas, struct_definitions);\n\n    // Add additional error status codes from error_status attribute\n    if let Some(status_codes) = error_status {\n        // Find the error response schema (usually 400 or the first error response)\n        let error_schema = responses\n            .iter()\n            .find(|(code, _)| code != \u0026\u0026\"200\".to_string())\n            .and_then(|(_, resp)| {\n                resp.content\n                    .as_ref()?\n                    .get(\"application/json\")?\n                    .schema\n                    .clone()\n            });\n\n        if let Some(schema) = error_schema {\n            for \u0026status_code in status_codes {\n                let status_str = status_code.to_string();\n                // Only add if not already present\n                responses.entry(status_str).or_insert_with(|| {\n                    let mut err_content = BTreeMap::new();\n                    err_content.insert(\n                        \"application/json\".to_string(),\n                        MediaType {\n                            schema: Some(schema.clone()),\n                            example: None,\n                            examples: None,\n                        },\n                    );\n\n                    Response {\n                        description: \"Error response\".to_string(),\n                        headers: None,\n                        content: Some(err_content),\n                    }\n                });\n            }\n        }\n    }\n\n    Operation {\n        operation_id: Some(sig.ident.to_string()),\n        tags: tags.map(|t| t.to_vec()),\n        summary: None,\n        description: None,\n        parameters: if parameters.is_empty() {\n            None\n        } else {\n            Some(parameters)\n        },\n        request_body,\n        responses,\n        security: None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rstest::rstest;\n    use std::collections::HashMap;\n    use vespera_core::schema::{SchemaRef, SchemaType};\n\n    fn param_schema_type(param: \u0026Parameter) -\u003e Option\u003cSchemaType\u003e {\n        match param.schema.as_ref()? {\n            SchemaRef::Inline(schema) =\u003e schema.schema_type.clone(),\n            SchemaRef::Ref(_) =\u003e None,\n        }\n    }\n\n    fn build(sig_src: \u0026str, path: \u0026str, error_status: Option\u003c\u0026[u16]\u003e) -\u003e Operation {\n        let sig: syn::Signature = syn::parse_str(sig_src).expect(\"signature parse failed\");\n        build_operation_from_function(\n            \u0026sig,\n            path,\n            \u0026HashMap::new(),\n            \u0026HashMap::new(),\n            error_status,\n            None,\n        )\n    }\n\n    #[derive(Clone, Debug)]\n    struct ExpectedParam {\n        name: \u0026'static str,\n        schema: Option\u003cSchemaType\u003e,\n    }\n\n    #[derive(Clone, Debug)]\n    struct ExpectedBody {\n        content_type: \u0026'static str,\n        schema: Option\u003cSchemaType\u003e,\n    }\n\n    #[derive(Clone, Debug)]\n    struct ExpectedResp {\n        status: \u0026'static str,\n        schema: Option\u003cSchemaType\u003e,\n    }\n\n    fn assert_body(op: \u0026Operation, expected: \u0026Option\u003cExpectedBody\u003e) {\n        match expected {\n            None =\u003e assert!(op.request_body.is_none()),\n            Some(exp) =\u003e {\n                let body = op.request_body.as_ref().expect(\"request body expected\");\n                let media = body\n                    .content\n                    .get(exp.content_type)\n                    .or_else(|| {\n                        // allow fallback to the only available content type if expected is absent\n                        if body.content.len() == 1 {\n                            body.content.values().next()\n                        } else {\n                            None\n                        }\n                    })\n                    .expect(\"expected content type\");\n                if let Some(schema_ty) = \u0026exp.schema {\n                    match media.schema.as_ref().expect(\"schema expected\") {\n                        SchemaRef::Inline(schema) =\u003e {\n                            assert_eq!(schema.schema_type, Some(schema_ty.clone()));\n                        }\n                        SchemaRef::Ref(_) =\u003e panic!(\"expected inline schema\"),\n                    }\n                }\n            }\n        }\n    }\n\n    fn assert_params(op: \u0026Operation, expected: \u0026[ExpectedParam]) {\n        match op.parameters.as_ref() {\n            None =\u003e assert!(expected.is_empty()),\n            Some(params) =\u003e {\n                assert_eq!(params.len(), expected.len());\n                for (param, exp) in params.iter().zip(expected) {\n                    assert_eq!(param.name, exp.name);\n                    assert_eq!(param_schema_type(param), exp.schema);\n                }\n            }\n        }\n    }\n\n    fn assert_responses(op: \u0026Operation, expected: \u0026[ExpectedResp]) {\n        for exp in expected {\n            let resp = op.responses.get(exp.status).expect(\"response missing\");\n            let media = resp\n                .content\n                .as_ref()\n                .and_then(|c| c.get(\"application/json\"))\n                .or_else(|| resp.content.as_ref().and_then(|c| c.get(\"text/plain\")))\n                .expect(\"media type missing\");\n            if let Some(schema_ty) = \u0026exp.schema {\n                match media.schema.as_ref().expect(\"schema expected\") {\n                    SchemaRef::Inline(schema) =\u003e {\n                        assert_eq!(schema.schema_type, Some(schema_ty.clone()));\n                    }\n                    SchemaRef::Ref(_) =\u003e panic!(\"expected inline schema\"),\n                }\n            }\n        }\n    }\n\n    #[rstest]\n    #[case(\n        \"fn upload(data: String) -\u003e String\",\n        \"/upload\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![],\n        Some(ExpectedBody { content_type: \"text/plain\", schema: Some(SchemaType::String) }),\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn upload_ref(data: \u0026str) -\u003e String\",\n        \"/upload\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![],\n        Some(ExpectedBody { content_type: \"text/plain\", schema: Some(SchemaType::String) }),\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn get(Path(params): Path\u003c(i32,)\u003e) -\u003e String\",\n        \"/users/{id}/{name}\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![\n            ExpectedParam { name: \"id\", schema: Some(SchemaType::Integer) },\n            ExpectedParam { name: \"name\", schema: Some(SchemaType::String) },\n        ],\n        None,\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn get() -\u003e String\",\n        \"/items/{item_id}\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![ExpectedParam { name: \"item_id\", schema: Some(SchemaType::String) }],\n        None,\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn get(Path(id): Path\u003cString\u003e) -\u003e String\",\n        \"/shops/{shop_id}/items/{item_id}\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![\n            ExpectedParam { name: \"shop_id\", schema: Some(SchemaType::String) },\n            ExpectedParam { name: \"item_id\", schema: Some(SchemaType::String) },\n        ],\n        None,\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn create(Json(body): Json\u003cUser\u003e) -\u003e Result\u003cString, String\u003e\",\n        \"/create\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![],\n        Some(ExpectedBody { content_type: \"application/json\", schema: None }),\n        vec![\n            ExpectedResp { status: \"200\", schema: Some(SchemaType::String) },\n            ExpectedResp { status: \"400\", schema: Some(SchemaType::String) },\n        ]\n    )]\n    #[case(\n        \"fn get(Path(params): Path\u003c(i32,)\u003e) -\u003e String\",\n        \"/users/{id}/{name}/{extra}\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![\n            ExpectedParam { name: \"id\", schema: Some(SchemaType::Integer) },\n            ExpectedParam { name: \"name\", schema: Some(SchemaType::String) },\n            ExpectedParam { name: \"extra\", schema: Some(SchemaType::String) },\n        ],\n        None,\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn get() -\u003e String\",\n        \"/items/{item_id}/extra/{more}\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![\n            ExpectedParam { name: \"item_id\", schema: Some(SchemaType::String) },\n            ExpectedParam { name: \"more\", schema: Some(SchemaType::String) },\n        ],\n        None,\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn post(data: String) -\u003e String\",\n        \"/post\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![],\n        Some(ExpectedBody { content_type: \"text/plain\", schema: Some(SchemaType::String) }),\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn no_error_extra() -\u003e String\",\n        \"/plain\",\n        Some(\u0026[500u16][..]),\n        vec![],\n        None,\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn create() -\u003e Result\u003cString, String\u003e\",\n        \"/create\",\n        Some(\u0026[400u16, 500u16][..]),\n        vec![],\n        None,\n        vec![\n            ExpectedResp { status: \"200\", schema: Some(SchemaType::String) },\n            ExpectedResp { status: \"400\", schema: Some(SchemaType::String) },\n            ExpectedResp { status: \"500\", schema: Some(SchemaType::String) },\n        ]\n    )]\n    #[case(\n        \"fn create() -\u003e Result\u003cString, String\u003e\",\n        \"/create\",\n        Some(\u0026[401u16, 402u16][..]),\n        vec![],\n        None,\n        vec![\n            ExpectedResp { status: \"200\", schema: Some(SchemaType::String) },\n            ExpectedResp { status: \"400\", schema: Some(SchemaType::String) },\n            ExpectedResp { status: \"401\", schema: Some(SchemaType::String) },\n            ExpectedResp { status: \"402\", schema: Some(SchemaType::String) },\n        ]\n    )]\n    fn test_build_operation_cases(\n        #[case] sig_src: \u0026str,\n        #[case] path: \u0026str,\n        #[case] extra_status: Option\u003c\u0026[u16]\u003e,\n        #[case] expected_params: Vec\u003cExpectedParam\u003e,\n        #[case] expected_body: Option\u003cExpectedBody\u003e,\n        #[case] expected_resps: Vec\u003cExpectedResp\u003e,\n    ) {\n        let op = build(sig_src, path, extra_status);\n        assert_params(\u0026op, \u0026expected_params);\n        assert_body(\u0026op, \u0026expected_body);\n        assert_responses(\u0026op, \u0026expected_resps);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":24,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":25,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":26,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":27,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":30,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":31,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":32,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":34,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":35,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":36,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":37,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":38,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":39,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":41,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":42,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":50,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":51,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":53,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":55,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":56,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":57,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":58,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":59,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":60,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":61,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":62,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":63,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":64,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":71,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":72,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":73,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":74,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":75,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":77,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":78,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":79,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":81,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":87,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":103,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":104,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":105,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":106,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":107,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":108,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":109,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":110,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":111,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":113,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":120,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":121,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":122,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":123,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":124,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":125,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":126,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":127,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":128,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":129,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":131,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":138,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":140,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":141,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":144,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":145,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":146,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":148,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":149,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":165,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":167,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":168,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":169,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":170,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":172,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":6124895493223874560}},{"line":210,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":212,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":214,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":215,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":216,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":217,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":218,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":220,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":223,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":224,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":225,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":227,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":228,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":229,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":230,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":231,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":232,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":233,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":234,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":238,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":239,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":240,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":241,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":249,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":250,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":253,"address":[],"length":0,"stats":{"Line":2449958197289549824}}],"covered":108,"coverable":140},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","parameters.rs"],"content":"use std::collections::HashMap;\r\n\r\nuse syn::{FnArg, Pat, PatType, Type};\r\nuse vespera_core::{\r\n    route::{Parameter, ParameterLocation},\r\n    schema::{Schema, SchemaRef, SchemaType},\r\n};\r\n\r\nuse super::schema::{\r\n    extract_field_rename, extract_rename_all, is_primitive_type, parse_struct_to_schema,\r\n    parse_type_to_schema_ref_with_schemas, rename_field,\r\n};\r\n\r\n/// Analyze function parameter and convert to OpenAPI Parameter(s)\r\n/// Returns None if parameter should be ignored (e.g., Query\u003cHashMap\u003c...\u003e\u003e)\r\n/// Returns Some(Vec\u003cParameter\u003e) with one or more parameters\r\npub fn parse_function_parameter(\r\n    arg: \u0026FnArg,\r\n    path_params: \u0026[String],\r\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\r\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\r\n) -\u003e Option\u003cVec\u003cParameter\u003e\u003e {\r\n    match arg {\r\n        FnArg::Receiver(_) =\u003e None,\r\n        FnArg::Typed(PatType { pat, ty, .. }) =\u003e {\r\n            // Extract parameter name from pattern\r\n            let param_name = match pat.as_ref() {\r\n                Pat::Ident(ident) =\u003e ident.ident.to_string(),\r\n                Pat::TupleStruct(tuple_struct) =\u003e {\r\n                    // Handle Path(id) pattern\r\n                    if tuple_struct.elems.len() == 1\r\n                        \u0026\u0026 let Pat::Ident(ident) = \u0026tuple_struct.elems[0]\r\n                    {\r\n                        ident.ident.to_string()\r\n                    } else {\r\n                        return None;\r\n                    }\r\n                }\r\n                _ =\u003e return None,\r\n            };\r\n\r\n            // Check for Option\u003cTypedHeader\u003cT\u003e\u003e first\r\n            if let Type::Path(type_path) = ty.as_ref() {\r\n                let path = \u0026type_path.path;\r\n                if !path.segments.is_empty() {\r\n                    let segment = path.segments.first().unwrap();\r\n                    let ident_str = segment.ident.to_string();\r\n\r\n                    // Handle Option\u003cTypedHeader\u003cT\u003e\u003e\r\n                    if ident_str == \"Option\"\r\n                        \u0026\u0026 let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n                        \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first()\r\n                        \u0026\u0026 let Type::Path(inner_type_path) = inner_ty\r\n                        \u0026\u0026 !inner_type_path.path.segments.is_empty()\r\n                    {\r\n                        let inner_segment = inner_type_path.path.segments.last().unwrap();\r\n                        let inner_ident_str = inner_segment.ident.to_string();\r\n\r\n                        if inner_ident_str == \"TypedHeader\" {\r\n                            // TypedHeader always uses string schema regardless of inner type\r\n                            return Some(vec![Parameter {\r\n                                name: param_name.replace(\"_\", \"-\"),\r\n                                r#in: ParameterLocation::Header,\r\n                                description: None,\r\n                                required: Some(false),\r\n                                schema: Some(SchemaRef::Inline(Box::new(Schema::string()))),\r\n                                example: None,\r\n                            }]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Check for common Axum extractors first (before checking path_params)\r\n            // Handle both Path\u003cT\u003e and vespera::axum::extract::Path\u003cT\u003e by checking the last segment\r\n            if let Type::Path(type_path) = ty.as_ref() {\r\n                let path = \u0026type_path.path;\r\n                if !path.segments.is_empty() {\r\n                    // Check the last segment (handles both Path\u003cT\u003e and vespera::axum::extract::Path\u003cT\u003e)\r\n                    let segment = path.segments.last().unwrap();\r\n                    let ident_str = segment.ident.to_string();\r\n\r\n                    match ident_str.as_str() {\r\n                        \"Path\" =\u003e {\r\n                            // Path\u003cT\u003e extractor - use path parameter name from route if available\r\n                            if let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n                                \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) =\r\n                                    args.args.first()\r\n                            {\r\n                                // Check if inner type is a tuple (e.g., Path\u003c(String, String, String)\u003e)\r\n                                if let Type::Tuple(tuple) = inner_ty {\r\n                                    // For tuple types, extract parameters from path string\r\n                                    let mut parameters = Vec::new();\r\n                                    let tuple_elems = \u0026tuple.elems;\r\n\r\n                                    // Match tuple elements with path parameters\r\n                                    for (idx, elem_ty) in tuple_elems.iter().enumerate() {\r\n                                        if let Some(param_name) = path_params.get(idx) {\r\n                                            parameters.push(Parameter {\r\n                                                name: param_name.clone(),\r\n                                                r#in: ParameterLocation::Path,\r\n                                                description: None,\r\n                                                required: Some(true),\r\n                                                schema: Some(\r\n                                                    parse_type_to_schema_ref_with_schemas(\r\n                                                        elem_ty,\r\n                                                        known_schemas,\r\n                                                        struct_definitions,\r\n                                                    ),\r\n                                                ),\r\n                                                example: None,\r\n                                            });\r\n                                        }\r\n                                    }\r\n\r\n                                    if !parameters.is_empty() {\r\n                                        return Some(parameters);\r\n                                    }\r\n                                } else {\r\n                                    // Single path parameter\r\n                                    // Allow only when exactly one path parameter is provided\r\n                                    if path_params.len() != 1 {\r\n                                        return None;\r\n                                    }\r\n                                    let name = path_params[0].clone();\r\n                                    return Some(vec![Parameter {\r\n                                        name,\r\n                                        r#in: ParameterLocation::Path,\r\n                                        description: None,\r\n                                        required: Some(true),\r\n                                        schema: Some(parse_type_to_schema_ref_with_schemas(\r\n                                            inner_ty,\r\n                                            known_schemas,\r\n                                            struct_definitions,\r\n                                        )),\r\n                                        example: None,\r\n                                    }]);\r\n                                }\r\n                            }\r\n                        }\r\n                        \"Query\" =\u003e {\r\n                            // Query\u003cT\u003e extractor\r\n                            if let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n                                \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) =\r\n                                    args.args.first()\r\n                            {\r\n                                // Check if it's HashMap or BTreeMap - ignore these\r\n                                if is_map_type(inner_ty) {\r\n                                    return None;\r\n                                }\r\n\r\n                                // Check if it's a struct - expand to individual parameters\r\n                                if let Some(struct_params) = parse_query_struct_to_parameters(\r\n                                    inner_ty,\r\n                                    known_schemas,\r\n                                    struct_definitions,\r\n                                ) {\r\n                                    return Some(struct_params);\r\n                                }\r\n\r\n                                // Ignore primitive-like query params (including Vec/Option of primitive)\r\n                                if is_primitive_like(inner_ty) {\r\n                                    return None;\r\n                                }\r\n\r\n                                // Check if it's a known type (primitive or known schema)\r\n                                // If unknown, don't add parameter\r\n                                if !is_known_type(inner_ty, known_schemas, struct_definitions) {\r\n                                    return None;\r\n                                }\r\n\r\n                                // Otherwise, treat as single parameter\r\n                                return Some(vec![Parameter {\r\n                                    name: param_name.clone(),\r\n                                    r#in: ParameterLocation::Query,\r\n                                    description: None,\r\n                                    required: Some(true),\r\n                                    schema: Some(parse_type_to_schema_ref_with_schemas(\r\n                                        inner_ty,\r\n                                        known_schemas,\r\n                                        struct_definitions,\r\n                                    )),\r\n                                    example: None,\r\n                                }]);\r\n                            }\r\n                        }\r\n                        \"Header\" =\u003e {\r\n                            // Header\u003cT\u003e extractor\r\n                            if let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n                                \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) =\r\n                                    args.args.first()\r\n                            {\r\n                                // Ignore primitive-like headers\r\n                                if is_primitive_like(inner_ty) {\r\n                                    return None;\r\n                                }\r\n                                return Some(vec![Parameter {\r\n                                    name: param_name.clone(),\r\n                                    r#in: ParameterLocation::Header,\r\n                                    description: None,\r\n                                    required: Some(true),\r\n                                    schema: Some(parse_type_to_schema_ref_with_schemas(\r\n                                        inner_ty,\r\n                                        known_schemas,\r\n                                        struct_definitions,\r\n                                    )),\r\n                                    example: None,\r\n                                }]);\r\n                            }\r\n                        }\r\n                        \"TypedHeader\" =\u003e {\r\n                            // TypedHeader\u003cT\u003e extractor (axum::TypedHeader)\r\n                            // TypedHeader always uses string schema regardless of inner type\r\n                            return Some(vec![Parameter {\r\n                                name: param_name.replace(\"_\", \"-\"),\r\n                                r#in: ParameterLocation::Header,\r\n                                description: None,\r\n                                required: Some(true),\r\n                                schema: Some(SchemaRef::Inline(Box::new(Schema::string()))),\r\n                                example: None,\r\n                            }]);\r\n                        }\r\n                        \"Json\" =\u003e {\r\n                            // Json\u003cT\u003e extractor - this will be handled as RequestBody\r\n                            return None;\r\n                        }\r\n                        _ =\u003e {}\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Check if it's a path parameter (by name match) - for non-extractor cases\r\n            if path_params.contains(\u0026param_name) {\r\n                return Some(vec![Parameter {\r\n                    name: param_name.clone(),\r\n                    r#in: ParameterLocation::Path,\r\n                    description: None,\r\n                    required: Some(true),\r\n                    schema: Some(parse_type_to_schema_ref_with_schemas(\r\n                        ty,\r\n                        known_schemas,\r\n                        struct_definitions,\r\n                    )),\r\n                    example: None,\r\n                }]);\r\n            }\r\n\r\n            // Bare primitive without extractor is ignored (cannot infer location)\r\n            None\r\n        }\r\n    }\r\n}\r\n\r\nfn is_map_type(ty: \u0026Type) -\u003e bool {\r\n    if let Type::Path(type_path) = ty {\r\n        let path = \u0026type_path.path;\r\n        if !path.segments.is_empty() {\r\n            let segment = path.segments.last().unwrap();\r\n            let ident_str = segment.ident.to_string();\r\n            return ident_str == \"HashMap\" || ident_str == \"BTreeMap\";\r\n        }\r\n    }\r\n    false\r\n}\r\n\r\nfn is_primitive_like(ty: \u0026Type) -\u003e bool {\r\n    if is_primitive_type(ty) {\r\n        return true;\r\n    }\r\n    if let Type::Path(type_path) = ty\r\n        \u0026\u0026 let Some(seg) = type_path.path.segments.last()\r\n    {\r\n        let ident = seg.ident.to_string();\r\n        if let syn::PathArguments::AngleBracketed(args) = \u0026seg.arguments\r\n            \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first()\r\n            \u0026\u0026 (ident == \"Vec\" || ident == \"Option\")\r\n            \u0026\u0026 is_primitive_like(inner_ty)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    false\r\n}\r\n\r\nfn is_known_type(\r\n    ty: \u0026Type,\r\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\r\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\r\n) -\u003e bool {\r\n    // Check if it's a primitive type\r\n    if is_primitive_type(ty) {\r\n        return true;\r\n    }\r\n\r\n    // Check if it's a known struct\r\n    if let Type::Path(type_path) = ty {\r\n        let path = \u0026type_path.path;\r\n        if path.segments.is_empty() {\r\n            return false;\r\n        }\r\n\r\n        let segment = path.segments.last().unwrap();\r\n        let ident_str = segment.ident.to_string();\r\n\r\n        // Get type name (handle both simple and qualified paths)\r\n\r\n        // Check if it's in struct_definitions or known_schemas\r\n        if struct_definitions.contains_key(\u0026ident_str) || known_schemas.contains_key(\u0026ident_str) {\r\n            return true;\r\n        }\r\n\r\n        // Check for generic types like Vec\u003cT\u003e, Option\u003cT\u003e - recursively check inner type\r\n        if let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments {\r\n            match ident_str.as_str() {\r\n                \"Vec\" | \"Option\" =\u003e {\r\n                    if let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first() {\r\n                        return is_known_type(inner_ty, known_schemas, struct_definitions);\r\n                    }\r\n                }\r\n                _ =\u003e {}\r\n            }\r\n        }\r\n    }\r\n\r\n    false\r\n}\r\n\r\n/// Parse struct fields to individual query parameters\r\n/// Returns None if the type is not a struct or cannot be parsed\r\nfn parse_query_struct_to_parameters(\r\n    ty: \u0026Type,\r\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\r\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\r\n) -\u003e Option\u003cVec\u003cParameter\u003e\u003e {\r\n    // Check if it's a known struct\r\n    if let Type::Path(type_path) = ty {\r\n        let path = \u0026type_path.path;\r\n        if path.segments.is_empty() {\r\n            return None;\r\n        }\r\n\r\n        let segment = path.segments.last().unwrap();\r\n        let ident_str = segment.ident.to_string();\r\n\r\n        // Get type name (handle both simple and qualified paths)\r\n\r\n        // Check if it's a known struct\r\n        if let Some(struct_def) = struct_definitions.get(\u0026ident_str)\r\n            \u0026\u0026 let Ok(struct_item) = syn::parse_str::\u003csyn::ItemStruct\u003e(struct_def)\r\n        {\r\n            let mut parameters = Vec::new();\r\n\r\n            // Extract rename_all attribute from struct\r\n            let rename_all = extract_rename_all(\u0026struct_item.attrs);\r\n\r\n            if let syn::Fields::Named(fields_named) = \u0026struct_item.fields {\r\n                for field in \u0026fields_named.named {\r\n                    let rust_field_name = field\r\n                        .ident\r\n                        .as_ref()\r\n                        .map(|i| i.to_string())\r\n                        .unwrap_or_else(|| \"unknown\".to_string());\r\n\r\n                    // Check for field-level rename attribute first (takes precedence)\r\n                    let field_name = if let Some(renamed) = extract_field_rename(\u0026field.attrs) {\r\n                        renamed\r\n                    } else {\r\n                        // Apply rename_all transformation if present\r\n                        rename_field(\u0026rust_field_name, rename_all.as_deref())\r\n                    };\r\n\r\n                    let field_type = \u0026field.ty;\r\n\r\n                    // Check if field is Option\u003cT\u003e\r\n                    let is_optional = matches!(\r\n                        field_type,\r\n                        Type::Path(type_path)\r\n                            if type_path\r\n                                .path\r\n                                .segments\r\n                                .first()\r\n                                .map(|s| s.ident == \"Option\")\r\n                                .unwrap_or(false)\r\n                    );\r\n\r\n                    // Parse field type to schema (inline, not ref)\r\n                    // For Query parameters, we need inline schemas, not refs\r\n                    let mut field_schema = parse_type_to_schema_ref_with_schemas(\r\n                        field_type,\r\n                        known_schemas,\r\n                        struct_definitions,\r\n                    );\r\n\r\n                    // Convert ref to inline if needed (Query parameters should not use refs)\r\n                    // If it's a ref to a known struct, get the struct definition and inline it\r\n                    if let SchemaRef::Ref(ref_ref) = \u0026field_schema {\r\n                        // Try to extract type name from ref path (e.g., \"#/components/schemas/User\" -\u003e \"User\")\r\n                        if let Some(type_name) =\r\n                            ref_ref.ref_path.strip_prefix(\"#/components/schemas/\")\r\n                            \u0026\u0026 let Some(struct_def) = struct_definitions.get(type_name)\r\n                            \u0026\u0026 let Ok(nested_struct_item) =\r\n                                syn::parse_str::\u003csyn::ItemStruct\u003e(struct_def)\r\n                        {\r\n                            // Parse the nested struct to schema (inline)\r\n                            let nested_schema = parse_struct_to_schema(\r\n                                \u0026nested_struct_item,\r\n                                known_schemas,\r\n                                struct_definitions,\r\n                            );\r\n                            field_schema = SchemaRef::Inline(Box::new(nested_schema));\r\n                        }\r\n                    }\r\n\r\n                    // If it's Option\u003cT\u003e, make it nullable\r\n                    let final_schema = if is_optional {\r\n                        if let SchemaRef::Inline(mut schema) = field_schema {\r\n                            schema.nullable = Some(true);\r\n                            SchemaRef::Inline(schema)\r\n                        } else {\r\n                            // If still a ref, convert to inline object with nullable\r\n                            SchemaRef::Inline(Box::new(Schema {\r\n                                schema_type: Some(SchemaType::Object),\r\n                                nullable: Some(true),\r\n                                ..Schema::object()\r\n                            }))\r\n                        }\r\n                    } else {\r\n                        // If it's still a ref, convert to inline object\r\n                        match field_schema {\r\n                            SchemaRef::Ref(_) =\u003e {\r\n                                SchemaRef::Inline(Box::new(Schema::new(SchemaType::Object)))\r\n                            }\r\n                            SchemaRef::Inline(schema) =\u003e SchemaRef::Inline(schema),\r\n                        }\r\n                    };\r\n\r\n                    let required = !is_optional;\r\n\r\n                    parameters.push(Parameter {\r\n                        name: field_name,\r\n                        r#in: ParameterLocation::Query,\r\n                        description: None,\r\n                        required: Some(required),\r\n                        schema: Some(final_schema),\r\n                        example: None,\r\n                    });\r\n                }\r\n            }\r\n\r\n            if !parameters.is_empty() {\r\n                return Some(parameters);\r\n            }\r\n        }\r\n    }\r\n    None\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use insta::{assert_debug_snapshot, with_settings};\r\n    use rstest::rstest;\r\n    use std::collections::HashMap;\r\n    use vespera_core::route::ParameterLocation;\r\n\r\n    fn setup_test_data(func_src: \u0026str) -\u003e (HashMap\u003cString, String\u003e, HashMap\u003cString, String\u003e) {\r\n        let mut struct_definitions = HashMap::new();\r\n        let known_schemas: HashMap\u003cString, String\u003e = HashMap::new();\r\n\r\n        if func_src.contains(\"QueryParams\") {\r\n            struct_definitions.insert(\r\n                \"QueryParams\".to_string(),\r\n                r#\"\r\n                pub struct QueryParams {\r\n                    pub page: i32,\r\n                    pub limit: Option\u003ci32\u003e,\r\n                }\r\n                \"#\r\n                .to_string(),\r\n            );\r\n        }\r\n\r\n        if func_src.contains(\"User\") {\r\n            struct_definitions.insert(\r\n                \"User\".to_string(),\r\n                r#\"\r\n                pub struct User {\r\n                    pub id: i32,\r\n                    pub name: String,\r\n                }\r\n                \"#\r\n                .to_string(),\r\n            );\r\n        }\r\n\r\n        (known_schemas, struct_definitions)\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\r\n        \"fn test(params: Path\u003c(String, i32)\u003e) {}\",\r\n        vec![\"user_id\".to_string(), \"count\".to_string()],\r\n        vec![vec![ParameterLocation::Path, ParameterLocation::Path]],\r\n        \"path_tuple\"\r\n    )]\r\n    #[case(\r\n        \"fn show(Path(id): Path\u003ci32\u003e) {}\",\r\n        vec![\"item_id\".to_string()],\r\n        vec![vec![ParameterLocation::Path]],\r\n        \"path_single\"\r\n    )]\r\n    #[case(\r\n        \"fn test(Query(params): Query\u003cHashMap\u003cString, String\u003e\u003e) {}\",\r\n        vec![],\r\n        vec![vec![]],\r\n        \"query_hashmap\"\r\n    )]\r\n    #[case(\r\n        \"fn test(TypedHeader(user_agent): TypedHeader\u003cUserAgent\u003e, count: i32) {}\",\r\n        vec![],\r\n        vec![\r\n            vec![ParameterLocation::Header],\r\n            vec![],\r\n        ],\r\n        \"typed_header_and_arg\"\r\n    )]\r\n    #[case(\r\n        \"fn test(TypedHeader(user_agent): TypedHeader\u003cUserAgent\u003e, content_type: Option\u003cTypedHeader\u003cContentType\u003e\u003e, authorization: Option\u003cTypedHeader\u003cAuthorization\u003cBearer\u003e\u003e\u003e) {}\",\r\n        vec![],\r\n        vec![\r\n            vec![ParameterLocation::Header],\r\n            vec![ParameterLocation::Header],\r\n            vec![ParameterLocation::Header],\r\n        ],\r\n        \"typed_header_multi\"\r\n    )]\r\n    #[case(\r\n        \"fn test(user_agent: TypedHeader\u003cUserAgent\u003e, count: i32) {}\",\r\n        vec![],\r\n        vec![\r\n            vec![ParameterLocation::Header],\r\n            vec![],\r\n        ],\r\n        \"header_value_and_arg\"\r\n    )]\r\n    #[case(\r\n        \"fn test(\u0026self, id: i32) {}\",\r\n        vec![],\r\n        vec![\r\n            vec![],\r\n            vec![],\r\n        ],\r\n        \"method_receiver\"\r\n    )]\r\n    #[case(\r\n        \"fn test(Path((a, b)): Path\u003c(i32, String)\u003e) {}\",\r\n        vec![],\r\n        vec![vec![]],\r\n        \"path_tuple_destructure\"\r\n    )]\r\n    #[case(\r\n        \"fn test(params: Query\u003cQueryParams\u003e) {}\",\r\n        vec![],\r\n        vec![vec![ParameterLocation::Query, ParameterLocation::Query]],\r\n        \"query_struct\"\r\n    )]\r\n    #[case(\r\n        \"fn test(body: Json\u003cUser\u003e) {}\",\r\n        vec![],\r\n        vec![vec![]],\r\n        \"json_body\"\r\n    )]\r\n    #[case(\r\n        \"fn test(params: Query\u003cUnknownType\u003e) {}\",\r\n        vec![],\r\n        vec![vec![]],\r\n        \"query_unknown\"\r\n    )]\r\n    #[case(\r\n        \"fn test(params: Query\u003cBTreeMap\u003cString, String\u003e\u003e) {}\",\r\n        vec![],\r\n        vec![vec![]],\r\n        \"query_map\"\r\n    )]\r\n    #[case(\r\n        \"fn test(user: Query\u003cUser\u003e) {}\",\r\n        vec![],\r\n        vec![vec![ParameterLocation::Query, ParameterLocation::Query]],\r\n        \"query_user\"\r\n    )]\r\n    #[case(\r\n        \"fn test(custom: Header\u003cCustomHeader\u003e) {}\",\r\n        vec![],\r\n        vec![vec![ParameterLocation::Header]],\r\n        \"header_custom\"\r\n    )]\r\n    fn test_parse_function_parameter_cases(\r\n        #[case] func_src: \u0026str,\r\n        #[case] path_params: Vec\u003cString\u003e,\r\n        #[case] expected_locations: Vec\u003cVec\u003cParameterLocation\u003e\u003e,\r\n        #[case] suffix: \u0026str,\r\n    ) {\r\n        let func: syn::ItemFn = syn::parse_str(func_src).unwrap();\r\n        let (known_schemas, struct_definitions) = setup_test_data(func_src);\r\n        let mut parameters = Vec::new();\r\n\r\n        for (idx, arg) in func.sig.inputs.iter().enumerate() {\r\n            let result =\r\n                parse_function_parameter(arg, \u0026path_params, \u0026known_schemas, \u0026struct_definitions);\r\n            let expected = expected_locations\r\n                .get(idx)\r\n                .unwrap_or_else(|| expected_locations.last().unwrap());\r\n\r\n            if expected.is_empty() {\r\n                assert!(\r\n                    result.is_none(),\r\n                    \"Expected None at arg index {}, func: {}\",\r\n                    idx,\r\n                    func_src\r\n                );\r\n                continue;\r\n            }\r\n\r\n            let params = result.as_ref().expect(\"Expected Some parameters\");\r\n            let got_locs: Vec\u003cParameterLocation\u003e = params.iter().map(|p| p.r#in.clone()).collect();\r\n            assert_eq!(\r\n                got_locs, *expected,\r\n                \"Location mismatch at arg index {idx}, func: {func_src}\"\r\n            );\r\n            parameters.extend(params.clone());\r\n        }\r\n        with_settings!({ snapshot_suffix =\u003e format!(\"params_{}\", suffix) }, {\r\n            assert_debug_snapshot!(parameters);\r\n        });\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\r\n        \"fn test(id: Query\u003ci32\u003e) {}\",\r\n        vec![],\r\n    )]\r\n    #[case(\r\n        \"fn test(auth: Header\u003cString\u003e) {}\",\r\n        vec![],\r\n    )]\r\n    #[case(\r\n        \"fn test(params: Query\u003cVec\u003ci32\u003e\u003e) {}\",\r\n        vec![],\r\n    )]\r\n    #[case(\r\n        \"fn test(params: Query\u003cOption\u003cString\u003e\u003e) {}\",\r\n        vec![],\r\n    )]\r\n    #[case(\r\n        \"fn test(Path([a]): Path\u003c[i32; 1]\u003e) {}\",\r\n        vec![],\r\n    )]\r\n    #[case(\r\n        \"fn test(id: Path\u003ci32\u003e) {}\",\r\n        vec![\"user_id\".to_string(), \"post_id\".to_string()],\r\n    )]\r\n    #[case(\r\n        \"fn test((x, y): (i32, i32)) {}\",\r\n        vec![],\r\n    )]\r\n    fn test_parse_function_parameter_wrong_cases(\r\n        #[case] func_src: \u0026str,\r\n        #[case] path_params: Vec\u003cString\u003e,\r\n    ) {\r\n        let func: syn::ItemFn = syn::parse_str(func_src).unwrap();\r\n        let (known_schemas, struct_definitions) = setup_test_data(func_src);\r\n\r\n        // Provide custom types for header/query known schemas/structs\r\n        let mut struct_definitions = struct_definitions;\r\n        struct_definitions.insert(\r\n            \"User\".to_string(),\r\n            \"pub struct User { pub id: i32 }\".to_string(),\r\n        );\r\n        let mut known_schemas = known_schemas;\r\n        known_schemas.insert(\r\n            \"CustomHeader\".to_string(),\r\n            \"#/components/schemas/CustomHeader\".to_string(),\r\n        );\r\n\r\n        for (idx, arg) in func.sig.inputs.iter().enumerate() {\r\n            let result =\r\n                parse_function_parameter(arg, \u0026path_params, \u0026known_schemas, \u0026struct_definitions);\r\n            assert!(\r\n                result.is_none(),\r\n                \"Expected None at arg index {}, func: {}, got: {:?}\",\r\n                idx,\r\n                func_src,\r\n                result\r\n            );\r\n        }\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\"i32\", true)]\r\n    #[case(\"Vec\u003cString\u003e\", true)]\r\n    #[case(\"Option\u003cbool\u003e\", true)]\r\n    #[case(\"CustomType\", false)]\r\n    fn test_is_primitive_like_fn(#[case] type_str: \u0026str, #[case] expected: bool) {\r\n        let ty: Type = syn::parse_str(type_str).unwrap();\r\n        assert_eq!(is_primitive_like(\u0026ty), expected, \"type_str={}\", type_str);\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\"HashMap\u003cString, String\u003e\", true)]\r\n    #[case(\"BTreeMap\u003cString, String\u003e\", true)]\r\n    #[case(\"String\", false)]\r\n    #[case(\"Vec\u003ci32\u003e\", false)]\r\n    fn test_is_map_type(#[case] type_str: \u0026str, #[case] expected: bool) {\r\n        let ty: Type = syn::parse_str(type_str).unwrap();\r\n        assert_eq!(is_map_type(\u0026ty), expected, \"type_str={}\", type_str);\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\"i32\", HashMap::new(), HashMap::new(), true)] // primitive type\r\n    #[case(\r\n        \"User\",\r\n        HashMap::new(),\r\n        {\r\n            let mut map = HashMap::new();\r\n            map.insert(\"User\".to_string(), \"pub struct User { id: i32 }\".to_string());\r\n            map\r\n        },\r\n        true\r\n    )] // known struct\r\n    #[case(\r\n        \"Product\",\r\n        {\r\n            let mut map = HashMap::new();\r\n            map.insert(\"Product\".to_string(), \"Product\".to_string());\r\n            map\r\n        },\r\n        HashMap::new(),\r\n        true\r\n    )] // known schema\r\n    #[case(\"Vec\u003ci32\u003e\", HashMap::new(), HashMap::new(), true)] // Vec\u003cT\u003e with known inner type\r\n    #[case(\"Option\u003cString\u003e\", HashMap::new(), HashMap::new(), true)] // Option\u003cT\u003e with known inner type\r\n    #[case(\"UnknownType\", HashMap::new(), HashMap::new(), false)] // unknown type\r\n    fn test_is_known_type(\r\n        #[case] type_str: \u0026str,\r\n        #[case] known_schemas: HashMap\u003cString, String\u003e,\r\n        #[case] struct_definitions: HashMap\u003cString, String\u003e,\r\n        #[case] expected: bool,\r\n    ) {\r\n        let ty: Type = syn::parse_str(type_str).unwrap();\r\n        assert_eq!(\r\n            is_known_type(\u0026ty, \u0026known_schemas, \u0026struct_definitions),\r\n            expected,\r\n            \"Type: {}\",\r\n            type_str\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_parse_query_struct_to_parameters() {\r\n        let mut struct_definitions = HashMap::new();\r\n        let mut known_schemas = HashMap::new();\r\n\r\n        // Test with struct that has fields\r\n        struct_definitions.insert(\r\n            \"QueryParams\".to_string(),\r\n            r#\"\r\n            #[serde(rename_all = \"camelCase\")]\r\n            pub struct QueryParams {\r\n                pub page: i32,\r\n                #[serde(rename = \"per_page\")]\r\n                pub limit: Option\u003ci32\u003e,\r\n                pub search: String,\r\n            }\r\n            \"#\r\n            .to_string(),\r\n        );\r\n\r\n        let ty: Type = syn::parse_str(\"QueryParams\").unwrap();\r\n        let result = parse_query_struct_to_parameters(\u0026ty, \u0026known_schemas, \u0026struct_definitions);\r\n        assert!(result.is_some());\r\n        let params = result.unwrap();\r\n        assert_eq!(params.len(), 3);\r\n        assert_eq!(params[0].name, \"page\");\r\n        assert_eq!(params[0].r#in, ParameterLocation::Query);\r\n        assert_eq!(params[1].name, \"per_page\");\r\n        assert_eq!(params[1].r#in, ParameterLocation::Query);\r\n        assert_eq!(params[2].name, \"search\");\r\n        assert_eq!(params[2].r#in, ParameterLocation::Query);\r\n\r\n        // Test with struct that has nested struct (ref to inline conversion)\r\n        struct_definitions.insert(\r\n            \"NestedQuery\".to_string(),\r\n            r#\"\r\n            pub struct NestedQuery {\r\n                pub user: User,\r\n            }\r\n            \"#\r\n            .to_string(),\r\n        );\r\n        struct_definitions.insert(\r\n            \"User\".to_string(),\r\n            r#\"\r\n            pub struct User {\r\n                pub id: i32,\r\n            }\r\n            \"#\r\n            .to_string(),\r\n        );\r\n        known_schemas.insert(\"User\".to_string(), \"#/components/schemas/User\".to_string());\r\n\r\n        let ty: Type = syn::parse_str(\"NestedQuery\").unwrap();\r\n        let result = parse_query_struct_to_parameters(\u0026ty, \u0026known_schemas, \u0026struct_definitions);\r\n        assert!(result.is_some());\r\n\r\n        // Test with non-struct type\r\n        let ty: Type = syn::parse_str(\"i32\").unwrap();\r\n        let result = parse_query_struct_to_parameters(\u0026ty, \u0026known_schemas, \u0026struct_definitions);\r\n        assert!(result.is_none());\r\n\r\n        // Test with unknown struct\r\n        let ty: Type = syn::parse_str(\"UnknownStruct\").unwrap();\r\n        let result = parse_query_struct_to_parameters(\u0026ty, \u0026known_schemas, \u0026struct_definitions);\r\n        assert!(result.is_none());\r\n\r\n        // Test with struct that has Option\u003cT\u003e fields\r\n        struct_definitions.insert(\r\n            \"OptionalQuery\".to_string(),\r\n            r#\"\r\n            pub struct OptionalQuery {\r\n                pub required: i32,\r\n                pub optional: Option\u003cString\u003e,\r\n            }\r\n            \"#\r\n            .to_string(),\r\n        );\r\n\r\n        let ty: Type = syn::parse_str(\"OptionalQuery\").unwrap();\r\n        let result = parse_query_struct_to_parameters(\u0026ty, \u0026known_schemas, \u0026struct_definitions);\r\n        assert!(result.is_some());\r\n        let params = result.unwrap();\r\n        assert_eq!(params.len(), 2);\r\n        assert_eq!(params[0].required, Some(true));\r\n        assert_eq!(params[1].required, Some(false));\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":23,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":27,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":28,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":29,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":31,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":32,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":34,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":36,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":39,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":43,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":44,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":45,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":46,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":47,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":50,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":51,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":52,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":53,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":54,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":56,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":57,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":59,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":61,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":62,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":63,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":64,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":65,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":76,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":77,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":78,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":80,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":81,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":83,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":84,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":86,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":87,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":88,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":91,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":93,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":94,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":97,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":98,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":99,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":100,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":101,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":102,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":103,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":104,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":105,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":106,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":107,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":108,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":111,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":116,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":117,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":122,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":123,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":125,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":127,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":129,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":130,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":131,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":132,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":133,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":134,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":136,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":141,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":143,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":144,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":145,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":148,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":149,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":154,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":155,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":156,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":158,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":162,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":163,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":168,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":169,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":189,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":190,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":191,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":194,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":195,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":197,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":198,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":199,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":200,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":201,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":202,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":203,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":204,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":205,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":207,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":211,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":214,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":215,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":216,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":217,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":218,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":219,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":220,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":223,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":225,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":227,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":233,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":254,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":255,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":256,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":257,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":258,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":259,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":260,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":267,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":268,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":270,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":271,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":273,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":274,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":275,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":276,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":277,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":279,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":282,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":285,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":291,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":292,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":296,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":297,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":298,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":303,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":308,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":309,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":313,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":314,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":315,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":316,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":317,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":330,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":336,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":337,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":338,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":343,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":348,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":349,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":351,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":354,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":356,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":357,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":358,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":359,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":361,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":362,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":365,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":366,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":369,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":372,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":375,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":376,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":377,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":378,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":379,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":380,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":381,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":382,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":383,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":389,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":390,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":391,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":396,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":398,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":399,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":400,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":401,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":402,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":406,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":407,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":408,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":410,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":415,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":416,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":417,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":418,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":437,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":439,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":440,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":441,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":442,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":443,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":444,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":445,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":450,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":451,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":455,"address":[],"length":0,"stats":{"Line":432345564227567616}}],"covered":210,"coverable":239},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","path.rs"],"content":"/// Extract path parameters from a path string\r\npub fn extract_path_parameters(path: \u0026str) -\u003e Vec\u003cString\u003e {\r\n    let mut params = Vec::new();\r\n    let segments: Vec\u003c\u0026str\u003e = path.split('/').collect();\r\n\r\n    for segment in segments {\r\n        if segment.starts_with('{') \u0026\u0026 segment.ends_with('}') {\r\n            let param = segment.trim_start_matches('{').trim_end_matches('}');\r\n            params.push(param.to_string());\r\n        } else if segment.starts_with(':') {\r\n            let param = segment.trim_start_matches(':');\r\n            params.push(param.to_string());\r\n        }\r\n    }\r\n\r\n    params\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use rstest::rstest;\r\n\r\n    #[rstest]\r\n    #[case(\"/test\", vec![])]\r\n    #[case(\"/test/{id}\", vec![\"id\"])]\r\n    #[case(\"/test/{id}/test/{test_id}\", vec![\"id\", \"test_id\"])]\r\n    #[case(\"/test/:id/test/:test_id\", vec![\"id\", \"test_id\"])]\r\n    fn test_extract_path_parameters(#[case] path: \u0026str, #[case] expected: Vec\u003c\u0026str\u003e) {\r\n        assert_eq!(extract_path_parameters(path), expected);\r\n    }\r\n}\r\n","traces":[{"line":2,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":3,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":4,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":6,"address":[],"length":0,"stats":{"Line":10304235947423694848}},{"line":7,"address":[],"length":0,"stats":{"Line":11601272640106397696}},{"line":8,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":9,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":10,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":11,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":12,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":16,"address":[],"length":0,"stats":{"Line":1513209474796486656}}],"covered":11,"coverable":11},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","request_body.rs"],"content":"use std::collections::BTreeMap;\r\n\r\nuse syn::{FnArg, PatType, Type};\r\nuse vespera_core::route::{MediaType, RequestBody};\r\n\r\nuse super::schema::parse_type_to_schema_ref_with_schemas;\r\n\r\nfn is_string_like(ty: \u0026Type) -\u003e bool {\r\n    match ty {\r\n        Type::Path(type_path) =\u003e type_path\r\n            .path\r\n            .segments\r\n            .last()\r\n            .map(|seg| seg.ident == \"String\" || seg.ident == \"str\")\r\n            .unwrap_or(false),\r\n        Type::Reference(type_ref) =\u003e is_string_like(\u0026type_ref.elem),\r\n        _ =\u003e false,\r\n    }\r\n}\r\n\r\n/// Analyze function signature and extract RequestBody\r\npub fn parse_request_body(\r\n    arg: \u0026FnArg,\r\n    known_schemas: \u0026std::collections::HashMap\u003cString, String\u003e,\r\n    struct_definitions: \u0026std::collections::HashMap\u003cString, String\u003e,\r\n) -\u003e Option\u003cRequestBody\u003e {\r\n    match arg {\r\n        FnArg::Receiver(_) =\u003e None,\r\n        FnArg::Typed(PatType { ty, .. }) =\u003e {\r\n            if let Type::Path(type_path) = ty.as_ref() {\r\n                let path = \u0026type_path.path;\r\n\r\n                // Check the last segment (handles both Json\u003cT\u003e and vespera::axum::Json\u003cT\u003e)\r\n                let segment = path.segments.last().unwrap();\r\n                let ident_str = segment.ident.to_string();\r\n\r\n                if ident_str == \"Json\"\r\n                    \u0026\u0026 let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n                    \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first()\r\n                {\r\n                    let schema = parse_type_to_schema_ref_with_schemas(\r\n                        inner_ty,\r\n                        known_schemas,\r\n                        struct_definitions,\r\n                    );\r\n                    let mut content = BTreeMap::new();\r\n                    content.insert(\r\n                        \"application/json\".to_string(),\r\n                        MediaType {\r\n                            schema: Some(schema),\r\n                            example: None,\r\n                            examples: None,\r\n                        },\r\n                    );\r\n                    return Some(RequestBody {\r\n                        description: None,\r\n                        required: Some(true),\r\n                        content,\r\n                    });\r\n                }\r\n            }\r\n\r\n            if is_string_like(ty.as_ref()) {\r\n                let schema =\r\n                    parse_type_to_schema_ref_with_schemas(ty, known_schemas, struct_definitions);\r\n                let mut content = BTreeMap::new();\r\n                content.insert(\r\n                    \"text/plain\".to_string(),\r\n                    MediaType {\r\n                        schema: Some(schema),\r\n                        example: None,\r\n                        examples: None,\r\n                    },\r\n                );\r\n\r\n                return Some(RequestBody {\r\n                    description: None,\r\n                    required: Some(true),\r\n                    content,\r\n                });\r\n            }\r\n            None\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use insta::{assert_debug_snapshot, with_settings};\r\n    use rstest::rstest;\r\n    use std::collections::HashMap;\r\n\r\n    #[rstest]\r\n    #[case(\"String\", true)]\r\n    #[case(\"str\", true)]\r\n    #[case(\"\u0026String\", true)]\r\n    #[case(\"\u0026str\", true)]\r\n    #[case(\"i32\", false)]\r\n    #[case(\"Vec\u003cString\u003e\", false)]\r\n    #[case(\"!\", false)]\r\n    fn test_is_string_like_cases(#[case] ty_src: \u0026str, #[case] expected: bool) {\r\n        let ty: Type = syn::parse_str(ty_src).expect(\"type parse failed\");\r\n        assert_eq!(is_string_like(\u0026ty), expected);\r\n    }\r\n\r\n    #[rstest]\r\n    #[case::json(\"fn test(Json(payload): Json\u003cUser\u003e) {}\", true, \"json\")]\r\n    #[case::string(\"fn test(just_string: String) {}\", true, \"string\")]\r\n    #[case::str(\"fn test(just_str: \u0026str) {}\", true, \"str\")]\r\n    #[case::i32(\"fn test(just_i32: i32) {}\", false, \"i32\")]\r\n    #[case::vec_string(\"fn test(just_vec_string: Vec\u003cString\u003e) {}\", false, \"vec_string\")]\r\n    #[case::self_ref(\"fn test(\u0026self) {}\", false, \"self_ref\")]\r\n    fn test_parse_request_body_cases(\r\n        #[case] func_src: \u0026str,\r\n        #[case] has_body: bool,\r\n        #[case] suffix: \u0026str,\r\n    ) {\r\n        let func: syn::ItemFn = syn::parse_str(func_src).unwrap();\r\n        let arg = func.sig.inputs.first().unwrap();\r\n        let body = parse_request_body(arg, \u0026HashMap::new(), \u0026HashMap::new());\r\n        assert_eq!(body.is_some(), has_body);\r\n        with_settings!({ snapshot_suffix =\u003e format!(\"req_body_{}\", suffix) }, {\r\n            assert_debug_snapshot!(body);\r\n        });\r\n    }\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":9,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":10,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":11,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":12,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":14,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":16,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":17,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":27,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":28,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":29,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":30,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":31,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":34,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":35,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":37,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":38,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":39,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":43,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":44,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":46,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":48,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":49,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":50,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":52,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":55,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":56,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":58,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":63,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":64,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":65,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":66,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":67,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":68,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":69,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":70,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":71,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":72,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":76,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":77,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":78,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":79,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":82,"address":[],"length":0,"stats":{"Line":360287970189639680}}],"covered":48,"coverable":48},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","response.rs"],"content":"use std::collections::{BTreeMap, HashMap};\r\n\r\nuse syn::{ReturnType, Type};\r\nuse vespera_core::route::{Header, MediaType, Response};\r\n\r\nuse crate::parser::is_keyword_type::{KeywordType, is_keyword_type, is_keyword_type_by_type_path};\r\n\r\nuse super::schema::parse_type_to_schema_ref_with_schemas;\r\n\r\n/// Unwrap Json\u003cT\u003e to get T\r\n/// Handles both Json\u003cT\u003e and vespera::axum::Json\u003cT\u003e by checking the last segment\r\nfn unwrap_json(ty: \u0026Type) -\u003e \u0026Type {\r\n    if let Type::Path(type_path) = ty {\r\n        let path = \u0026type_path.path;\r\n        if !path.segments.is_empty() {\r\n            // Check the last segment (handles both Json\u003cT\u003e and vespera::axum::Json\u003cT\u003e)\r\n            let segment = path.segments.last().unwrap();\r\n            if segment.ident == \"Json\"\r\n                \u0026\u0026 let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n                \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first()\r\n            {\r\n                return inner_ty;\r\n            }\r\n        }\r\n    }\r\n    ty\r\n}\r\n\r\n/// Extract Ok and Err types from Result\u003cT, E\u003e or Result\u003cJson\u003cT\u003e, E\u003e\r\n/// Handles both Result and std::result::Result, and unwraps references\r\nfn extract_result_types(ty: \u0026Type) -\u003e Option\u003c(Type, Type)\u003e {\r\n    // First unwrap Json if present\r\n    let unwrapped = unwrap_json(ty);\r\n\r\n    // Handle both Type::Path and Type::Reference (for \u0026Result\u003c...\u003e)\r\n    let result_type = if let Type::Path(type_path) = unwrapped {\r\n        type_path\r\n    } else if let Type::Reference(type_ref) = unwrapped\r\n        \u0026\u0026 let Type::Path(type_path) = type_ref.elem.as_ref()\r\n    {\r\n        type_path\r\n    } else {\r\n        return None;\r\n    };\r\n\r\n    let path = \u0026result_type.path;\r\n    if path.segments.is_empty() {\r\n        return None;\r\n    }\r\n\r\n    if is_keyword_type_by_type_path(result_type, \u0026KeywordType::Result)\r\n        \u0026\u0026 let Some(segment) = path.segments.last()\r\n        \u0026\u0026 let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n        \u0026\u0026 args.args.len() \u003e= 2\r\n        \u0026\u0026 let (Some(syn::GenericArgument::Type(ok_ty)), Some(syn::GenericArgument::Type(err_ty))) =\r\n            (args.args.first(), args.args.get(1))\r\n    {\r\n        // Get the last segment (Result) to check for generics\r\n        // Unwrap Json from Ok type if present\r\n        let ok_ty_unwrapped = unwrap_json(ok_ty);\r\n        return Some((ok_ty_unwrapped.clone(), err_ty.clone()));\r\n    }\r\n    None\r\n}\r\n\r\n/// Check if error type is a tuple (StatusCode, E) or (StatusCode, Json\u003cE\u003e)\r\n/// Returns the error type E and a default status code (400)\r\nfn extract_status_code_tuple(err_ty: \u0026Type) -\u003e Option\u003c(u16, Type)\u003e {\r\n    if let Type::Tuple(tuple) = err_ty\r\n        \u0026\u0026 tuple\r\n            .elems\r\n            .iter()\r\n            .any(|ty| is_keyword_type(ty, \u0026KeywordType::StatusCode))\r\n    {\r\n        Some((400, unwrap_json(tuple.elems.last().unwrap()).clone()))\r\n    } else {\r\n        None\r\n    }\r\n}\r\n\r\n/// Extract payload type from an Ok tuple and track if headers exist.\r\n/// The last element of the tuple is always treated as the response body.\r\n/// Any presence of HeaderMap in the tuple marks headers as present.\r\nfn extract_ok_payload_and_headers(ok_ty: \u0026Type) -\u003e (Type, Option\u003cHashMap\u003cString, Header\u003e\u003e) {\r\n    if let Type::Tuple(tuple) = ok_ty {\r\n        let payload_ty = tuple.elems.last().map(|ty| unwrap_json(ty).clone());\r\n\r\n        if let Some(payload_ty) = payload_ty {\r\n            let headers = if tuple\r\n                .elems\r\n                .iter()\r\n                .any(|ty| is_keyword_type(ty, \u0026KeywordType::HeaderMap))\r\n            {\r\n                Some(HashMap::new())\r\n            } else {\r\n                None\r\n            };\r\n            return (payload_ty, headers);\r\n        }\r\n    }\r\n\r\n    (ok_ty.clone(), None)\r\n}\r\n\r\n/// Analyze return type and convert to Responses map\r\npub fn parse_return_type(\r\n    return_type: \u0026ReturnType,\r\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\r\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\r\n) -\u003e BTreeMap\u003cString, Response\u003e {\r\n    let mut responses = BTreeMap::new();\r\n\r\n    match return_type {\r\n        ReturnType::Default =\u003e {\r\n            // No return type - just 200 with no content\r\n            responses.insert(\r\n                \"200\".to_string(),\r\n                Response {\r\n                    description: \"Successful response\".to_string(),\r\n                    headers: None,\r\n                    content: None,\r\n                },\r\n            );\r\n        }\r\n        ReturnType::Type(_, ty) =\u003e {\r\n            // Check if it's a Result\u003cT, E\u003e\r\n            if let Some((ok_ty, err_ty)) = extract_result_types(ty) {\r\n                // Handle success response (200)\r\n                let (ok_payload_ty, ok_headers) = extract_ok_payload_and_headers(\u0026ok_ty);\r\n                let ok_schema = parse_type_to_schema_ref_with_schemas(\r\n                    \u0026ok_payload_ty,\r\n                    known_schemas,\r\n                    struct_definitions,\r\n                );\r\n                let mut ok_content = BTreeMap::new();\r\n                ok_content.insert(\r\n                    \"application/json\".to_string(),\r\n                    MediaType {\r\n                        schema: Some(ok_schema),\r\n                        example: None,\r\n                        examples: None,\r\n                    },\r\n                );\r\n\r\n                responses.insert(\r\n                    \"200\".to_string(),\r\n                    Response {\r\n                        description: \"Successful response\".to_string(),\r\n                        headers: ok_headers,\r\n                        content: Some(ok_content),\r\n                    },\r\n                );\r\n\r\n                // Handle error response\r\n                // Check if error is (StatusCode, E) tuple\r\n                if let Some((status_code, error_type)) = extract_status_code_tuple(\u0026err_ty) {\r\n                    // Use the status code from the tuple\r\n                    let err_schema = parse_type_to_schema_ref_with_schemas(\r\n                        \u0026error_type,\r\n                        known_schemas,\r\n                        struct_definitions,\r\n                    );\r\n                    let mut err_content = BTreeMap::new();\r\n                    err_content.insert(\r\n                        \"application/json\".to_string(),\r\n                        MediaType {\r\n                            schema: Some(err_schema),\r\n                            example: None,\r\n                            examples: None,\r\n                        },\r\n                    );\r\n\r\n                    responses.insert(\r\n                        status_code.to_string(),\r\n                        Response {\r\n                            description: \"Error response\".to_string(),\r\n                            headers: None,\r\n                            content: Some(err_content),\r\n                        },\r\n                    );\r\n                } else {\r\n                    // Regular error type - use default 400\r\n                    // Unwrap Json if present\r\n                    let err_ty_unwrapped = unwrap_json(\u0026err_ty);\r\n                    let err_schema = parse_type_to_schema_ref_with_schemas(\r\n                        err_ty_unwrapped,\r\n                        known_schemas,\r\n                        struct_definitions,\r\n                    );\r\n                    let mut err_content = BTreeMap::new();\r\n                    err_content.insert(\r\n                        \"application/json\".to_string(),\r\n                        MediaType {\r\n                            schema: Some(err_schema),\r\n                            example: None,\r\n                            examples: None,\r\n                        },\r\n                    );\r\n\r\n                    responses.insert(\r\n                        \"400\".to_string(),\r\n                        Response {\r\n                            description: \"Error response\".to_string(),\r\n                            headers: None,\r\n                            content: Some(err_content),\r\n                        },\r\n                    );\r\n                }\r\n            } else {\r\n                // Not a Result type - regular response\r\n                // Unwrap Json\u003cT\u003e if present\r\n                let unwrapped_ty = unwrap_json(ty);\r\n                let schema = parse_type_to_schema_ref_with_schemas(\r\n                    unwrapped_ty,\r\n                    known_schemas,\r\n                    struct_definitions,\r\n                );\r\n                let mut content = BTreeMap::new();\r\n                content.insert(\r\n                    \"application/json\".to_string(),\r\n                    MediaType {\r\n                        schema: Some(schema),\r\n                        example: None,\r\n                        examples: None,\r\n                    },\r\n                );\r\n\r\n                responses.insert(\r\n                    \"200\".to_string(),\r\n                    Response {\r\n                        description: \"Successful response\".to_string(),\r\n                        headers: None,\r\n                        content: Some(content),\r\n                    },\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    responses\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use rstest::rstest;\r\n    use std::collections::HashMap;\r\n    use vespera_core::schema::{SchemaRef, SchemaType};\r\n\r\n    #[derive(Debug)]\r\n    struct ExpectedSchema {\r\n        schema_type: SchemaType,\r\n        nullable: bool,\r\n        items_schema_type: Option\u003cSchemaType\u003e,\r\n    }\r\n\r\n    #[derive(Debug)]\r\n    struct ExpectedResponse {\r\n        status: \u0026'static str,\r\n        schema: ExpectedSchema,\r\n    }\r\n\r\n    fn parse_return_type_str(return_type_str: \u0026str) -\u003e syn::ReturnType {\r\n        if return_type_str.is_empty() {\r\n            syn::ReturnType::Default\r\n        } else {\r\n            let full_signature = format!(\"fn test() {}\", return_type_str);\r\n            syn::parse_str::\u003csyn::Signature\u003e(\u0026full_signature)\r\n                .expect(\"Failed to parse return type\")\r\n                .output\r\n        }\r\n    }\r\n\r\n    fn assert_schema_matches(schema_ref: \u0026SchemaRef, expected: \u0026ExpectedSchema) {\r\n        match schema_ref {\r\n            SchemaRef::Inline(schema) =\u003e {\r\n                assert_eq!(schema.schema_type, Some(expected.schema_type.clone()));\r\n                assert_eq!(schema.nullable.unwrap_or(false), expected.nullable);\r\n                if let Some(item_ty) = \u0026expected.items_schema_type {\r\n                    let items = schema\r\n                        .items\r\n                        .as_ref()\r\n                        .expect(\"items should be present for array\");\r\n                    match items.as_ref() {\r\n                        SchemaRef::Inline(item_schema) =\u003e {\r\n                            assert_eq!(item_schema.schema_type, Some(item_ty.clone()));\r\n                        }\r\n                        SchemaRef::Ref(_) =\u003e panic!(\"expected inline schema for array items\"),\r\n                    }\r\n                }\r\n            }\r\n            SchemaRef::Ref(_) =\u003e panic!(\"expected inline schema\"),\r\n        }\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\"\", None, None, None)]\r\n    #[case(\r\n        \"-\u003e String\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        None,\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e \u0026str\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        None,\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e i32\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::Integer, nullable: false, items_schema_type: None }),\r\n        None,\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e bool\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::Boolean, nullable: false, items_schema_type: None }),\r\n        None,\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Vec\u003cString\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::Array, nullable: false, items_schema_type: Some(SchemaType::String) }),\r\n        None,\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Option\u003cString\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: true, items_schema_type: None }),\r\n        None,\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003cString, String\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003ci32, String\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::Integer, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003cJson\u003cUser\u003e, String\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::Object, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003c\u0026str, String\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003cString, (StatusCode, String)\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003cString, (StatusCode, Json\u003cString\u003e)\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003c(HeaderMap\u003cString, String\u003e, Json\u003ci32\u003e), String\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::Integer, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        Some(true)\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003cString, (axum::http::StatusCode, Json\u003ci32\u003e)\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::Integer, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    fn test_parse_return_type(\r\n        #[case] return_type_str: \u0026str,\r\n        #[case] ok_expectation: Option\u003cExpectedSchema\u003e,\r\n        #[case] err_expectation: Option\u003cExpectedResponse\u003e,\r\n        #[case] ok_headers_expected: Option\u003cbool\u003e,\r\n    ) {\r\n        let known_schemas = HashMap::new();\r\n        let struct_definitions = HashMap::new();\r\n        let return_type = parse_return_type_str(return_type_str);\r\n\r\n        let responses = parse_return_type(\u0026return_type, \u0026known_schemas, \u0026struct_definitions);\r\n\r\n        // Validate success response\r\n        let ok_response = responses.get(\"200\").expect(\"200 response should exist\");\r\n        assert_eq!(ok_response.description, \"Successful response\");\r\n        match \u0026ok_expectation {\r\n            None =\u003e {\r\n                assert!(ok_response.content.is_none());\r\n            }\r\n            Some(expected_schema) =\u003e {\r\n                let content = ok_response\r\n                    .content\r\n                    .as_ref()\r\n                    .expect(\"ok content should exist\");\r\n                let media_type = content\r\n                    .get(\"application/json\")\r\n                    .expect(\"ok media type should exist\");\r\n                let schema_ref = media_type.schema.as_ref().expect(\"ok schema should exist\");\r\n                assert_schema_matches(schema_ref, expected_schema);\r\n            }\r\n        }\r\n        if let Some(expect_headers) = ok_headers_expected {\r\n            assert_eq!(ok_response.headers.is_some(), expect_headers);\r\n        }\r\n\r\n        // Validate error response (if any)\r\n        match \u0026err_expectation {\r\n            None =\u003e assert_eq!(responses.len(), 1),\r\n            Some(err) =\u003e {\r\n                assert_eq!(responses.len(), 2);\r\n                let err_response = responses\r\n                    .get(err.status)\r\n                    .expect(\"error response should exist\");\r\n                assert_eq!(err_response.description, \"Error response\");\r\n                let content = err_response\r\n                    .content\r\n                    .as_ref()\r\n                    .expect(\"error content should exist\");\r\n                let media_type = content\r\n                    .get(\"application/json\")\r\n                    .expect(\"error media type should exist\");\r\n                let schema_ref = media_type\r\n                    .schema\r\n                    .as_ref()\r\n                    .expect(\"error schema should exist\");\r\n                assert_schema_matches(schema_ref, \u0026err.schema);\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":13,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":14,"address":[],"length":0,"stats":{"Line":10088063165309911040}},{"line":15,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":17,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":18,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":19,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":20,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":22,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":26,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":31,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":33,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":36,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":37,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":41,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":47,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":52,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":53,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":54,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":55,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":56,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":60,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":61,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":63,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":68,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":69,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":71,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":72,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":73,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":75,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":77,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":84,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":85,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":86,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":89,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":90,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":92,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":94,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":102,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":106,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":111,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":113,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":114,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":116,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":117,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":118,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":119,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":120,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":121,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":125,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":127,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":129,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":131,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":132,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":133,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":135,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":136,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":137,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":138,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":139,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":140,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":141,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":145,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":146,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":147,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":148,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":149,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":150,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":156,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":159,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":160,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":161,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":163,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":164,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":165,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":166,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":167,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":168,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":169,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":173,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":174,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":175,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":176,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":177,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":178,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":184,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":186,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":187,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":188,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":190,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":191,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":192,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":193,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":194,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":195,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":196,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":200,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":201,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":202,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":203,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":204,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":205,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":212,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":214,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":215,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":216,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":218,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":219,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":220,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":221,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":222,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":223,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":224,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":228,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":229,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":230,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":231,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":232,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":233,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":240,"address":[],"length":0,"stats":{"Line":2305843009213693952}}],"covered":127,"coverable":130},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","schema.rs"],"content":"use std::collections::{BTreeMap, HashMap};\n\nuse syn::{Fields, Type};\nuse vespera_core::schema::{Reference, Schema, SchemaRef, SchemaType};\n\npub fn extract_rename_all(attrs: \u0026[syn::Attribute]) -\u003e Option\u003cString\u003e {\n    for attr in attrs {\n        if attr.path().is_ident(\"serde\") {\n            // Try using parse_nested_meta for robust parsing\n            let mut found_rename_all = None;\n            let _ = attr.parse_nested_meta(|meta| {\n                if meta.path.is_ident(\"rename_all\")\n                    \u0026\u0026 let Ok(value) = meta.value()\n                    \u0026\u0026 let Ok(syn::Expr::Lit(syn::ExprLit {\n                        lit: syn::Lit::Str(s),\n                        ..\n                    })) = value.parse::\u003csyn::Expr\u003e()\n                {\n                    found_rename_all = Some(s.value());\n                }\n                Ok(())\n            });\n            if found_rename_all.is_some() {\n                return found_rename_all;\n            }\n\n            // Fallback: manual token parsing\n            let tokens = match attr.meta.require_list() {\n                Ok(t) =\u003e t,\n                Err(_) =\u003e continue,\n            };\n            let token_str = tokens.tokens.to_string();\n\n            // Look for rename_all = \"...\" pattern\n            if let Some(start) = token_str.find(\"rename_all\") {\n                let remaining = \u0026token_str[start + \"rename_all\".len()..];\n                if let Some(equals_pos) = remaining.find('=') {\n                    let value_part = remaining[equals_pos + 1..].trim();\n                    // Extract string value - find the closing quote\n                    if let Some(quote_start) = value_part.find('\"') {\n                        let after_quote = \u0026value_part[quote_start + 1..];\n                        if let Some(quote_end) = after_quote.find('\"') {\n                            let value = \u0026after_quote[..quote_end];\n                            return Some(value.to_string());\n                        }\n                    }\n                }\n            }\n        }\n    }\n    None\n}\n\npub fn extract_field_rename(attrs: \u0026[syn::Attribute]) -\u003e Option\u003cString\u003e {\n    for attr in attrs {\n        if attr.path().is_ident(\"serde\")\n            \u0026\u0026 let syn::Meta::List(meta_list) = \u0026attr.meta\n        {\n            // Use parse_nested_meta to parse nested attributes\n            let mut found_rename = None;\n            let _ = attr.parse_nested_meta(|meta| {\n                if meta.path.is_ident(\"rename\")\n                    \u0026\u0026 let Ok(value) = meta.value()\n                    \u0026\u0026 let Ok(syn::Expr::Lit(syn::ExprLit {\n                        lit: syn::Lit::Str(s),\n                        ..\n                    })) = value.parse::\u003csyn::Expr\u003e()\n                {\n                    found_rename = Some(s.value());\n                }\n                Ok(())\n            });\n            if let Some(rename_value) = found_rename {\n                return Some(rename_value);\n            }\n\n            // Fallback: manual token parsing with regex-like approach\n            let tokens = meta_list.tokens.to_string();\n            // Look for pattern: rename = \"value\" (with proper word boundaries)\n            if let Some(start) = tokens.find(\"rename\") {\n                // Avoid false positives from rename_all\n                if tokens[start..].starts_with(\"rename_all\") {\n                    continue;\n                }\n                // Check that \"rename\" is a standalone word (not part of another word)\n                let before = if start \u003e 0 { \u0026tokens[..start] } else { \"\" };\n                let after_start = start + \"rename\".len();\n                let after = if after_start \u003c tokens.len() {\n                    \u0026tokens[after_start..]\n                } else {\n                    \"\"\n                };\n\n                let before_char = before.chars().last().unwrap_or(' ');\n                let after_char = after.chars().next().unwrap_or(' ');\n\n                // Check if rename is a standalone word (preceded by space/comma/paren, followed by space/equals)\n                if (before_char == ' ' || before_char == ',' || before_char == '(')\n                    \u0026\u0026 (after_char == ' ' || after_char == '=')\n                {\n                    // Find the equals sign and extract the quoted value\n                    if let Some(equals_pos) = after.find('=') {\n                        let value_part = \u0026after[equals_pos + 1..].trim();\n                        // Extract string value (remove quotes)\n                        if let Some(quote_start) = value_part.find('\"') {\n                            let after_quote = \u0026value_part[quote_start + 1..];\n                            if let Some(quote_end) = after_quote.find('\"') {\n                                let value = \u0026after_quote[..quote_end];\n                                return Some(value.to_string());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    None\n}\n\n/// Extract skip attribute from field attributes\n/// Returns true if #[serde(skip)] is present\npub(super) fn extract_skip(attrs: \u0026[syn::Attribute]) -\u003e bool {\n    for attr in attrs {\n        if attr.path().is_ident(\"serde\")\n            \u0026\u0026 let syn::Meta::List(meta_list) = \u0026attr.meta\n        {\n            let tokens = meta_list.tokens.to_string();\n            // Check for \"skip\" (not part of skip_serializing_if or skip_deserializing)\n            if tokens.contains(\"skip\") {\n                // Make sure it's not skip_serializing_if or skip_deserializing\n                if !tokens.contains(\"skip_serializing_if\") \u0026\u0026 !tokens.contains(\"skip_deserializing\")\n                {\n                    // Check if it's a standalone \"skip\"\n                    let skip_pos = tokens.find(\"skip\");\n                    if let Some(pos) = skip_pos {\n                        let before = if pos \u003e 0 { \u0026tokens[..pos] } else { \"\" };\n                        let after = \u0026tokens[pos + \"skip\".len()..];\n                        // Check if skip is not part of another word\n                        let before_char = before.chars().last().unwrap_or(' ');\n                        let after_char = after.chars().next().unwrap_or(' ');\n                        if (before_char == ' ' || before_char == ',' || before_char == '(')\n                            \u0026\u0026 (after_char == ' ' || after_char == ',' || after_char == ')')\n                        {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    false\n}\n\n/// Extract skip_serializing_if attribute from field attributes\n/// Returns true if #[serde(skip_serializing_if = \"...\")] is present\npub fn extract_skip_serializing_if(attrs: \u0026[syn::Attribute]) -\u003e bool {\n    for attr in attrs {\n        if attr.path().is_ident(\"serde\")\n            \u0026\u0026 let syn::Meta::List(meta_list) = \u0026attr.meta\n        {\n            let mut found = false;\n            let _ = attr.parse_nested_meta(|meta| {\n                if meta.path.is_ident(\"skip_serializing_if\") {\n                    found = true;\n                }\n                Ok(())\n            });\n            if found {\n                return true;\n            }\n\n            // Fallback: check tokens string\n            let tokens = meta_list.tokens.to_string();\n            if tokens.contains(\"skip_serializing_if\") {\n                return true;\n            }\n        }\n    }\n    false\n}\n\n/// Extract default attribute from field attributes\n/// Returns:\n/// - Some(None) if #[serde(default)] is present (no function)\n/// - Some(Some(function_name)) if #[serde(default = \"function_name\")] is present\n/// - None if no default attribute is present\npub fn extract_default(attrs: \u0026[syn::Attribute]) -\u003e Option\u003cOption\u003cString\u003e\u003e {\n    for attr in attrs {\n        if attr.path().is_ident(\"serde\")\n            \u0026\u0026 let syn::Meta::List(meta_list) = \u0026attr.meta\n        {\n            let mut found_default: Option\u003cOption\u003cString\u003e\u003e = None;\n            let _ = attr.parse_nested_meta(|meta| {\n                if meta.path.is_ident(\"default\") {\n                    // Check if it has a value (default = \"function_name\")\n                    if let Ok(value) = meta.value() {\n                        if let Ok(syn::Expr::Lit(syn::ExprLit {\n                            lit: syn::Lit::Str(s),\n                            ..\n                        })) = value.parse::\u003csyn::Expr\u003e()\n                        {\n                            found_default = Some(Some(s.value()));\n                        }\n                    } else {\n                        // Just \"default\" without value\n                        found_default = Some(None);\n                    }\n                }\n                Ok(())\n            });\n            if let Some(default_value) = found_default {\n                return Some(default_value);\n            }\n\n            // Fallback: manual token parsing\n            let tokens = meta_list.tokens.to_string();\n            if let Some(start) = tokens.find(\"default\") {\n                let remaining = \u0026tokens[start + \"default\".len()..];\n                if remaining.trim_start().starts_with('=') {\n                    // default = \"function_name\"\n                    let value_part = remaining.trim_start()[1..].trim();\n                    if value_part.starts_with('\"') \u0026\u0026 value_part.ends_with('\"') {\n                        let function_name = \u0026value_part[1..value_part.len() - 1];\n                        return Some(Some(function_name.to_string()));\n                    }\n                } else {\n                    // Just \"default\" without = (standalone)\n                    let before = if start \u003e 0 { \u0026tokens[..start] } else { \"\" };\n                    let after = \u0026remaining;\n                    let before_char = before.chars().last().unwrap_or(' ');\n                    let after_char = after.chars().next().unwrap_or(' ');\n                    if (before_char == ' ' || before_char == ',' || before_char == '(')\n                        \u0026\u0026 (after_char == ' ' || after_char == ',' || after_char == ')')\n                    {\n                        return Some(None);\n                    }\n                }\n            }\n        }\n    }\n    None\n}\n\npub fn rename_field(field_name: \u0026str, rename_all: Option\u003c\u0026str\u003e) -\u003e String {\n    // \"lowercase\", \"UPPERCASE\", \"PascalCase\", \"camelCase\", \"snake_case\", \"SCREAMING_SNAKE_CASE\", \"kebab-case\", \"SCREAMING-KEBAB-CASE\"\n    match rename_all {\n        Some(\"camelCase\") =\u003e {\n            // Convert snake_case or PascalCase to camelCase\n            let mut result = String::new();\n            let mut capitalize_next = false;\n            let mut in_first_word = true;\n            let chars: Vec\u003cchar\u003e = field_name.chars().collect();\n\n            for (i, \u0026ch) in chars.iter().enumerate() {\n                if ch == '_' {\n                    capitalize_next = true;\n                    in_first_word = false;\n                } else if in_first_word {\n                    // In first word: lowercase until we hit a word boundary\n                    // Word boundary: uppercase char followed by lowercase (e.g., \"XMLParser\" -\u003e \"P\" starts new word)\n                    let next_is_lower = chars.get(i + 1).is_some_and(|c| c.is_lowercase());\n                    if ch.is_uppercase() \u0026\u0026 next_is_lower \u0026\u0026 i \u003e 0 {\n                        // This uppercase starts a new word (e.g., 'P' in \"XMLParser\")\n                        in_first_word = false;\n                        result.push(ch);\n                    } else {\n                        // Still in first word, lowercase it\n                        result.push(ch.to_lowercase().next().unwrap_or(ch));\n                    }\n                } else if capitalize_next {\n                    result.push(ch.to_uppercase().next().unwrap_or(ch));\n                    capitalize_next = false;\n                } else {\n                    result.push(ch);\n                }\n            }\n            result\n        }\n        Some(\"snake_case\") =\u003e {\n            // Convert camelCase to snake_case\n            let mut result = String::new();\n            for (i, ch) in field_name.chars().enumerate() {\n                if ch.is_uppercase() \u0026\u0026 i \u003e 0 {\n                    result.push('_');\n                }\n                result.push(ch.to_lowercase().next().unwrap_or(ch));\n            }\n            result\n        }\n        Some(\"kebab-case\") =\u003e {\n            // Convert snake_case or Camel/PascalCase to kebab-case (lowercase with hyphens)\n            let mut result = String::new();\n            for (i, ch) in field_name.chars().enumerate() {\n                if ch.is_uppercase() {\n                    if i \u003e 0 \u0026\u0026 !result.ends_with('-') {\n                        result.push('-');\n                    }\n                    result.push(ch.to_lowercase().next().unwrap_or(ch));\n                } else if ch == '_' {\n                    result.push('-');\n                } else {\n                    result.push(ch);\n                }\n            }\n            result\n        }\n        Some(\"PascalCase\") =\u003e {\n            // Convert snake_case to PascalCase\n            let mut result = String::new();\n            let mut capitalize_next = true;\n            for ch in field_name.chars() {\n                if ch == '_' {\n                    capitalize_next = true;\n                } else if capitalize_next {\n                    result.push(ch.to_uppercase().next().unwrap_or(ch));\n                    capitalize_next = false;\n                } else {\n                    result.push(ch);\n                }\n            }\n            result\n        }\n        Some(\"lowercase\") =\u003e {\n            // Convert to lowercase\n            field_name.to_lowercase()\n        }\n        Some(\"UPPERCASE\") =\u003e {\n            // Convert to UPPERCASE\n            field_name.to_uppercase()\n        }\n        Some(\"SCREAMING_SNAKE_CASE\") =\u003e {\n            // Convert to SCREAMING_SNAKE_CASE\n            // If already in SCREAMING_SNAKE_CASE format, return as is\n            if field_name.chars().all(|c| c.is_uppercase() || c == '_') \u0026\u0026 field_name.contains('_')\n            {\n                return field_name.to_string();\n            }\n            // First convert to snake_case if needed, then uppercase\n            let mut snake_case = String::new();\n            for (i, ch) in field_name.chars().enumerate() {\n                if ch.is_uppercase() \u0026\u0026 i \u003e 0 \u0026\u0026 !snake_case.ends_with('_') {\n                    snake_case.push('_');\n                }\n                if ch != '_' \u0026\u0026 ch != '-' {\n                    snake_case.push(ch.to_lowercase().next().unwrap_or(ch));\n                } else if ch == '_' {\n                    snake_case.push('_');\n                }\n            }\n            snake_case.to_uppercase()\n        }\n        Some(\"SCREAMING-KEBAB-CASE\") =\u003e {\n            // Convert to SCREAMING-KEBAB-CASE\n            // First convert to kebab-case if needed, then uppercase\n            let mut kebab_case = String::new();\n            for (i, ch) in field_name.chars().enumerate() {\n                if ch.is_uppercase()\n                    \u0026\u0026 i \u003e 0\n                    \u0026\u0026 !kebab_case.ends_with('-')\n                    \u0026\u0026 !kebab_case.ends_with('_')\n                {\n                    kebab_case.push('-');\n                }\n                if ch == '_' {\n                    kebab_case.push('-');\n                } else if ch != '-' {\n                    kebab_case.push(ch.to_lowercase().next().unwrap_or(ch));\n                } else {\n                    kebab_case.push('-');\n                }\n            }\n            kebab_case.to_uppercase()\n        }\n        _ =\u003e field_name.to_string(),\n    }\n}\n\npub fn parse_enum_to_schema(\n    enum_item: \u0026syn::ItemEnum,\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Schema {\n    // Extract rename_all attribute from enum\n    let rename_all = extract_rename_all(\u0026enum_item.attrs);\n\n    // Check if all variants are unit variants\n    let all_unit = enum_item\n        .variants\n        .iter()\n        .all(|v| matches!(v.fields, syn::Fields::Unit));\n\n    if all_unit {\n        // Simple enum with string values\n        let mut enum_values = Vec::new();\n\n        for variant in \u0026enum_item.variants {\n            let variant_name = variant.ident.to_string();\n\n            // Check for variant-level rename attribute first (takes precedence)\n            let enum_value = if let Some(renamed) = extract_field_rename(\u0026variant.attrs) {\n                renamed\n            } else {\n                // Apply rename_all transformation if present\n                rename_field(\u0026variant_name, rename_all.as_deref())\n            };\n\n            enum_values.push(serde_json::Value::String(enum_value));\n        }\n\n        Schema {\n            schema_type: Some(SchemaType::String),\n            r#enum: if enum_values.is_empty() {\n                None\n            } else {\n                Some(enum_values)\n            },\n            ..Schema::string()\n        }\n    } else {\n        // Enum with data - use oneOf\n        let mut one_of_schemas = Vec::new();\n\n        for variant in \u0026enum_item.variants {\n            let variant_name = variant.ident.to_string();\n\n            // Check for variant-level rename attribute first (takes precedence)\n            let variant_key = if let Some(renamed) = extract_field_rename(\u0026variant.attrs) {\n                renamed\n            } else {\n                // Apply rename_all transformation if present\n                rename_field(\u0026variant_name, rename_all.as_deref())\n            };\n\n            let variant_schema = match \u0026variant.fields {\n                syn::Fields::Unit =\u003e {\n                    // Unit variant: {\"const\": \"VariantName\"}\n                    Schema {\n                        r#enum: Some(vec![serde_json::Value::String(variant_key)]),\n                        ..Schema::string()\n                    }\n                }\n                syn::Fields::Unnamed(fields_unnamed) =\u003e {\n                    // Tuple variant: {\"VariantName\": \u003cinner_type\u003e}\n                    // For single field: {\"VariantName\": \u003ctype\u003e}\n                    // For multiple fields: {\"VariantName\": [\u003ctype1\u003e, \u003ctype2\u003e, ...]}\n                    if fields_unnamed.unnamed.len() == 1 {\n                        // Single field tuple variant\n                        let inner_type = \u0026fields_unnamed.unnamed[0].ty;\n                        let inner_schema =\n                            parse_type_to_schema_ref(inner_type, known_schemas, struct_definitions);\n\n                        let mut properties = BTreeMap::new();\n                        properties.insert(variant_key.clone(), inner_schema);\n\n                        Schema {\n                            properties: Some(properties),\n                            required: Some(vec![variant_key]),\n                            ..Schema::object()\n                        }\n                    } else {\n                        // Multiple fields tuple variant - serialize as array\n                        // serde serializes tuple variants as: {\"VariantName\": [value1, value2, ...]}\n                        // For OpenAPI 3.1, we use prefixItems to represent tuple arrays\n                        let mut tuple_item_schemas = Vec::new();\n                        for field in \u0026fields_unnamed.unnamed {\n                            let field_schema = parse_type_to_schema_ref(\n                                \u0026field.ty,\n                                known_schemas,\n                                struct_definitions,\n                            );\n                            tuple_item_schemas.push(field_schema);\n                        }\n\n                        let tuple_len = tuple_item_schemas.len();\n\n                        // Create array schema with prefixItems for tuple arrays (OpenAPI 3.1)\n                        let array_schema = Schema {\n                            prefix_items: Some(tuple_item_schemas),\n                            min_items: Some(tuple_len),\n                            max_items: Some(tuple_len),\n                            items: None, // Do not use prefixItems and items together\n                            ..Schema::new(SchemaType::Array)\n                        };\n\n                        let mut properties = BTreeMap::new();\n                        properties.insert(\n                            variant_key.clone(),\n                            SchemaRef::Inline(Box::new(array_schema)),\n                        );\n\n                        Schema {\n                            properties: Some(properties),\n                            required: Some(vec![variant_key]),\n                            ..Schema::object()\n                        }\n                    }\n                }\n                syn::Fields::Named(fields_named) =\u003e {\n                    // Struct variant: {\"VariantName\": {field1: type1, field2: type2, ...}}\n                    let mut variant_properties = BTreeMap::new();\n                    let mut variant_required = Vec::new();\n                    let variant_rename_all = extract_rename_all(\u0026variant.attrs);\n\n                    for field in \u0026fields_named.named {\n                        let rust_field_name = field\n                            .ident\n                            .as_ref()\n                            .map(|i| i.to_string())\n                            .unwrap_or_else(|| \"unknown\".to_string());\n\n                        // Check for field-level rename attribute first (takes precedence)\n                        let field_name = if let Some(renamed) = extract_field_rename(\u0026field.attrs) {\n                            renamed\n                        } else {\n                            // Apply rename_all transformation if present\n                            rename_field(\n                                \u0026rust_field_name,\n                                variant_rename_all.as_deref().or(rename_all.as_deref()),\n                            )\n                        };\n\n                        let field_type = \u0026field.ty;\n                        let schema_ref =\n                            parse_type_to_schema_ref(field_type, known_schemas, struct_definitions);\n\n                        variant_properties.insert(field_name.clone(), schema_ref);\n\n                        // Check if field is Option\u003cT\u003e\n                        let is_optional = matches!(\n                            field_type,\n                            Type::Path(type_path)\n                                if type_path\n                                    .path\n                                    .segments\n                                    .first()\n                                    .map(|s| s.ident == \"Option\")\n                                    .unwrap_or(false)\n                        );\n\n                        if !is_optional {\n                            variant_required.push(field_name);\n                        }\n                    }\n\n                    // Wrap struct variant in an object with the variant name as key\n                    let inner_struct_schema = Schema {\n                        properties: if variant_properties.is_empty() {\n                            None\n                        } else {\n                            Some(variant_properties)\n                        },\n                        required: if variant_required.is_empty() {\n                            None\n                        } else {\n                            Some(variant_required)\n                        },\n                        ..Schema::object()\n                    };\n\n                    let mut properties = BTreeMap::new();\n                    properties.insert(\n                        variant_key.clone(),\n                        SchemaRef::Inline(Box::new(inner_struct_schema)),\n                    );\n\n                    Schema {\n                        properties: Some(properties),\n                        required: Some(vec![variant_key]),\n                        ..Schema::object()\n                    }\n                }\n            };\n\n            one_of_schemas.push(SchemaRef::Inline(Box::new(variant_schema)));\n        }\n\n        Schema {\n            schema_type: None, // oneOf doesn't have a single type\n            one_of: if one_of_schemas.is_empty() {\n                None\n            } else {\n                Some(one_of_schemas)\n            },\n            ..Schema::new(SchemaType::Object)\n        }\n    }\n}\n\npub fn parse_struct_to_schema(\n    struct_item: \u0026syn::ItemStruct,\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Schema {\n    let mut properties = BTreeMap::new();\n    let mut required = Vec::new();\n\n    // Extract rename_all attribute from struct\n    let rename_all = extract_rename_all(\u0026struct_item.attrs);\n\n    match \u0026struct_item.fields {\n        Fields::Named(fields_named) =\u003e {\n            for field in \u0026fields_named.named {\n                // Check if field should be skipped\n                if extract_skip(\u0026field.attrs) {\n                    continue;\n                }\n\n                let rust_field_name = field\n                    .ident\n                    .as_ref()\n                    .map(|i| i.to_string())\n                    .unwrap_or_else(|| \"unknown\".to_string());\n\n                // Check for field-level rename attribute first (takes precedence)\n                let field_name = if let Some(renamed) = extract_field_rename(\u0026field.attrs) {\n                    renamed\n                } else {\n                    // Apply rename_all transformation if present\n                    rename_field(\u0026rust_field_name, rename_all.as_deref())\n                };\n\n                let field_type = \u0026field.ty;\n\n                let mut schema_ref =\n                    parse_type_to_schema_ref(field_type, known_schemas, struct_definitions);\n\n                // Check for default attribute\n                let has_default = extract_default(\u0026field.attrs).is_some();\n\n                // Check for skip_serializing_if attribute\n                let has_skip_serializing_if = extract_skip_serializing_if(\u0026field.attrs);\n\n                // If default or skip_serializing_if is present, mark field as optional (not required)\n                // and set default value if it's a simple default (not a function)\n                if has_default || has_skip_serializing_if {\n                    // For default = \"function_name\", we'll handle it in openapi_generator\n                    // For now, just mark as optional\n                    if let SchemaRef::Inline(ref mut _schema) = schema_ref {\n                        // Default will be set later in openapi_generator if it's a function\n                        // For simple default, we could set it here, but serde handles it\n                    }\n                } else {\n                    // Check if field is Option\u003cT\u003e\n                    let is_optional = matches!(\n                        field_type,\n                        Type::Path(type_path)\n                            if type_path\n                                .path\n                                .segments\n                                .first()\n                                .map(|s| s.ident == \"Option\")\n                                .unwrap_or(false)\n                    );\n\n                    if !is_optional {\n                        required.push(field_name.clone());\n                    }\n                }\n\n                properties.insert(field_name, schema_ref);\n            }\n        }\n        Fields::Unnamed(_) =\u003e {\n            // Tuple structs are not supported for now\n        }\n        Fields::Unit =\u003e {\n            // Unit structs have no fields\n        }\n    }\n\n    Schema {\n        schema_type: Some(SchemaType::Object),\n        properties: if properties.is_empty() {\n            None\n        } else {\n            Some(properties)\n        },\n        required: if required.is_empty() {\n            None\n        } else {\n            Some(required)\n        },\n        ..Schema::object()\n    }\n}\n\nfn substitute_type(ty: \u0026Type, generic_params: \u0026[String], concrete_types: \u0026[\u0026Type]) -\u003e Type {\n    // Check if this is a generic parameter\n    if let Type::Path(type_path) = ty\n        \u0026\u0026 let Some(segment) = type_path.path.segments.last()\n    {\n        let ident_str = segment.ident.to_string();\n        if generic_params.contains(\u0026ident_str) \u0026\u0026 segment.arguments.is_none() {\n            // Find the index and substitute\n            if let Some(index) = generic_params.iter().position(|p| p == \u0026ident_str)\n                \u0026\u0026 let Some(concrete_ty) = concrete_types.get(index)\n            {\n                return (*concrete_ty).clone();\n            }\n        }\n    }\n\n    // For complex types, use quote! to regenerate with substitutions\n    let tokens = quote::quote! { #ty };\n    let mut new_tokens = tokens.to_string();\n\n    // Replace generic parameter names with concrete types\n    for (param, concrete_ty) in generic_params.iter().zip(concrete_types.iter()) {\n        // Replace standalone generic parameter (not part of another identifier)\n        let pattern = format!(r\"\\b{}\\b\", param);\n        let replacement = quote::quote! { #concrete_ty }.to_string();\n        new_tokens = new_tokens.replace(\u0026pattern, \u0026replacement);\n    }\n\n    // Parse the substituted type\n    syn::parse_str::\u003cType\u003e(\u0026new_tokens).unwrap_or_else(|_| ty.clone())\n}\n\npub(super) fn is_primitive_type(ty: \u0026Type) -\u003e bool {\n    match ty {\n        Type::Path(type_path) =\u003e {\n            let path = \u0026type_path.path;\n            if path.segments.len() == 1 {\n                let ident = path.segments[0].ident.to_string();\n                matches!(\n                    ident.as_str(),\n                    \"i8\" | \"i16\"\n                        | \"i32\"\n                        | \"i64\"\n                        | \"u8\"\n                        | \"u16\"\n                        | \"u32\"\n                        | \"u64\"\n                        | \"f32\"\n                        | \"f64\"\n                        | \"bool\"\n                        | \"String\"\n                        | \"str\"\n                )\n            } else {\n                false\n            }\n        }\n        _ =\u003e false,\n    }\n}\n\npub fn parse_type_to_schema_ref(\n    ty: \u0026Type,\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\n) -\u003e SchemaRef {\n    parse_type_to_schema_ref_with_schemas(ty, known_schemas, struct_definitions)\n}\n\npub(super) fn parse_type_to_schema_ref_with_schemas(\n    ty: \u0026Type,\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\n) -\u003e SchemaRef {\n    match ty {\n        Type::Path(type_path) =\u003e {\n            let path = \u0026type_path.path;\n            if path.segments.is_empty() {\n                return SchemaRef::Inline(Box::new(Schema::new(SchemaType::Object)));\n            }\n\n            // Get the last segment as the type name (handles paths like crate::TestStruct)\n            let segment = path.segments.last().unwrap();\n            let ident_str = segment.ident.to_string();\n\n            // Handle generic types\n            if let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments {\n                match ident_str.as_str() {\n                    \"Vec\" | \"Option\" =\u003e {\n                        if let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first() {\n                            let inner_schema = parse_type_to_schema_ref(\n                                inner_ty,\n                                known_schemas,\n                                struct_definitions,\n                            );\n                            if ident_str == \"Vec\" {\n                                return SchemaRef::Inline(Box::new(Schema::array(inner_schema)));\n                            } else {\n                                // Option\u003cT\u003e -\u003e nullable schema\n                                match inner_schema {\n                                    SchemaRef::Inline(mut schema) =\u003e {\n                                        schema.nullable = Some(true);\n                                        return SchemaRef::Inline(schema);\n                                    }\n                                    SchemaRef::Ref(reference) =\u003e {\n                                        // Wrap reference in an inline schema to attach nullable flag\n                                        return SchemaRef::Inline(Box::new(Schema {\n                                            ref_path: Some(reference.ref_path),\n                                            schema_type: None,\n                                            nullable: Some(true),\n                                            ..Schema::new(SchemaType::Object)\n                                        }));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    \"HashMap\" | \"BTreeMap\" =\u003e {\n                        // HashMap\u003cK, V\u003e or BTreeMap\u003cK, V\u003e -\u003e object with additionalProperties\n                        // K is typically String, we use V as the value type\n                        if args.args.len() \u003e= 2\n                            \u0026\u0026 let (\n                                Some(syn::GenericArgument::Type(_key_ty)),\n                                Some(syn::GenericArgument::Type(value_ty)),\n                            ) = (args.args.get(0), args.args.get(1))\n                        {\n                            let value_schema = parse_type_to_schema_ref(\n                                value_ty,\n                                known_schemas,\n                                struct_definitions,\n                            );\n                            // Convert SchemaRef to serde_json::Value for additional_properties\n                            let additional_props_value = match value_schema {\n                                SchemaRef::Ref(ref_ref) =\u003e {\n                                    serde_json::json!({ \"$ref\": ref_ref.ref_path })\n                                }\n                                SchemaRef::Inline(schema) =\u003e {\n                                    serde_json::to_value(\u0026*schema).unwrap_or(serde_json::json!({}))\n                                }\n                            };\n                            return SchemaRef::Inline(Box::new(Schema {\n                                schema_type: Some(SchemaType::Object),\n                                additional_properties: Some(additional_props_value),\n                                ..Schema::object()\n                            }));\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n\n            // Handle primitive types\n            match ident_str.as_str() {\n                \"i8\" | \"i16\" | \"i32\" | \"i64\" | \"u8\" | \"u16\" | \"u32\" | \"u64\" =\u003e {\n                    SchemaRef::Inline(Box::new(Schema::integer()))\n                }\n                \"f32\" | \"f64\" =\u003e SchemaRef::Inline(Box::new(Schema::number())),\n                \"bool\" =\u003e SchemaRef::Inline(Box::new(Schema::boolean())),\n                \"String\" | \"str\" =\u003e SchemaRef::Inline(Box::new(Schema::string())),\n                // Standard library types that should not be referenced\n                // Note: HashMap and BTreeMap are handled above in generic types\n                \"Vec\" | \"Option\" | \"Result\" | \"Json\" | \"Path\" | \"Query\" | \"Header\" =\u003e {\n                    // These are not schema types, return object schema\n                    SchemaRef::Inline(Box::new(Schema::new(SchemaType::Object)))\n                }\n                _ =\u003e {\n                    // Check if this is a known schema (struct with Schema derive)\n                    // Try both the full path and just the type name\n                    let type_name = if path.segments.len() \u003e 1 {\n                        // For paths like crate::TestStruct, use just the type name\n                        ident_str.clone()\n                    } else {\n                        ident_str.clone()\n                    };\n\n                    if known_schemas.contains_key(\u0026type_name) {\n                        // Check if this is a generic type with type parameters\n                        if let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments {\n                            // This is a concrete generic type like GenericStruct\u003cString\u003e\n                            // Inline the schema by substituting generic parameters with concrete types\n                            if let Some(base_def) = struct_definitions.get(\u0026type_name)\n                                \u0026\u0026 let Ok(mut parsed) = syn::parse_str::\u003csyn::ItemStruct\u003e(base_def)\n                            {\n                                // Extract generic parameter names from the struct definition\n                                let generic_params: Vec\u003cString\u003e = parsed\n                                    .generics\n                                    .params\n                                    .iter()\n                                    .filter_map(|param| {\n                                        if let syn::GenericParam::Type(type_param) = param {\n                                            Some(type_param.ident.to_string())\n                                        } else {\n                                            None\n                                        }\n                                    })\n                                    .collect();\n\n                                // Extract concrete type arguments\n                                let concrete_types: Vec\u003c\u0026Type\u003e = args\n                                    .args\n                                    .iter()\n                                    .filter_map(|arg| {\n                                        if let syn::GenericArgument::Type(ty) = arg {\n                                            Some(ty)\n                                        } else {\n                                            None\n                                        }\n                                    })\n                                    .collect();\n\n                                // Substitute generic parameters with concrete types in all fields\n                                if generic_params.len() == concrete_types.len() {\n                                    if let syn::Fields::Named(fields_named) = \u0026mut parsed.fields {\n                                        for field in \u0026mut fields_named.named {\n                                            field.ty = substitute_type(\n                                                \u0026field.ty,\n                                                \u0026generic_params,\n                                                \u0026concrete_types,\n                                            );\n                                        }\n                                    }\n\n                                    // Remove generics from the struct (it's now concrete)\n                                    parsed.generics.params.clear();\n                                    parsed.generics.where_clause = None;\n\n                                    // Parse the substituted struct to schema (inline)\n                                    let schema = parse_struct_to_schema(\n                                        \u0026parsed,\n                                        known_schemas,\n                                        struct_definitions,\n                                    );\n                                    return SchemaRef::Inline(Box::new(schema));\n                                }\n                            }\n                        }\n                        // Non-generic type or generic without parameters - use reference\n                        SchemaRef::Ref(Reference::schema(\u0026type_name))\n                    } else {\n                        // For unknown custom types, return object schema instead of reference\n                        // This prevents creating invalid references to non-existent schemas\n                        SchemaRef::Inline(Box::new(Schema::new(SchemaType::Object)))\n                    }\n                }\n            }\n        }\n        Type::Reference(type_ref) =\u003e {\n            // Handle \u0026T, \u0026mut T, etc.\n            parse_type_to_schema_ref_with_schemas(\u0026type_ref.elem, known_schemas, struct_definitions)\n        }\n        _ =\u003e SchemaRef::Inline(Box::new(Schema::new(SchemaType::Object))),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use insta::{assert_debug_snapshot, with_settings};\n    use rstest::rstest;\n    use std::collections::HashMap;\n    use vespera_core::schema::{SchemaRef, SchemaType};\n\n    #[rstest]\n    #[case(\"HashMap\u003cString, i32\u003e\", Some(SchemaType::Object), true)]\n    #[case(\"Option\u003cString\u003e\", Some(SchemaType::String), false)] // nullable check\n    fn test_parse_type_to_schema_ref_cases(\n        #[case] ty_src: \u0026str,\n        #[case] expected_type: Option\u003cSchemaType\u003e,\n        #[case] expect_additional_props: bool,\n    ) {\n        let ty: syn::Type = syn::parse_str(ty_src).unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026HashMap::new(), \u0026HashMap::new());\n        if let SchemaRef::Inline(schema) = schema_ref {\n            assert_eq!(schema.schema_type, expected_type);\n            if expect_additional_props {\n                assert!(schema.additional_properties.is_some());\n            }\n            if ty_src.starts_with(\"Option\") {\n                assert_eq!(schema.nullable, Some(true));\n            }\n        } else {\n            panic!(\"Expected inline schema for {}\", ty_src);\n        }\n    }\n\n    #[test]\n    fn test_parse_type_to_schema_ref_option_ref_nullable() {\n        let mut known = HashMap::new();\n        known.insert(\"User\".to_string(), \"struct User;\".to_string());\n\n        let ty: syn::Type = syn::parse_str(\"Option\u003cUser\u003e\").unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026known, \u0026HashMap::new());\n\n        match schema_ref {\n            SchemaRef::Inline(schema) =\u003e {\n                assert_eq!(\n                    schema.ref_path,\n                    Some(\"#/components/schemas/User\".to_string())\n                );\n                assert_eq!(schema.nullable, Some(true));\n                assert_eq!(schema.schema_type, None);\n            }\n            _ =\u003e panic!(\"Expected inline schema for Option\u003cUser\u003e\"),\n        }\n    }\n\n    #[rstest]\n    #[case(\n        r#\"\n        #[serde(rename_all = \"kebab-case\")]\n        enum Status {\n            #[serde(rename = \"ok-status\")]\n            Ok,\n            ErrorCode,\n        }\n        \"#,\n        SchemaType::String,\n        vec![\"ok-status\", \"error-code\"], // rename_all is not applied in this path\n        \"status\"\n    )]\n    #[case(\n        r#\"\n        enum Simple {\n            First,\n            Second,\n        }\n        \"#,\n        SchemaType::String,\n        vec![\"First\", \"Second\"],\n        \"simple\"\n    )]\n    #[case(\n        r#\"\n        #[serde(rename_all = \"snake_case\")]\n        enum Simple {\n            FirstItem,\n            SecondItem,\n        }\n        \"#,\n        SchemaType::String,\n        vec![\"first_item\", \"second_item\"],\n        \"simple_snake\"\n    )]\n    fn test_parse_enum_to_schema_unit_variants(\n        #[case] enum_src: \u0026str,\n        #[case] expected_type: SchemaType,\n        #[case] expected_enum: Vec\u003c\u0026str\u003e,\n        #[case] suffix: \u0026str,\n    ) {\n        let enum_item: syn::ItemEnum = syn::parse_str(enum_src).unwrap();\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        assert_eq!(schema.schema_type, Some(expected_type));\n        let got = schema\n            .clone()\n            .r#enum\n            .unwrap()\n            .iter()\n            .map(|v| v.as_str().unwrap().to_string())\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        assert_eq!(got, expected_enum);\n        with_settings!({ snapshot_suffix =\u003e format!(\"unit_{}\", suffix) }, {\n            assert_debug_snapshot!(schema);\n        });\n    }\n\n    #[rstest]\n    #[case(\n        r#\"\n        enum Event {\n            Data(String),\n        }\n        \"#,\n        1,\n        Some(SchemaType::String),\n        0, // single-field tuple variant stored as object with inline schema\n        \"tuple_single\"\n    )]\n    #[case(\n        r#\"\n        enum Pair {\n            Values(i32, String),\n        }\n        \"#,\n        1,\n        Some(SchemaType::Array),\n        2, // tuple array prefix_items length\n        \"tuple_multi\"\n    )]\n    #[case(\n        r#\"\n        enum Msg {\n            Detail { id: i32, note: Option\u003cString\u003e },\n        }\n        \"#,\n        1,\n        Some(SchemaType::Object),\n        0, // not an array; ignore prefix_items length\n        \"named_object\"\n    )]\n    fn test_parse_enum_to_schema_tuple_and_named_variants(\n        #[case] enum_src: \u0026str,\n        #[case] expected_one_of_len: usize,\n        #[case] expected_inner_type: Option\u003cSchemaType\u003e,\n        #[case] expected_prefix_items_len: usize,\n        #[case] suffix: \u0026str,\n    ) {\n        let enum_item: syn::ItemEnum = syn::parse_str(enum_src).unwrap();\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.clone().one_of.expect(\"one_of missing\");\n        assert_eq!(one_of.len(), expected_one_of_len);\n\n        if let Some(inner_expected) = expected_inner_type.clone() {\n            if let SchemaRef::Inline(obj) = \u0026one_of[0] {\n                let props = obj.properties.as_ref().expect(\"props missing\");\n                // take first property value\n                let inner_schema = props.values().next().expect(\"no property value\");\n                match inner_expected {\n                    SchemaType::Array =\u003e {\n                        if let SchemaRef::Inline(array_schema) = inner_schema {\n                            assert_eq!(array_schema.schema_type, Some(SchemaType::Array));\n                            if expected_prefix_items_len \u003e 0 {\n                                assert_eq!(\n                                    array_schema.prefix_items.as_ref().unwrap().len(),\n                                    expected_prefix_items_len\n                                );\n                            }\n                        } else {\n                            panic!(\"Expected inline array schema\");\n                        }\n                    }\n                    SchemaType::Object =\u003e {\n                        if let SchemaRef::Inline(inner_obj) = inner_schema {\n                            assert_eq!(inner_obj.schema_type, Some(SchemaType::Object));\n                            let inner_props = inner_obj.properties.as_ref().unwrap();\n                            assert!(inner_props.contains_key(\"id\"));\n                            assert!(inner_props.contains_key(\"note\"));\n                            assert!(\n                                inner_obj\n                                    .required\n                                    .as_ref()\n                                    .unwrap()\n                                    .contains(\u0026\"id\".to_string())\n                            );\n                        } else {\n                            panic!(\"Expected inline object schema\");\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            } else {\n                panic!(\"Expected inline schema in one_of\");\n            }\n        }\n\n        with_settings!({ snapshot_suffix =\u003e format!(\"tuple_named_{}\", suffix) }, {\n            assert_debug_snapshot!(schema);\n        });\n    }\n\n    #[rstest]\n    #[case(\n        r#\"\n        enum Mixed {\n            Ready,\n            Data(String),\n        }\n        \"#,\n        2,\n        SchemaType::String,\n        \"Ready\"\n    )]\n    fn test_parse_enum_to_schema_mixed_unit_variant(\n        #[case] enum_src: \u0026str,\n        #[case] expected_one_of_len: usize,\n        #[case] expected_unit_type: SchemaType,\n        #[case] expected_unit_value: \u0026str,\n    ) {\n        let enum_item: syn::ItemEnum = syn::parse_str(enum_src).unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.one_of.expect(\"one_of missing for mixed enum\");\n        assert_eq!(one_of.len(), expected_one_of_len);\n\n        let unit_schema = match \u0026one_of[0] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema for unit variant\"),\n        };\n        assert_eq!(unit_schema.schema_type, Some(expected_unit_type));\n        let unit_enum = unit_schema.r#enum.as_ref().expect(\"enum values missing\");\n        assert_eq!(unit_enum[0].as_str().unwrap(), expected_unit_value);\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_rename_all_for_data_variant() {\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"kebab-case\")]\n            enum Payload {\n                DataItem(String),\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.one_of.expect(\"one_of missing\");\n        let variant_obj = match \u0026one_of[0] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema\"),\n        };\n        let props = variant_obj\n            .properties\n            .as_ref()\n            .expect(\"variant props missing\");\n        assert!(props.contains_key(\"data-item\"));\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_field_uses_enum_rename_all() {\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"snake_case\")]\n            enum Event {\n                Detail { UserId: i32 },\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.one_of.expect(\"one_of missing\");\n        let variant_obj = match \u0026one_of[0] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema\"),\n        };\n        let props = variant_obj\n            .properties\n            .as_ref()\n            .expect(\"variant props missing\");\n        let inner = match props.get(\"detail\").expect(\"variant key missing\") {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline inner schema\"),\n        };\n        let inner_props = inner.properties.as_ref().expect(\"inner props missing\");\n        assert!(inner_props.contains_key(\"user_id\"));\n        assert!(!inner_props.contains_key(\"UserId\"));\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_variant_rename_overrides_rename_all() {\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"snake_case\")]\n            enum Payload {\n                #[serde(rename = \"Explicit\")]\n                DataItem(i32),\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.one_of.expect(\"one_of missing\");\n        let variant_obj = match \u0026one_of[0] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema\"),\n        };\n        let props = variant_obj\n            .properties\n            .as_ref()\n            .expect(\"variant props missing\");\n        assert!(props.contains_key(\"Explicit\"));\n        assert!(!props.contains_key(\"data_item\"));\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_field_rename_overrides_variant_rename_all() {\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"snake_case\")]\n            enum Payload {\n                #[serde(rename_all = \"kebab-case\")]\n                Detail { #[serde(rename = \"ID\")] user_id: i32 },\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.one_of.expect(\"one_of missing\");\n        let variant_obj = match \u0026one_of[0] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema\"),\n        };\n        let props = variant_obj\n            .properties\n            .as_ref()\n            .expect(\"variant props missing\");\n        let inner = match props\n            .get(\"detail\")\n            .or_else(|| props.get(\"Detail\"))\n            .expect(\"variant key missing\")\n        {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline inner schema\"),\n        };\n        let inner_props = inner.properties.as_ref().expect(\"inner props missing\");\n        assert!(inner_props.contains_key(\"ID\")); // field-level rename wins\n        assert!(!inner_props.contains_key(\"user-id\")); // variant rename_all ignored for this field\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_rename_all_with_other_attrs_unit() {\n        // Test rename_all combined with other serde attributes for unit variants\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"kebab-case\", default)]\n            enum Status {\n                ActiveUser,\n                InactiveUser,\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let enum_values = schema.r#enum.expect(\"enum values missing\");\n        assert_eq!(enum_values[0].as_str().unwrap(), \"active-user\");\n        assert_eq!(enum_values[1].as_str().unwrap(), \"inactive-user\");\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_rename_all_with_other_attrs_data() {\n        // Test rename_all combined with other serde attributes for data variants\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"camelCase\", deny_unknown_fields)]\n            enum Event {\n                UserCreated { user_name: String, created_at: i64 },\n                UserDeleted(i32),\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.one_of.expect(\"one_of missing\");\n\n        // Check UserCreated variant key is camelCase\n        let variant_obj = match \u0026one_of[0] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema\"),\n        };\n        let props = variant_obj\n            .properties\n            .as_ref()\n            .expect(\"variant props missing\");\n        assert!(props.contains_key(\"userCreated\"));\n        assert!(!props.contains_key(\"UserCreated\"));\n        assert!(!props.contains_key(\"user_created\"));\n\n        // Check UserDeleted variant key is camelCase\n        let variant_obj2 = match \u0026one_of[1] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema\"),\n        };\n        let props2 = variant_obj2\n            .properties\n            .as_ref()\n            .expect(\"variant props missing\");\n        assert!(props2.contains_key(\"userDeleted\"));\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_rename_all_not_first_attr() {\n        // Test rename_all when it's not the first attribute\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(default, rename_all = \"SCREAMING_SNAKE_CASE\")]\n            enum Priority {\n                HighPriority,\n                LowPriority,\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let enum_values = schema.r#enum.expect(\"enum values missing\");\n        assert_eq!(enum_values[0].as_str().unwrap(), \"HIGH_PRIORITY\");\n        assert_eq!(enum_values[1].as_str().unwrap(), \"LOW_PRIORITY\");\n    }\n\n    #[test]\n    fn test_parse_struct_to_schema_required_optional() {\n        let struct_item: syn::ItemStruct = syn::parse_str(\n            r#\"\n            struct User {\n                id: i32,\n                name: Option\u003cString\u003e,\n            }\n        \"#,\n        )\n        .unwrap();\n        let schema = parse_struct_to_schema(\u0026struct_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let props = schema.properties.as_ref().unwrap();\n        assert!(props.contains_key(\"id\"));\n        assert!(props.contains_key(\"name\"));\n        assert!(\n            schema\n                .required\n                .as_ref()\n                .unwrap()\n                .contains(\u0026\"id\".to_string())\n        );\n        assert!(\n            !schema\n                .required\n                .as_ref()\n                .unwrap()\n                .contains(\u0026\"name\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_parse_struct_to_schema_rename_all_and_field_rename() {\n        let struct_item: syn::ItemStruct = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"camelCase\")]\n            struct Profile {\n                #[serde(rename = \"id\")]\n                user_id: i32,\n                display_name: Option\u003cString\u003e,\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_struct_to_schema(\u0026struct_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let props = schema.properties.as_ref().expect(\"props missing\");\n        assert!(props.contains_key(\"id\")); // field-level rename wins\n        assert!(props.contains_key(\"displayName\")); // rename_all applied\n        let required = schema.required.as_ref().expect(\"required missing\");\n        assert!(required.contains(\u0026\"id\".to_string()));\n        assert!(!required.contains(\u0026\"displayName\".to_string())); // Option makes it optional\n    }\n\n    #[rstest]\n    #[case(\"struct Wrapper(i32);\")]\n    #[case(\"struct Empty;\")]\n    fn test_parse_struct_to_schema_tuple_and_unit_structs(#[case] struct_src: \u0026str) {\n        let struct_item: syn::ItemStruct = syn::parse_str(struct_src).unwrap();\n        let schema = parse_struct_to_schema(\u0026struct_item, \u0026HashMap::new(), \u0026HashMap::new());\n        assert!(schema.properties.is_none());\n        assert!(schema.required.is_none());\n    }\n\n    #[test]\n    fn test_parse_type_to_schema_ref_empty_path_and_reference() {\n        // Empty path segments returns object\n        let ty = Type::Path(syn::TypePath {\n            qself: None,\n            path: syn::Path {\n                leading_colon: None,\n                segments: syn::punctuated::Punctuated::new(),\n            },\n        });\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026HashMap::new(), \u0026HashMap::new());\n        assert!(matches!(schema_ref, SchemaRef::Inline(_)));\n\n        // Reference type delegates to inner\n        let ty: Type = syn::parse_str(\"\u0026i32\").unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026HashMap::new(), \u0026HashMap::new());\n        if let SchemaRef::Inline(schema) = schema_ref {\n            assert_eq!(schema.schema_type, Some(SchemaType::Integer));\n        } else {\n            panic!(\"Expected inline integer schema\");\n        }\n    }\n\n    #[test]\n    fn test_parse_type_to_schema_ref_known_schema_ref_and_unknown_custom() {\n        let mut known_schemas = HashMap::new();\n        known_schemas.insert(\"Known\".to_string(), \"Known\".to_string());\n\n        let ty: Type = syn::parse_str(\"Known\").unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026known_schemas, \u0026HashMap::new());\n        assert!(matches!(schema_ref, SchemaRef::Ref(_)));\n\n        let ty: Type = syn::parse_str(\"UnknownType\").unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026known_schemas, \u0026HashMap::new());\n        assert!(matches!(schema_ref, SchemaRef::Inline(_)));\n    }\n\n    #[test]\n    fn test_parse_type_to_schema_ref_generic_substitution() {\n        // Ensure generic struct Wrapper\u003cT\u003e { value: T } is substituted to concrete type\n        let mut known_schemas = HashMap::new();\n        known_schemas.insert(\"Wrapper\".to_string(), \"Wrapper\".to_string());\n\n        let mut struct_definitions = HashMap::new();\n        struct_definitions.insert(\n            \"Wrapper\".to_string(),\n            \"struct Wrapper\u003cT\u003e { value: T }\".to_string(),\n        );\n\n        let ty: syn::Type = syn::parse_str(\"Wrapper\u003cString\u003e\").unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026known_schemas, \u0026struct_definitions);\n\n        if let SchemaRef::Inline(schema) = schema_ref {\n            let props = schema.properties.as_ref().unwrap();\n            let value = props.get(\"value\").unwrap();\n            if let SchemaRef::Inline(inner) = value {\n                assert_eq!(inner.schema_type, Some(SchemaType::String));\n            } else {\n                panic!(\"Expected inline schema for value\");\n            }\n        } else {\n            panic!(\"Expected inline schema for generic substitution\");\n        }\n    }\n\n    #[rstest]\n    #[case(\"$invalid\", \"String\")]\n    fn test_substitute_type_parse_failure_uses_original(\n        #[case] invalid: \u0026str,\n        #[case] concrete_src: \u0026str,\n    ) {\n        use proc_macro2::TokenStream;\n        use std::str::FromStr;\n\n        let ty = Type::Verbatim(TokenStream::from_str(invalid).unwrap());\n        let concrete: Type = syn::parse_str(concrete_src).unwrap();\n        let substituted = substitute_type(\u0026ty, \u0026[String::from(\"T\")], \u0026[\u0026concrete]);\n        assert_eq!(substituted, ty);\n    }\n\n    #[rstest]\n    #[case(\"\u0026i32\")]\n    #[case(\"std::string::String\")]\n    fn test_is_primitive_type_non_path_variants(#[case] ty_src: \u0026str) {\n        let ty: Type = syn::parse_str(ty_src).unwrap();\n        assert!(!is_primitive_type(\u0026ty));\n    }\n\n    #[rstest]\n    #[case(\n        \"HashMap\u003cString, Value\u003e\",\n        true,\n        None,\n        Some(\"#/components/schemas/Value\")\n    )]\n    #[case(\"Result\u003cString, i32\u003e\", false, Some(SchemaType::Object), None)]\n    #[case(\"crate::Value\", false, None, None)]\n    #[case(\"(i32, bool)\", false, Some(SchemaType::Object), None)]\n    fn test_parse_type_to_schema_ref_additional_cases(\n        #[case] ty_src: \u0026str,\n        #[case] expect_additional_props: bool,\n        #[case] expected_type: Option\u003cSchemaType\u003e,\n        #[case] expected_ref: Option\u003c\u0026str\u003e,\n    ) {\n        let mut known_schemas = HashMap::new();\n        known_schemas.insert(\"Value\".to_string(), \"Value\".to_string());\n\n        let ty: Type = syn::parse_str(ty_src).unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026known_schemas, \u0026HashMap::new());\n        match expected_ref {\n            Some(expected) =\u003e {\n                let SchemaRef::Inline(schema) = schema_ref else {\n                    panic!(\"Expected inline schema for {}\", ty_src);\n                };\n                let additional = schema\n                    .additional_properties\n                    .as_ref()\n                    .expect(\"additional_properties missing\");\n                assert_eq!(additional.get(\"$ref\").unwrap(), expected);\n            }\n            None =\u003e match schema_ref {\n                SchemaRef::Inline(schema) =\u003e {\n                    if expect_additional_props {\n                        assert!(schema.additional_properties.is_some());\n                    } else {\n                        assert_eq!(schema.schema_type, expected_type);\n                    }\n                }\n                SchemaRef::Ref(_) =\u003e {\n                    assert!(ty_src.contains(\"Value\"));\n                }\n            },\n        }\n    }\n\n    #[rstest]\n    // camelCase tests (snake_case input)\n    #[case(\"user_name\", Some(\"camelCase\"), \"userName\")]\n    #[case(\"first_name\", Some(\"camelCase\"), \"firstName\")]\n    #[case(\"last_name\", Some(\"camelCase\"), \"lastName\")]\n    #[case(\"user_id\", Some(\"camelCase\"), \"userId\")]\n    #[case(\"api_key\", Some(\"camelCase\"), \"apiKey\")]\n    #[case(\"already_camel\", Some(\"camelCase\"), \"alreadyCamel\")]\n    // camelCase tests (PascalCase input)\n    #[case(\"UserName\", Some(\"camelCase\"), \"userName\")]\n    #[case(\"UserCreated\", Some(\"camelCase\"), \"userCreated\")]\n    #[case(\"FirstName\", Some(\"camelCase\"), \"firstName\")]\n    #[case(\"ID\", Some(\"camelCase\"), \"id\")]\n    #[case(\"XMLParser\", Some(\"camelCase\"), \"xmlParser\")]\n    #[case(\"HTTPSConnection\", Some(\"camelCase\"), \"httpsConnection\")]\n    // snake_case tests\n    #[case(\"userName\", Some(\"snake_case\"), \"user_name\")]\n    #[case(\"firstName\", Some(\"snake_case\"), \"first_name\")]\n    #[case(\"lastName\", Some(\"snake_case\"), \"last_name\")]\n    #[case(\"userId\", Some(\"snake_case\"), \"user_id\")]\n    #[case(\"apiKey\", Some(\"snake_case\"), \"api_key\")]\n    #[case(\"already_snake\", Some(\"snake_case\"), \"already_snake\")]\n    // kebab-case tests\n    #[case(\"user_name\", Some(\"kebab-case\"), \"user-name\")]\n    #[case(\"first_name\", Some(\"kebab-case\"), \"first-name\")]\n    #[case(\"last_name\", Some(\"kebab-case\"), \"last-name\")]\n    #[case(\"user_id\", Some(\"kebab-case\"), \"user-id\")]\n    #[case(\"api_key\", Some(\"kebab-case\"), \"api-key\")]\n    #[case(\"already-kebab\", Some(\"kebab-case\"), \"already-kebab\")]\n    // PascalCase tests\n    #[case(\"user_name\", Some(\"PascalCase\"), \"UserName\")]\n    #[case(\"first_name\", Some(\"PascalCase\"), \"FirstName\")]\n    #[case(\"last_name\", Some(\"PascalCase\"), \"LastName\")]\n    #[case(\"user_id\", Some(\"PascalCase\"), \"UserId\")]\n    #[case(\"api_key\", Some(\"PascalCase\"), \"ApiKey\")]\n    #[case(\"AlreadyPascal\", Some(\"PascalCase\"), \"AlreadyPascal\")]\n    // lowercase tests\n    #[case(\"UserName\", Some(\"lowercase\"), \"username\")]\n    #[case(\"FIRST_NAME\", Some(\"lowercase\"), \"first_name\")]\n    #[case(\"lastName\", Some(\"lowercase\"), \"lastname\")]\n    #[case(\"User_ID\", Some(\"lowercase\"), \"user_id\")]\n    #[case(\"API_KEY\", Some(\"lowercase\"), \"api_key\")]\n    #[case(\"already_lower\", Some(\"lowercase\"), \"already_lower\")]\n    // UPPERCASE tests\n    #[case(\"user_name\", Some(\"UPPERCASE\"), \"USER_NAME\")]\n    #[case(\"firstName\", Some(\"UPPERCASE\"), \"FIRSTNAME\")]\n    #[case(\"LastName\", Some(\"UPPERCASE\"), \"LASTNAME\")]\n    #[case(\"user_id\", Some(\"UPPERCASE\"), \"USER_ID\")]\n    #[case(\"apiKey\", Some(\"UPPERCASE\"), \"APIKEY\")]\n    #[case(\"ALREADY_UPPER\", Some(\"UPPERCASE\"), \"ALREADY_UPPER\")]\n    // SCREAMING_SNAKE_CASE tests\n    #[case(\"user_name\", Some(\"SCREAMING_SNAKE_CASE\"), \"USER_NAME\")]\n    #[case(\"firstName\", Some(\"SCREAMING_SNAKE_CASE\"), \"FIRST_NAME\")]\n    #[case(\"LastName\", Some(\"SCREAMING_SNAKE_CASE\"), \"LAST_NAME\")]\n    #[case(\"user_id\", Some(\"SCREAMING_SNAKE_CASE\"), \"USER_ID\")]\n    #[case(\"apiKey\", Some(\"SCREAMING_SNAKE_CASE\"), \"API_KEY\")]\n    #[case(\"ALREADY_SCREAMING\", Some(\"SCREAMING_SNAKE_CASE\"), \"ALREADY_SCREAMING\")]\n    // SCREAMING-KEBAB-CASE tests\n    #[case(\"user_name\", Some(\"SCREAMING-KEBAB-CASE\"), \"USER-NAME\")]\n    #[case(\"firstName\", Some(\"SCREAMING-KEBAB-CASE\"), \"FIRST-NAME\")]\n    #[case(\"LastName\", Some(\"SCREAMING-KEBAB-CASE\"), \"LAST-NAME\")]\n    #[case(\"user_id\", Some(\"SCREAMING-KEBAB-CASE\"), \"USER-ID\")]\n    #[case(\"apiKey\", Some(\"SCREAMING-KEBAB-CASE\"), \"API-KEY\")]\n    #[case(\"already-kebab\", Some(\"SCREAMING-KEBAB-CASE\"), \"ALREADY-KEBAB\")]\n    // None tests (no transformation)\n    #[case(\"user_name\", None, \"user_name\")]\n    #[case(\"firstName\", None, \"firstName\")]\n    #[case(\"LastName\", None, \"LastName\")]\n    #[case(\"user-id\", None, \"user-id\")]\n    fn test_rename_field(\n        #[case] field_name: \u0026str,\n        #[case] rename_all: Option\u003c\u0026str\u003e,\n        #[case] expected: \u0026str,\n    ) {\n        assert_eq!(rename_field(field_name, rename_all), expected);\n    }\n\n    #[rstest]\n    #[case(r#\"#[serde(rename_all = \"camelCase\")] struct Foo;\"#, Some(\"camelCase\"))]\n    #[case(\n        r#\"#[serde(rename_all = \"snake_case\")] struct Foo;\"#,\n        Some(\"snake_case\")\n    )]\n    #[case(\n        r#\"#[serde(rename_all = \"kebab-case\")] struct Foo;\"#,\n        Some(\"kebab-case\")\n    )]\n    #[case(\n        r#\"#[serde(rename_all = \"PascalCase\")] struct Foo;\"#,\n        Some(\"PascalCase\")\n    )]\n    // Multiple attributes - this is the bug case\n    #[case(\n        r#\"#[serde(rename_all = \"camelCase\", default)] struct Foo;\"#,\n        Some(\"camelCase\")\n    )]\n    #[case(\n        r#\"#[serde(default, rename_all = \"snake_case\")] struct Foo;\"#,\n        Some(\"snake_case\")\n    )]\n    #[case(r#\"#[serde(rename_all = \"kebab-case\", skip_serializing_if = \"Option::is_none\")] struct Foo;\"#, Some(\"kebab-case\"))]\n    // No rename_all\n    #[case(r#\"#[serde(default)] struct Foo;\"#, None)]\n    #[case(r#\"#[derive(Debug)] struct Foo;\"#, None)]\n    fn test_extract_rename_all(#[case] item_src: \u0026str, #[case] expected: Option\u003c\u0026str\u003e) {\n        let item: syn::ItemStruct = syn::parse_str(item_src).unwrap();\n        let result = extract_rename_all(\u0026item.attrs);\n        assert_eq!(result.as_deref(), expected);\n    }\n\n    #[test]\n    fn test_extract_rename_all_enum_with_deny_unknown_fields() {\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"camelCase\", deny_unknown_fields)]\n            enum Foo { A, B }\n        \"#,\n        )\n        .unwrap();\n        let result = extract_rename_all(\u0026enum_item.attrs);\n        assert_eq!(result.as_deref(), Some(\"camelCase\"));\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":7,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":8,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":10,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":11,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":12,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":13,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":15,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":17,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":19,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":21,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":23,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":24,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":28,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":29,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":54,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":55,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":56,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":57,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":60,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":61,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":62,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":63,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":65,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":67,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":69,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":71,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":73,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":74,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":78,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":80,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":82,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":122,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":123,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":124,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":125,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":127,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":129,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":156,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":157,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":158,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":159,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":161,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":162,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":163,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":168,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":174,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":187,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":188,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":189,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":190,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":192,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":193,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":194,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":211,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":217,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":244,"address":[],"length":0,"stats":{"Line":7854277750134145024}},{"line":246,"address":[],"length":0,"stats":{"Line":7854277750134145024}},{"line":247,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":249,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":250,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":251,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":252,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":254,"address":[],"length":0,"stats":{"Line":9079256848778919936}},{"line":255,"address":[],"length":0,"stats":{"Line":13042424520864956416}},{"line":256,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":257,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":258,"address":[],"length":0,"stats":{"Line":12393906174523604992}},{"line":261,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":262,"address":[],"length":0,"stats":{"Line":16357073846609641472}},{"line":264,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":265,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":268,"address":[],"length":0,"stats":{"Line":12538021362599460864}},{"line":270,"address":[],"length":0,"stats":{"Line":9871890383196127232}},{"line":271,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":272,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":279,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":281,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":282,"address":[],"length":0,"stats":{"Line":14915921965851082752}},{"line":283,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":284,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":286,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":288,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":290,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":292,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":293,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":294,"address":[],"length":0,"stats":{"Line":13546827679130451968}},{"line":295,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":296,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":298,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":299,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":300,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":302,"address":[],"length":0,"stats":{"Line":11673330234144325632}},{"line":305,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":307,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":309,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":310,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":311,"address":[],"length":0,"stats":{"Line":4827858800541171712}},{"line":312,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":313,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":314,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":315,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":316,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":318,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":321,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":323,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":325,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":327,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":329,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":331,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":334,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":336,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":339,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":340,"address":[],"length":0,"stats":{"Line":10448351135499550720}},{"line":341,"address":[],"length":0,"stats":{"Line":10232178353385766912}},{"line":342,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":344,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":345,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":346,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":347,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":350,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":352,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":355,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":356,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":357,"address":[],"length":0,"stats":{"Line":7493989779944505344}},{"line":358,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":359,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":360,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":362,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":364,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":365,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":366,"address":[],"length":0,"stats":{"Line":7277816997830721536}},{"line":367,"address":[],"length":0,"stats":{"Line":17654110539292344320}},{"line":369,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":372,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":374,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":378,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":384,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":387,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":388,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":390,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":392,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":394,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":396,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":397,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":400,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":401,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":404,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":407,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":411,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":412,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":421,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":423,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":424,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":427,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":428,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":431,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":434,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":438,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":442,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":446,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":448,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":449,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":450,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":452,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":453,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":456,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":457,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":464,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":465,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":467,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":468,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":469,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":471,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":474,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":478,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":479,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":480,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":485,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":486,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":487,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":488,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":492,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":493,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":498,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":500,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":501,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":502,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":504,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":505,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":506,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":508,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":509,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":512,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":513,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":517,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":518,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":522,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":523,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":524,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":526,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":529,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":530,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":531,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":532,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":533,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":534,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":535,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":536,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":537,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":540,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":541,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":547,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":552,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":560,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":561,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":562,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":563,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":567,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":568,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":574,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":579,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":589,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":594,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":595,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":598,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":600,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":601,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":602,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":604,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":609,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":611,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":612,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":615,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":616,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":619,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":622,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":624,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":625,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":628,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":631,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":635,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":645,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":646,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":647,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":648,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":649,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":650,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":651,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":652,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":655,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":656,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":660,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":663,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":666,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":672,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":673,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":678,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":687,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":689,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":690,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":692,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":693,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":695,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":696,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":698,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":704,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":705,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":708,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":710,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":711,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":712,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":716,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":719,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":720,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":721,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":722,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":723,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":724,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":725,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":726,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":741,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":744,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":748,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":753,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":756,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":761,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":762,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":775,"address":[],"length":0,"stats":{"Line":10160120759347838976}},{"line":776,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":778,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":779,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":780,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":782,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":783,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":786,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":787,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":788,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":789,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":791,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":793,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":794,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":795,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":796,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":797,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":804,"address":[],"length":0,"stats":{"Line":9367487224930631680}},{"line":807,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":809,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":810,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":811,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":814,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":815,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":816,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":819,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":820,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":821,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":823,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":824,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":827,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":828,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":829,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":830,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":834,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":839,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":840,"address":[],"length":0,"stats":{"Line":16933534598913064960}},{"line":841,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":843,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":844,"address":[],"length":0,"stats":{"Line":9295429630892703744}},{"line":845,"address":[],"length":0,"stats":{"Line":15204152342002794496}},{"line":848,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":850,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":864,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":867,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":868,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":871,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":872,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":873,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":875,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":876,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":877,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":886,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":888,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":889,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":890,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":899,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":900,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":901,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":902,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":903,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":904,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":910,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":911,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":915,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":916,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":917,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":919,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":924,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":935,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":937,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":382,"coverable":451},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","route","mod.rs"],"content":"mod utils;\n\npub use utils::*;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","route","utils.rs"],"content":"use crate::args::RouteArgs;\n\n/// Extract doc comments from attributes\n/// Returns concatenated doc comment string or None if no doc comments\npub fn extract_doc_comment(attrs: \u0026[syn::Attribute]) -\u003e Option\u003cString\u003e {\n    let mut doc_lines = Vec::new();\n\n    for attr in attrs {\n        if attr.path().is_ident(\"doc\")\n            \u0026\u0026 let syn::Meta::NameValue(meta_nv) = \u0026attr.meta\n            \u0026\u0026 let syn::Expr::Lit(syn::ExprLit {\n                lit: syn::Lit::Str(lit_str),\n                ..\n            }) = \u0026meta_nv.value\n        {\n            let line = lit_str.value();\n            // Trim leading space that rustdoc adds\n            let trimmed = line.strip_prefix(' ').unwrap_or(\u0026line);\n            doc_lines.push(trimmed.to_string());\n        }\n    }\n\n    if doc_lines.is_empty() {\n        None\n    } else {\n        Some(doc_lines.join(\"\\n\"))\n    }\n}\n\n#[derive(Debug)]\npub struct RouteInfo {\n    pub method: String,\n    pub path: Option\u003cString\u003e,\n    pub error_status: Option\u003cVec\u003cu16\u003e\u003e,\n    pub tags: Option\u003cVec\u003cString\u003e\u003e,\n    pub description: Option\u003cString\u003e,\n}\n\npub fn check_route_by_meta(meta: \u0026syn::Meta) -\u003e bool {\n    match meta {\n        syn::Meta::List(meta_list) =\u003e {\n            (meta_list.path.segments.len() == 2\n                \u0026\u0026 meta_list.path.segments[0].ident == \"vespera\"\n                \u0026\u0026 meta_list.path.segments[1].ident == \"route\")\n                || (meta_list.path.segments.len() == 1\n                    \u0026\u0026 meta_list.path.segments[0].ident == \"route\")\n        }\n        syn::Meta::Path(path) =\u003e {\n            (path.segments.len() == 2\n                \u0026\u0026 path.segments[0].ident == \"vespera\"\n                \u0026\u0026 path.segments[1].ident == \"route\")\n                || (path.segments.len() == 1 \u0026\u0026 path.segments[0].ident == \"route\")\n        }\n        syn::Meta::NameValue(meta_nv) =\u003e {\n            (meta_nv.path.segments.len() == 2\n                \u0026\u0026 meta_nv.path.segments[0].ident == \"vespera\"\n                \u0026\u0026 meta_nv.path.segments[1].ident == \"route\")\n                || (meta_nv.path.segments.len() == 1 \u0026\u0026 meta_nv.path.segments[0].ident == \"route\")\n        }\n    }\n}\n\npub fn extract_route_info(attrs: \u0026[syn::Attribute]) -\u003e Option\u003cRouteInfo\u003e {\n    for attr in attrs {\n        // Check if attribute path is \"vespera\" or \"route\"\n        if check_route_by_meta(\u0026attr.meta) {\n            match \u0026attr.meta {\n                syn::Meta::List(meta_list) =\u003e {\n                    // Try to parse as RouteArgs\n                    if let Ok(route_args) = meta_list.parse_args::\u003cRouteArgs\u003e() {\n                        let method = route_args\n                            .method\n                            .as_ref()\n                            .map(syn::Ident::to_string)\n                            .unwrap_or_else(|| \"get\".to_string());\n                        let path = route_args.path.as_ref().map(syn::LitStr::value);\n\n                        // Parse error_status array if present\n                        let error_status = route_args.error_status.as_ref().and_then(|array| {\n                            let mut status_codes = Vec::new();\n                            for elem in \u0026array.elems {\n                                if let syn::Expr::Lit(syn::ExprLit {\n                                    lit: syn::Lit::Int(lit_int),\n                                    ..\n                                }) = elem\n                                    \u0026\u0026 let Ok(code) = lit_int.base10_parse::\u003cu16\u003e()\n                                {\n                                    status_codes.push(code);\n                                }\n                            }\n                            if status_codes.is_empty() {\n                                None\n                            } else {\n                                Some(status_codes)\n                            }\n                        });\n\n                        // Parse tags array if present\n                        let tags = route_args.tags.as_ref().and_then(|array| {\n                            let mut tag_list = Vec::new();\n                            for elem in \u0026array.elems {\n                                if let syn::Expr::Lit(syn::ExprLit {\n                                    lit: syn::Lit::Str(lit_str),\n                                    ..\n                                }) = elem\n                                {\n                                    tag_list.push(lit_str.value());\n                                }\n                            }\n                            if tag_list.is_empty() {\n                                None\n                            } else {\n                                Some(tag_list)\n                            }\n                        });\n\n                        // Parse description if present\n                        let description = route_args.description.as_ref().map(|s| s.value());\n\n                        return Some(RouteInfo {\n                            method,\n                            path,\n                            error_status,\n                            tags,\n                            description,\n                        });\n                    }\n                }\n                // Try to parse as Meta::NameValue (e.g., #[route = \"patch\"])\n                syn::Meta::NameValue(meta_nv) =\u003e {\n                    if let syn::Expr::Lit(syn::ExprLit {\n                        lit: syn::Lit::Str(lit_str),\n                        ..\n                    }) = \u0026meta_nv.value\n                    {\n                        let method_str = lit_str.value().to_lowercase();\n                        if method_str == \"get\"\n                            || method_str == \"post\"\n                            || method_str == \"put\"\n                            || method_str == \"patch\"\n                            || method_str == \"delete\"\n                            || method_str == \"head\"\n                            || method_str == \"options\"\n                        {\n                            return Some(RouteInfo {\n                                method: method_str,\n                                path: None,\n                                error_status: None,\n                                tags: None,\n                                description: None,\n                            });\n                        }\n                    }\n                }\n                // Try to parse as Meta::Path (e.g., #[route])\n                syn::Meta::Path(_) =\u003e {\n                    return Some(RouteInfo {\n                        method: \"get\".to_string(),\n                        path: None,\n                        error_status: None,\n                        tags: None,\n                        description: None,\n                    });\n                }\n            }\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rstest::rstest;\n\n    fn parse_meta_from_attr(attr_str: \u0026str) -\u003e syn::Meta {\n        // Parse attribute from string like \"#[route()]\" or \"#[vespera::route(get)]\"\n        let full_code = format!(\"{} fn test() {{}}\", attr_str);\n        let file: syn::File = syn::parse_str(\u0026full_code).expect(\"Failed to parse with attribute\");\n\n        // Extract the first attribute from the function\n        if let Some(syn::Item::Fn(fn_item)) = file.items.first()\n            \u0026\u0026 let Some(attr) = fn_item.attrs.first()\n        {\n            return attr.meta.clone();\n        }\n\n        panic!(\"Failed to extract meta from attribute: {}\", attr_str);\n    }\n\n    #[rstest]\n    // Valid route attributes (List meta)\n    #[case(\"#[route()]\", true)]\n    #[case(\"#[vespera::route()]\", true)]\n    #[case(\"#[route(get)]\", true)]\n    #[case(\"#[vespera::route(get)]\", true)]\n    #[case(\"#[route(post)]\", true)]\n    #[case(\"#[vespera::route(post)]\", true)]\n    #[case(\"#[route(get, path = \\\"/api\\\")]\", true)]\n    #[case(\"#[vespera::route(get, path = \\\"/api\\\")]\", true)]\n    // Path meta (without parentheses) should return true\n    #[case(\"#[route]\", true)]\n    #[case(\"#[vespera::route]\", true)]\n    // NameValue meta should return true\n    #[case(\"#[route = \\\"get\\\"]\", true)]\n    #[case(\"#[vespera::route = \\\"get\\\"]\", true)]\n    // Invalid route attributes\n    #[case(\"#[other()]\", false)]\n    #[case(\"#[vespera::other()]\", false)]\n    #[case(\"#[other(get)]\", false)]\n    #[case(\"#[vespera::other(get)]\", false)]\n    #[case(\"#[derive(Schema)]\", false)]\n    #[case(\"#[serde(rename_all = \\\"camelCase\\\")]\", false)]\n    #[case(\"#[test]\", false)]\n    // Nested paths with more than 2 segments should return false\n    #[case(\"#[vespera::route::something]\", false)]\n    #[case(\"#[vespera::route::something()]\", false)]\n    fn test_check_route_by_meta(#[case] attr_str: \u0026str, #[case] expected: bool) {\n        let meta = parse_meta_from_attr(attr_str);\n        let result = check_route_by_meta(\u0026meta);\n        assert_eq!(\n            result, expected,\n            \"Failed for attribute: {}, expected: {}\",\n            attr_str, expected\n        );\n    }\n\n    fn parse_attrs_from_code(code: \u0026str) -\u003e Vec\u003csyn::Attribute\u003e {\n        let file: syn::File = syn::parse_str(code).expect(\"Failed to parse code\");\n        if let Some(syn::Item::Fn(fn_item)) = file.items.first() {\n            return fn_item.attrs.clone();\n        }\n        vec![]\n    }\n\n    #[rstest]\n    // Route with method only\n    #[case(\"#[route(get)] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    #[case(\"#[route(post)] fn test() {}\", Some((\"post\".to_string(), None, None)))]\n    #[case(\"#[route(put)] fn test() {}\", Some((\"put\".to_string(), None, None)))]\n    #[case(\"#[route(patch)] fn test() {}\", Some((\"patch\".to_string(), None, None)))]\n    #[case(\"#[route(delete)] fn test() {}\", Some((\"delete\".to_string(), None, None)))]\n    #[case(\"#[route(head)] fn test() {}\", Some((\"head\".to_string(), None, None)))]\n    #[case(\"#[route(options)] fn test() {}\", Some((\"options\".to_string(), None, None)))]\n    #[case(\"#[vespera::route(get)] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    // Route with method and path\n    #[case(\"#[route(get, path = \\\"/api\\\")] fn test() {}\", Some((\"get\".to_string(), Some(\"/api\".to_string()), None)))]\n    #[case(\"#[route(post, path = \\\"/users\\\")] fn test() {}\", Some((\"post\".to_string(), Some(\"/users\".to_string()), None)))]\n    #[case(\"#[route(get, path = \\\"/api/v1\\\")] fn test() {}\", Some((\"get\".to_string(), Some(\"/api/v1\".to_string()), None)))]\n    // Route with method and error_status\n    #[case(\"#[route(get, error_status = [400])] fn test() {}\", Some((\"get\".to_string(), None, Some(vec![400]))))]\n    #[case(\"#[route(get, error_status = [400, 404])] fn test() {}\", Some((\"get\".to_string(), None, Some(vec![400, 404]))))]\n    #[case(\"#[route(get, error_status = [400, 404, 500])] fn test() {}\", Some((\"get\".to_string(), None, Some(vec![400, 404, 500]))))]\n    // Route with method, path, and error_status\n    #[case(\"#[route(get, path = \\\"/api\\\", error_status = [400])] fn test() {}\", Some((\"get\".to_string(), Some(\"/api\".to_string()), Some(vec![400]))))]\n    #[case(\"#[route(post, path = \\\"/users\\\", error_status = [400, 404])] fn test() {}\", Some((\"post\".to_string(), Some(\"/users\".to_string()), Some(vec![400, 404]))))]\n    // Route without method (defaults to \"get\")\n    #[case(\"#[route()] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    #[case(\"#[route(path = \\\"/api\\\")] fn test() {}\", Some((\"get\".to_string(), Some(\"/api\".to_string()), None)))]\n    // Route with Path meta (e.g., #[route])\n    #[case(\"#[route] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    #[case(\"#[vespera::route] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    // Route with empty error_status array (should return None for error_status)\n    #[case(\"#[route(get, error_status = [])] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    // NameValue format (should work now)\n    #[case(\"#[route = \\\"get\\\"] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    #[case(\"#[route = \\\"post\\\"] fn test() {}\", Some((\"post\".to_string(), None, None)))]\n    #[case(\"#[route = \\\"put\\\"] fn test() {}\", Some((\"put\".to_string(), None, None)))]\n    #[case(\"#[route = \\\"patch\\\"] fn test() {}\", Some((\"patch\".to_string(), None, None)))]\n    #[case(\"#[route = \\\"delete\\\"] fn test() {}\", Some((\"delete\".to_string(), None, None)))]\n    #[case(\"#[route = \\\"head\\\"] fn test() {}\", Some((\"head\".to_string(), None, None)))]\n    #[case(\"#[route = \\\"options\\\"] fn test() {}\", Some((\"options\".to_string(), None, None)))]\n    #[case(\"#[vespera::route = \\\"get\\\"] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    // Invalid cases (should return None)\n    #[case(\"#[other(get)] fn test() {}\", None)]\n    #[case(\"#[derive(Schema)] fn test() {}\", None)]\n    #[case(\"#[test] fn test() {}\", None)]\n    #[case(\"fn test() {}\", None)]\n    // Invalid method in NameValue format\n    #[case(\"#[route = \\\"invalid\\\"] fn test() {}\", None)]\n    #[case(\"#[route = \\\"GET\\\"] fn test() {}\", Some((\"get\".to_string(), None, None)))] // lowercase conversion\n    // Multiple attributes - should find route attribute\n    #[case(\"#[derive(Debug)] #[route(get, path = \\\"/api\\\")] #[test] fn test() {}\", Some((\"get\".to_string(), Some(\"/api\".to_string()), None)))]\n    // Multiple route attributes - first one wins\n    #[case(\"#[route(get, path = \\\"/first\\\")] #[route(post, path = \\\"/second\\\")] fn test() {}\", Some((\"get\".to_string(), Some(\"/first\".to_string()), None)))]\n    // Explicit tests for method.as_ref() and path.as_ref().map() coverage\n    #[case(\"#[route(path = \\\"/test\\\")] fn test() {}\", Some((\"get\".to_string(), Some(\"/test\".to_string()), None)))] // method None, path Some\n    #[case(\"#[route()] fn test() {}\", Some((\"get\".to_string(), None, None)))] // method None, path None\n    #[case(\"#[route(post)] fn test() {}\", Some((\"post\".to_string(), None, None)))] // method Some, path None\n    #[case(\"#[route(put, path = \\\"/test\\\")] fn test() {}\", Some((\"put\".to_string(), Some(\"/test\".to_string()), None)))] // method Some, path Some\n    fn test_extract_route_info(\n        #[case] code: \u0026str,\n        #[case] expected: Option\u003c(String, Option\u003cString\u003e, Option\u003cVec\u003cu16\u003e\u003e)\u003e,\n    ) {\n        let attrs = parse_attrs_from_code(code);\n        let result = extract_route_info(\u0026attrs);\n\n        match expected {\n            Some((exp_method, exp_path, exp_error_status)) =\u003e {\n                assert!(\n                    result.is_some(),\n                    \"Expected Some but got None for code: {}\",\n                    code\n                );\n                let route_info = result.unwrap();\n                assert_eq!(\n                    route_info.method, exp_method,\n                    \"Method mismatch for code: {}\",\n                    code\n                );\n                assert_eq!(\n                    route_info.path, exp_path,\n                    \"Path mismatch for code: {}\",\n                    code\n                );\n                assert_eq!(\n                    route_info.error_status, exp_error_status,\n                    \"Error status mismatch for code: {}\",\n                    code\n                );\n            }\n            None =\u003e {\n                assert!(\n                    result.is_none(),\n                    \"Expected None but got Some({:?}) for code: {}\",\n                    result,\n                    code\n                );\n            }\n        }\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":6,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":8,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":9,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":24,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":7133701809754865664}},{"line":40,"address":[],"length":0,"stats":{"Line":7133701809754865664}},{"line":41,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":42,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":43,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":44,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":45,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":46,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":48,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":49,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":50,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":52,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":54,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":55,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":58,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":63,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":64,"address":[],"length":0,"stats":{"Line":11601272640106397696}},{"line":66,"address":[],"length":0,"stats":{"Line":11240984669916758016}},{"line":67,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":68,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":70,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":80,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":81,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":83,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":85,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":86,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":88,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":91,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":92,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":94,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":132,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":134,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":136,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":137,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":138,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":139,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":140,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":141,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":142,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":143,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":145,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":146,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":147,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":148,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":149,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":150,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":157,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":158,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":159,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":160,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":161,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":162,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":168,"address":[],"length":0,"stats":{"Line":360287970189639680}}],"covered":65,"coverable":92},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","lib.rs"],"content":"mod routes;\n\nuse std::sync::Arc;\n\nuse serde::{Deserialize, Serialize};\nuse vespera::{Schema, axum, vespera};\n\npub struct AppState {\n    pub config: String,\n}\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct TestStruct {\n    pub name: String,\n    pub age: u32,\n}\n\n/// Create the application router for testing\npub fn create_app() -\u003e axum::Router {\n    vespera!(\n        openapi = [\"examples/axum-example/openapi.json\", \"openapi.json\"],\n        docs_url = \"/docs\",\n        redoc_url = \"/redoc\"\n    )\n    .with_state(Arc::new(AppState {\n        config: \"test\".to_string(),\n    }))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","main.rs"],"content":"use axum_example::create_app;\nuse vespera::axum;\n\n#[tokio::main]\nasync fn main() {\n    let app = create_app();\n\n    let addr = std::net::SocketAddr::from(([0, 0, 0, 0], 3000));\n    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();\n\n    println!(\" Server running on http://localhost:3000\");\n\n    axum::serve(listener, app).await.unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","enums.rs"],"content":"use std::collections::{BTreeMap, HashMap};\n\nuse serde::{Deserialize, Serialize};\nuse vespera::{Schema, axum::Json};\n\nuse crate::TestStruct;\n\n#[derive(Serialize, Deserialize, Schema)]\npub enum Enum {\n    A,\n    B,\n    C,\n}\n\n#[vespera::route(get)]\npub async fn enum_endpoint() -\u003e Json\u003cEnum\u003e {\n    Json(Enum::A)\n}\n\n#[derive(Serialize, Deserialize, Schema)]\npub enum Enum2 {\n    A(String),\n    B { name: String, age: i32 },\n    C(i32),\n    D(bool),\n    E(Vec\u003cString\u003e),\n    F(String, i32),\n    G(HashMap\u003cString, String\u003e),\n    H(BTreeMap\u003cString, String\u003e),\n    I(TestStruct),\n    J(Vec\u003cTestStruct\u003e),\n    K(TestStruct, TestStruct),\n    L(Option\u003cString\u003e),\n    M(Vec\u003cOption\u003cString\u003e\u003e),\n    N(HashMap\u003cString, Option\u003cString\u003e\u003e),\n}\n\n#[vespera::route(get, path = \"/enum2\")]\npub async fn enum_endpoint2() -\u003e Json\u003cEnum2\u003e {\n    Json(Enum2::A(\"a\".to_string()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","error.rs"],"content":"use serde::{Deserialize, Serialize};\nuse vespera::{\n    Schema,\n    axum::{Json, http::StatusCode, http::header::HeaderMap, response::IntoResponse},\n};\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct ErrorResponse {\n    pub error: String,\n    pub code: u32,\n}\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct ErrorResponse2 {\n    pub error: String,\n    pub code: u32,\n}\n\nimpl IntoResponse for ErrorResponse2 {\n    fn into_response(self) -\u003e vespera::axum::response::Response {\n        (StatusCode::INTERNAL_SERVER_ERROR, Json(self)).into_response()\n    }\n}\n\n#[vespera::route()]\npub async fn error_endpoint() -\u003e Result\u003c\u0026'static str, Json\u003cErrorResponse\u003e\u003e {\n    Err(Json(ErrorResponse {\n        error: \"Internal server error\".to_string(),\n        code: 500,\n    }))\n}\n\n#[vespera::route(path = \"/error-with-status\")]\npub async fn error_endpoint_with_status_code()\n-\u003e Result\u003c\u0026'static str, (StatusCode, Json\u003cErrorResponse\u003e)\u003e {\n    Err((\n        StatusCode::INTERNAL_SERVER_ERROR,\n        Json(ErrorResponse {\n            error: \"Internal server error\".to_string(),\n            code: 500,\n        }),\n    ))\n}\n\n#[vespera::route(path = \"/error2\")]\npub async fn error_endpoint2() -\u003e Result\u003c\u0026'static str, ErrorResponse2\u003e {\n    Err(ErrorResponse2 {\n        error: \"Internal server error\".to_string(),\n        code: 500,\n    })\n}\n\n#[vespera::route(path = \"/error-with-status2\", error_status = [500, 400, 404])]\npub async fn error_endpoint_with_status_code2() -\u003e Result\u003c\u0026'static str, (StatusCode, ErrorResponse2)\u003e\n{\n    Err((\n        StatusCode::INTERNAL_SERVER_ERROR,\n        ErrorResponse2 {\n            error: \"Internal server error\".to_string(),\n            code: 500,\n        },\n    ))\n}\n\n#[vespera::route(path = \"/header-map\")]\npub async fn header_map_endpoint() -\u003e Result\u003c(HeaderMap, \u0026'static str), ErrorResponse2\u003e {\n    let headers = HeaderMap::new();\n    println!(\"headers: {:?}\", headers);\n    Ok((headers, \"ok\"))\n}\n\n#[vespera::route(path = \"/header-map2\")]\npub async fn header_map_endpoint2() -\u003e Result\u003c(StatusCode, HeaderMap, \u0026'static str), ErrorResponse2\u003e\n{\n    let headers = HeaderMap::new();\n    println!(\"headers: {:?}\", headers);\n    Ok((StatusCode::INTERNAL_SERVER_ERROR, headers, \"ok\"))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","foo","mod.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::sync::Arc;\nuse vespera::{\n    Schema,\n    axum::{Json, extract::State},\n};\n\nuse crate::AppState;\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct SignupRequest {\n    pub email: String,\n    pub password: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Schema)]\n#[serde(rename_all = \"camelCase\")]\npub struct SignupResponse {\n    pub id: i32,\n    pub email: String,\n    pub name: String,\n    #[serde(rename = \"phoneNumber23\")]\n    pub phone_number: String,\n    pub nickname: Option\u003cString\u003e,\n    pub birthday: Option\u003cString\u003e,\n    pub gender: Option\u003cString\u003e,\n    pub job: Option\u003cString\u003e,\n    #[serde(rename = \"createdAt\")]\n    pub created_at: String,\n}\n\n#[vespera::route(post, path = \"/foo\")]\npub async fn signup(\n    State(app_state): State\u003cArc\u003cAppState\u003e\u003e,\n    Json(request): Json\u003cSignupRequest\u003e,\n) -\u003e Result\u003cJson\u003cSignupResponse\u003e, String\u003e {\n    println!(\"app_state: {:?}\", app_state.config);\n    let response = SignupResponse {\n        id: 1,\n        email: request.email,\n        name: \"John Doe\".to_string(),\n        phone_number: \"1234567890\".to_string(),\n        nickname: Some(\"John\".to_string()),\n        birthday: Some(\"1990-01-01\".to_string()),\n        gender: Some(\"male\".to_string()),\n        job: Some(\"engineer\".to_string()),\n        created_at: \"2021-01-01\".to_string(),\n    };\n    Ok(Json(response))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","generic.rs"],"content":"use serde::Serialize;\nuse vespera::axum::Json;\n\nuse crate::TestStruct;\n\n#[derive(Serialize, vespera::Schema)]\npub struct GenericStruct\u003cT: Serialize\u003e {\n    pub value: T,\n    pub name: String,\n}\n\n#[derive(Serialize, vespera::Schema)]\npub struct GenericStruct2\u003cT, T2\u003e {\n    pub value: T,\n    pub name: String,\n    pub value2: T2,\n}\n\n#[vespera::route(get, path = \"/generic/{value}\")]\npub async fn generic_endpoint(\n    vespera::axum::extract::Path(value): vespera::axum::extract::Path\u003cString\u003e,\n) -\u003e Json\u003cGenericStruct\u003cString\u003e\u003e {\n    Json(GenericStruct {\n        value,\n        name: \"John Doe\".to_string(),\n    })\n}\n\n#[vespera::route(get, path = \"/generic2\")]\npub async fn generic_endpoint2() -\u003e Json\u003cGenericStruct\u003cTestStruct\u003e\u003e {\n    Json(GenericStruct {\n        value: TestStruct {\n            name: \"test\".to_string(),\n            age: 20,\n        },\n        name: \"John Doe\".to_string(),\n    })\n}\n\n#[vespera::route(get, path = \"/generic3\")]\npub async fn generic_endpoint3() -\u003e Json\u003cGenericStruct2\u003cTestStruct, String\u003e\u003e {\n    Json(GenericStruct2 {\n        value: TestStruct {\n            name: \"test\".to_string(),\n            age: 20,\n        },\n        value2: \"test2\".to_string(),\n        name: \"John Doe\".to_string(),\n    })\n}\n\n#[vespera::route(get, path = \"/generic4\")]\npub async fn generic_endpoint4() -\u003e Json\u003cGenericStruct2\u003cbool, bool\u003e\u003e {\n    Json(GenericStruct2 {\n        value: true,\n        value2: false,\n        name: \"John Doe\".to_string(),\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","health.rs"],"content":"#[vespera::route(get)]\npub async fn health() -\u003e \u0026'static str {\n    \"ok\"\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","mod.rs"],"content":"use std::collections::HashMap;\n\nuse serde::Deserialize;\nuse vespera::{\n    Schema,\n    axum::{Json, extract::Query},\n};\n\nuse crate::TestStruct;\n\npub mod enums;\npub mod error;\npub mod foo;\npub mod generic;\npub mod health;\npub mod path;\npub mod typed_header;\npub mod users;\n\n/// Health check endpoint\n#[vespera::route(get)]\npub async fn root_endpoint() -\u003e \u0026'static str {\n    \"root endpoint\"\n}\n\n/// Hello!!\n#[vespera::route(get, path = \"/hello\", tags = [\"hello\"])]\npub async fn mod_file_endpoint() -\u003e \u0026'static str {\n    \"mod file endpoint\"\n}\n\n#[derive(Deserialize, Schema, Debug)]\npub struct MapQuery {\n    pub name: String,\n    pub age: u32,\n    pub optional_age: Option\u003cu32\u003e,\n}\n#[vespera::route(get, path = \"/map-query\")]\npub async fn mod_file_with_map_query(Query(query): Query\u003cMapQuery\u003e) -\u003e \u0026'static str {\n    println!(\"map query: {:?}\", query.age);\n    println!(\"map query: {:?}\", query.name);\n    println!(\"map query: {:?}\", query.optional_age);\n    \"mod file endpoint\"\n}\n\n#[derive(Deserialize, Debug)]\npub struct NoSchemaQuery {\n    pub name: String,\n    pub age: u32,\n    pub optional_age: Option\u003cu32\u003e,\n}\n\n#[vespera::route(get, path = \"/no-schema-query\")]\npub async fn mod_file_with_no_schema_query(Query(query): Query\u003cNoSchemaQuery\u003e) -\u003e \u0026'static str {\n    println!(\"no schema query: {:?}\", query.age);\n    println!(\"no schema query: {:?}\", query.name);\n    println!(\"no schema query: {:?}\", query.optional_age);\n    \"mod file endpoint\"\n}\n\n#[derive(Deserialize, Schema)]\npub struct StructQuery {\n    pub name: String,\n    pub age: u32,\n}\n\n#[vespera::route(get, path = \"/struct-query\")]\npub async fn mod_file_with_struct_query(Query(query): Query\u003cStructQuery\u003e) -\u003e String {\n    format!(\"name: {}, age: {}\", query.name, query.age)\n}\n\n#[derive(Deserialize, Schema)]\npub struct StructBody {\n    pub name: String,\n    pub age: u32,\n}\n\n#[vespera::route(post, path = \"/struct-body\")]\npub async fn mod_file_with_struct_body(Json(body): Json\u003cStructBody\u003e) -\u003e String {\n    format!(\"name: {}, age: {}\", body.name, body.age)\n}\n\n#[derive(Deserialize, Schema, Debug)]\npub struct StructBodyWithOptional {\n    pub name: Option\u003cString\u003e,\n    pub age: Option\u003cu32\u003e,\n}\n\n#[vespera::route(post, path = \"/struct-body-with-optional\")]\npub async fn mod_file_with_struct_body_with_optional(\n    Json(body): Json\u003cStructBodyWithOptional\u003e,\n) -\u003e String {\n    format!(\"name: {:?}, age: {:?}\", body.name, body.age)\n}\n\n#[derive(Deserialize, Schema)]\npub struct ComplexStructBody {\n    pub name: String,\n    pub age: u32,\n    pub nested_struct: StructBodyWithOptional,\n    pub array: Vec\u003cString\u003e,\n    pub map: HashMap\u003cString, String\u003e,\n    pub nested_array: Vec\u003cStructBodyWithOptional\u003e,\n    pub nested_map: HashMap\u003cString, StructBodyWithOptional\u003e,\n    pub nested_struct_array: Vec\u003cStructBodyWithOptional\u003e,\n    pub nested_struct_map: HashMap\u003cString, StructBodyWithOptional\u003e,\n    pub nested_struct_array_map: Vec\u003cHashMap\u003cString, StructBodyWithOptional\u003e\u003e,\n    pub nested_struct_map_array: HashMap\u003cString, Vec\u003cStructBodyWithOptional\u003e\u003e,\n}\n\n#[vespera::route(post, path = \"/complex-struct-body\")]\npub async fn mod_file_with_complex_struct_body(Json(body): Json\u003cComplexStructBody\u003e) -\u003e String {\n    format!(\n        \"name: {}, age: {}, nested_struct: {:?}, array: {:?}, map: {:?}, nested_array: {:?}, nested_map: {:?}, nested_struct_array: {:?}, nested_struct_map: {:?}, nested_struct_array_map: {:?}, nested_struct_map_array: {:?}\",\n        body.name,\n        body.age,\n        body.nested_struct,\n        body.array,\n        body.map,\n        body.nested_array,\n        body.nested_map,\n        body.nested_struct_array,\n        body.nested_struct_map,\n        body.nested_struct_array_map,\n        body.nested_struct_map_array\n    )\n}\n\n#[derive(Deserialize, Schema)]\n#[serde(rename_all = \"camelCase\")]\npub struct ComplexStructBodyWithRename {\n    pub name: String,\n    pub age: u32,\n    pub nested_struct: StructBodyWithOptional,\n    pub array: Vec\u003cString\u003e,\n    pub map: HashMap\u003cString, String\u003e,\n    pub nested_array: Vec\u003cStructBodyWithOptional\u003e,\n    pub nested_map: HashMap\u003cString, StructBodyWithOptional\u003e,\n    pub nested_struct_array: Vec\u003cStructBodyWithOptional\u003e,\n    pub nested_struct_map: HashMap\u003cString, StructBodyWithOptional\u003e,\n    pub nested_struct_array_map: Vec\u003cHashMap\u003cString, StructBodyWithOptional\u003e\u003e,\n    pub nested_struct_map_array: HashMap\u003cString, Vec\u003cStructBodyWithOptional\u003e\u003e,\n}\n\n#[vespera::route(post, path = \"/complex-struct-body-with-rename\")]\npub async fn mod_file_with_complex_struct_body_with_rename(\n    Json(body): Json\u003cComplexStructBodyWithRename\u003e,\n) -\u003e String {\n    format!(\n        \"name: {}, age: {}, nested_struct: {:?}, array: {:?}, map: {:?}, nested_array: {:?}, nested_map: {:?}, nested_struct_array: {:?}, nested_struct_map: {:?}, nested_struct_array_map: {:?}, nested_struct_map_array: {:?}\",\n        body.name,\n        body.age,\n        body.nested_struct,\n        body.array,\n        body.map,\n        body.nested_array,\n        body.nested_map,\n        body.nested_struct_array,\n        body.nested_struct_map,\n        body.nested_struct_array_map,\n        body.nested_struct_map_array\n    )\n}\n\n#[vespera::route(get, path = \"/test_struct\")]\npub async fn mod_file_with_test_struct(Query(query): Query\u003cTestStruct\u003e) -\u003e Json\u003cTestStruct\u003e {\n    Json(query)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","path","mod.rs"],"content":"pub mod prefix;\n\n#[vespera::route(get, path = \"/multi-path/{var1}\")]\npub async fn mod_file_with_test_struct(\n    vespera::axum::extract::Path(var1): vespera::axum::extract::Path\u003cString\u003e,\n) -\u003e \u0026'static str {\n    println!(\"var1: {}\", var1);\n    \"multi path\"\n}\n\n// multi path\n#[vespera::route(get, path = \"/multi-path/{arg}/{var1}/{var2}\")]\npub async fn mod_file_with_multi_path(\n    vespera::axum::extract::Path((arg2, var1, var2)): vespera::axum::extract::Path\u003c(\n        String,\n        String,\n        String,\n    )\u003e,\n) -\u003e \u0026'static str {\n    println!(\"arg: {}\", arg2);\n    println!(\"var1: {}\", var1);\n    println!(\"var2: {}\", var2);\n    \"multi path\"\n}\n\n// multi path\n#[vespera::route(get, path = \"/multi-path2/{arg}/{var1}/{var2}\")]\npub async fn mod_file_with_multi_path_2(\n    vespera::axum::extract::Path(path): vespera::axum::extract::Path\u003c(String, String, String)\u003e,\n) -\u003e \u0026'static str {\n    println!(\"arg: {:?}\", path);\n    \"multi path\"\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","path","prefix","mod.rs"],"content":"use vespera::axum::extract::Path;\n\n#[vespera::route(path = \"/{var}\")]\npub async fn prefix_variable(Path(var): Path\u003cString\u003e) -\u003e String {\n    format!(\"prefix variable: {}\", var)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","typed_header.rs"],"content":"use vespera::axum_extra::{\r\n    TypedHeader,\r\n    headers::{Authorization, ContentType, UserAgent, authorization::Bearer},\r\n};\r\n\r\n#[vespera::route(post)]\r\npub async fn typed_header(\r\n    TypedHeader(user_agent): TypedHeader\u003cUserAgent\u003e,\r\n    content_type: Option\u003cTypedHeader\u003cContentType\u003e\u003e,\r\n) -\u003e \u0026'static str {\r\n    println!(\"user_agent: {:?}\", user_agent);\r\n    println!(\"content_type: {:?}\", content_type);\r\n    \"ok\"\r\n}\r\n\r\n#[vespera::route()]\r\npub async fn typed_header_jwt(\r\n    TypedHeader(authorization): TypedHeader\u003cAuthorization\u003cBearer\u003e\u003e,\r\n) -\u003e \u0026'static str {\r\n    println!(\"authorization: {:?}\", authorization);\r\n    \"ok\"\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","users.rs"],"content":"use std::collections::{BTreeMap, HashMap};\n\nuse serde::{Deserialize, Serialize};\nuse vespera::{\n    Schema,\n    axum::{Json, extract::Path},\n};\n\n#[derive(Serialize, Deserialize, Clone, Schema)]\npub struct User {\n    pub id: u32,\n    pub name: String,\n    pub email: String,\n}\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct CreateUserRequest {\n    pub name: String,\n    pub email: String,\n}\n\n/// Get all users\n#[vespera::route(get)]\npub async fn get_users() -\u003e Json\u003cVec\u003cUser\u003e\u003e {\n    Json(vec![\n        User {\n            id: 1,\n            name: \"Alice\".to_string(),\n            email: \"alice@example.com\".to_string(),\n        },\n        User {\n            id: 2,\n            name: \"Bob\".to_string(),\n            email: \"bob@example.com\".to_string(),\n        },\n    ])\n}\n\n/// Get user by ID\n#[vespera::route(get, path = \"/{id}\")]\npub async fn get_user(Path(id): Path\u003cu32\u003e) -\u003e Json\u003cUser\u003e {\n    Json(User {\n        id,\n        name: format!(\"User {}\", id),\n        email: format!(\"user{}@example.com\", id),\n    })\n}\n\n/// Create a new user\n#[vespera::route(post)]\npub async fn create_user(Json(user): Json\u003cCreateUserRequest\u003e) -\u003e Json\u003cUser\u003e {\n    Json(User {\n        id: 100,\n        name: user.name,\n        email: user.email,\n    })\n}\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct SkipResponse {\n    pub name: String,\n    #[serde(skip)]\n    #[allow(dead_code)]\n    pub email: String,\n\n    #[serde(skip, skip_serializing_if = \"Option::is_none\")]\n    #[allow(dead_code)]\n    pub email2: Option\u003cString\u003e,\n\n    #[serde(rename = \"email3\", skip)]\n    #[allow(dead_code)]\n    pub email3: Option\u003cString\u003e,\n\n    #[serde(rename = \"email4\", skip_serializing_if = \"Option::is_none\")]\n    pub email4: Option\u003cString\u003e,\n\n    #[serde(rename = \"email5\", default)]\n    pub email5: String,\n\n    #[serde(rename = \"email6\", default = \"default_value\")]\n    pub email6: String,\n\n    #[serde(rename = \"email7\", skip)]\n    #[allow(dead_code)]\n    pub email7: String,\n\n    #[serde(rename = \"num\", default)]\n    pub num: i32,\n\n    pub in_skip: InSkipResponse,\n    pub in_skip2: Option\u003cInSkipResponse\u003e,\n    pub in_skip3: Vec\u003cInSkipResponse\u003e,\n    pub in_skip4: Option\u003cVec\u003cInSkipResponse\u003e\u003e,\n    pub in_skip5: Option\u003cHashMap\u003cString, InSkipResponse\u003e\u003e,\n    pub in_skip6: Option\u003cBTreeMap\u003cString, InSkipResponse\u003e\u003e,\n}\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct InSkipResponse {\n    pub name: String,\n}\n\nfn default_value() -\u003e String {\n    \"default42\".to_string()\n}\n\n#[vespera::route(get, path = \"/skip-response\")]\npub async fn skip_response() -\u003e Json\u003cSkipResponse\u003e {\n    Json(SkipResponse {\n        name: \"John Doe\".to_string(),\n        email: \"john.doe@example.com\".to_string(),\n        email2: Some(\"john.doe2@example.com\".to_string()),\n        email3: Some(\"john.doe3@example.com\".to_string()),\n        email4: Some(\"john.doe4@example.com\".to_string()),\n        email5: \"john.doe5@example.com\".to_string(),\n        email6: \"john.doe6@example.com\".to_string(),\n        email7: \"john.doe7@example.com\".to_string(),\n        num: 0,\n        in_skip: InSkipResponse {\n            name: \"John Doe\".to_string(),\n        },\n        in_skip2: Some(InSkipResponse {\n            name: \"John Doe\".to_string(),\n        }),\n        in_skip3: vec![InSkipResponse {\n            name: \"John Doe\".to_string(),\n        }],\n        in_skip4: Some(vec![InSkipResponse {\n            name: \"John Doe\".to_string(),\n        }]),\n        in_skip5: Some(HashMap::from([(\n            \"John Doe\".to_string(),\n            InSkipResponse {\n                name: \"John Doe\".to_string(),\n            },\n        )])),\n        in_skip6: Some(BTreeMap::from([(\n            \"John Doe\".to_string(),\n            InSkipResponse {\n                name: \"John Doe\".to_string(),\n            },\n        )])),\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","serde-291d5c27960f80df","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private228 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","serde-63bbc3c99eac9aa0","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private228 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","serde-aff10547193e0874","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private228 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","serde_core-e39d8b2cecdfa797","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","serde_core-e6de1ee7ca275495","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","thiserror-637f0ad34ab847ca","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private17 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","typetag-8e6210346607692e","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private21 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","tests","integration_test.rs"],"content":"use axum_example::create_app;\nuse axum_test::TestServer;\nuse serde_json::json;\n\n#[tokio::test]\nasync fn test_health_endpoint() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/health\").await;\n\n    response.assert_status_ok();\n    response.assert_text(\"ok\");\n}\n\n#[tokio::test]\nasync fn test_mod_file_endpoint() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/hello\").await;\n\n    response.assert_status_ok();\n    response.assert_text(\"mod file endpoint\");\n\n    let response = server.get(\"/\").await;\n\n    response.assert_status_ok();\n    response.assert_text(\"root endpoint\");\n}\n\n#[tokio::test]\nasync fn test_get_users() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/users\").await;\n\n    response.assert_status_ok();\n    let users: serde_json::Value = response.json();\n\n    assert!(users.is_array());\n    assert_eq!(users.as_array().unwrap().len(), 2);\n\n    let first_user = \u0026users[0];\n    assert_eq!(first_user[\"id\"], 1);\n    assert_eq!(first_user[\"name\"], \"Alice\");\n    assert_eq!(first_user[\"email\"], \"alice@example.com\");\n}\n\n#[tokio::test]\nasync fn test_get_user_by_id() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/users/42\").await;\n\n    response.assert_status_ok();\n    let user: serde_json::Value = response.json();\n\n    assert_eq!(user[\"id\"], 42);\n    assert_eq!(user[\"name\"], \"User 42\");\n    assert_eq!(user[\"email\"], \"user42@example.com\");\n}\n\n#[tokio::test]\nasync fn test_create_user() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let new_user = json!({\n        \"name\": \"Charlie\",\n        \"email\": \"charlie@example.com\"\n    });\n\n    let response = server.post(\"/users\").json(\u0026new_user).await;\n\n    response.assert_status_ok();\n    let created_user: serde_json::Value = response.json();\n\n    assert_eq!(created_user[\"id\"], 100);\n    assert_eq!(created_user[\"name\"], \"Charlie\");\n    assert_eq!(created_user[\"email\"], \"charlie@example.com\");\n}\n\n#[tokio::test]\nasync fn test_get_nonexistent_user() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/users/999\").await;\n\n    response.assert_status_ok();\n    let user: serde_json::Value = response.json();\n    assert_eq!(user[\"id\"], 999);\n}\n\n#[tokio::test]\nasync fn test_prefix_variable() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/path/prefix/123\").await;\n\n    response.assert_status_ok();\n    response.assert_text(\"prefix variable: 123\");\n}\n\n#[tokio::test]\nasync fn test_invalid_path() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/nonexistent\").await;\n\n    response.assert_status_not_found();\n}\n\n#[tokio::test]\nasync fn test_mod_file_with_complex_struct_body() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let complex_body = json!({\n        \"name\": \"Test User\",\n        \"age\": 30,\n        \"nested_struct\": {\n            \"name\": \"Nested Name\",\n            \"age\": 25\n        },\n        \"array\": [\"item1\", \"item2\", \"item3\"],\n        \"map\": {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        },\n        \"nested_array\": [\n            {\n                \"name\": \"Array Item 1\",\n                \"age\": 20\n            },\n            {\n                \"name\": \"Array Item 2\",\n                \"age\": 21\n            }\n        ],\n        \"nested_map\": {\n            \"map_key1\": {\n                \"name\": \"Map Value 1\",\n                \"age\": 22\n            },\n            \"map_key2\": {\n                \"name\": \"Map Value 2\",\n                \"age\": 23\n            }\n        },\n        \"nested_struct_array\": [\n            {\n                \"name\": \"Struct Array 1\",\n                \"age\": 24\n            }\n        ],\n        \"nested_struct_map\": {\n            \"struct_map_key\": {\n                \"name\": \"Struct Map Value\",\n                \"age\": 26\n            }\n        },\n        \"nested_struct_array_map\": [\n            {\n                \"array_map_key1\": {\n                    \"name\": \"Array Map Value 1\",\n                    \"age\": 27\n                },\n                \"array_map_key2\": {\n                    \"name\": \"Array Map Value 2\",\n                    \"age\": 28\n                }\n            }\n        ],\n        \"nested_struct_map_array\": {\n            \"map_array_key\": [\n                {\n                    \"name\": \"Map Array Value 1\",\n                    \"age\": 29\n                },\n                {\n                    \"name\": \"Map Array Value 2\",\n                    \"age\": null\n                }\n            ]\n        }\n    });\n\n    let response = server\n        .post(\"/complex-struct-body\")\n        .json(\u0026complex_body)\n        .await;\n\n    response.assert_status_ok();\n    let response_text = response.text();\n\n    assert!(response_text.contains(\"name: Test User\"));\n    assert!(response_text.contains(\"age: 30\"));\n    assert!(response_text.contains(\"item1\"));\n    assert!(response_text.contains(\"value1\"));\n}\n\n#[tokio::test]\nasync fn test_mod_file_with_complex_struct_body_with_rename() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let complex_body = json!({\n        \"name\": \"Test User Renamed\",\n        \"age\": 35,\n        \"nestedStruct\": {\n            \"name\": \"Nested Name Renamed\",\n            \"age\": 30\n        },\n        \"array\": [\"renamed1\", \"renamed2\", \"renamed3\"],\n        \"map\": {\n            \"key1\": \"renamed_value1\",\n            \"key2\": \"renamed_value2\"\n        },\n        \"nestedArray\": [\n            {\n                \"name\": \"Renamed Array Item 1\",\n                \"age\": 25\n            },\n            {\n                \"name\": \"Renamed Array Item 2\",\n                \"age\": 26\n            }\n        ],\n        \"nestedMap\": {\n            \"map_key1\": {\n                \"name\": \"Renamed Map Value 1\",\n                \"age\": 27\n            },\n            \"map_key2\": {\n                \"name\": \"Renamed Map Value 2\",\n                \"age\": 28\n            }\n        },\n        \"nestedStructArray\": [\n            {\n                \"name\": \"Renamed Struct Array 1\",\n                \"age\": 29\n            }\n        ],\n        \"nestedStructMap\": {\n            \"struct_map_key\": {\n                \"name\": \"Renamed Struct Map Value\",\n                \"age\": 31\n            }\n        },\n        \"nestedStructArrayMap\": [\n            {\n                \"array_map_key1\": {\n                    \"name\": \"Renamed Array Map Value 1\",\n                    \"age\": 32\n                },\n                \"array_map_key2\": {\n                    \"name\": \"Renamed Array Map Value 2\",\n                    \"age\": 33\n                }\n            }\n        ],\n        \"nestedStructMapArray\": {\n            \"map_array_key\": [\n                {\n                    \"name\": \"Renamed Map Array Value 1\",\n                    \"age\": 34\n                },\n                {\n                    \"name\": \"Renamed Map Array Value 2\",\n                    \"age\": null\n                }\n            ]\n        }\n    });\n\n    let response = server\n        .post(\"/complex-struct-body-with-rename\")\n        .json(\u0026complex_body)\n        .await;\n\n    response.assert_status_ok();\n    let response_text = response.text();\n\n    assert!(response_text.contains(\"name: Test User Renamed\"));\n    assert!(response_text.contains(\"age: 35\"));\n    assert!(response_text.contains(\"renamed1\"));\n    assert!(response_text.contains(\"renamed_value1\"));\n}\n\n#[tokio::test]\nasync fn test_openapi() {\n    insta::assert_snapshot!(\"openapi\", std::fs::read_to_string(\"openapi.json\").unwrap());\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera","src","lib.rs"],"content":"//! Vespera - OpenAPI generation for Rust web frameworks\r\n//!\r\n//! This crate provides macros and utilities for generating OpenAPI documentation\r\n//! from your route definitions.\r\n\r\n// Re-export vespera_core types so users don't need to depend on vespera_core directly\r\npub mod schema {\r\n    pub use vespera_core::schema::*;\r\n}\r\n\r\npub mod route {\r\n    pub use vespera_core::route::*;\r\n}\r\n\r\npub mod openapi {\r\n    pub use vespera_core::openapi::*;\r\n}\r\n\r\n// Re-export macros from vespera_macro\r\npub use vespera_macro::{Schema, route, vespera};\r\n\r\n// Re-export axum for convenience\r\npub mod axum {\r\n    pub use axum::*;\r\n}\r\n\r\npub mod axum_extra {\r\n    pub use axum_extra::*;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_core","src","lib.rs"],"content":"//! Vespera Core - OpenAPI structure definitions\n//!\n//! Provides structures conforming to the OpenAPI 3.1 specification.\n\npub mod openapi;\npub mod route;\npub mod schema;\n\npub use openapi::*;\npub use route::*;\npub use schema::*;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_core","src","openapi.rs"],"content":"//! OpenAPI document structure definitions\n\nuse crate::route::PathItem;\nuse crate::schema::{Components, ExternalDocumentation};\nuse serde::{Deserialize, Serialize};\nuse std::collections::{BTreeMap, HashMap};\n\n/// OpenAPI document version\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Default)]\npub enum OpenApiVersion {\n    #[serde(rename = \"3.0.0\")]\n    V3_0_0,\n    #[serde(rename = \"3.0.1\")]\n    V3_0_1,\n    #[serde(rename = \"3.0.2\")]\n    V3_0_2,\n    #[serde(rename = \"3.0.3\")]\n    V3_0_3,\n    #[serde(rename = \"3.1.0\")]\n    #[default]\n    V3_1_0,\n}\n\n/// Contact information\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Contact {\n    /// Contact name\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub name: Option\u003cString\u003e,\n    /// Contact URL\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub url: Option\u003cString\u003e,\n    /// Contact email\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub email: Option\u003cString\u003e,\n}\n\n/// License information\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct License {\n    /// License name\n    pub name: String,\n    /// License URL\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub url: Option\u003cString\u003e,\n}\n\n/// API information\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Info {\n    /// API title\n    pub title: String,\n    /// API version\n    pub version: String,\n    /// API description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// Terms of service URL\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub terms_of_service: Option\u003cString\u003e,\n    /// Contact information\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub contact: Option\u003cContact\u003e,\n    /// License information\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub license: Option\u003cLicense\u003e,\n    /// Summary\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub summary: Option\u003cString\u003e,\n}\n\n/// Server variable\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ServerVariable {\n    /// Default value\n    pub default: String,\n    /// Enum values\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub r#enum: Option\u003cVec\u003cString\u003e\u003e,\n    /// Description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n}\n\n/// Server information\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Server {\n    /// Server URL\n    pub url: String,\n    /// Server description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// Server variables\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub variables: Option\u003cHashMap\u003cString, ServerVariable\u003e\u003e,\n}\n\n/// Tag definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Tag {\n    /// Tag name\n    pub name: String,\n    /// Tag description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// External documentation\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub external_docs: Option\u003cExternalDocumentation\u003e,\n}\n\n/// OpenAPI document (root structure)\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct OpenApi {\n    /// OpenAPI version\n    pub openapi: OpenApiVersion,\n    /// API information\n    pub info: Info,\n    /// Server list\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub servers: Option\u003cVec\u003cServer\u003e\u003e,\n    /// Path definitions\n    pub paths: BTreeMap\u003cString, PathItem\u003e,\n    /// Components (reusable components)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub components: Option\u003cComponents\u003e,\n    /// Security requirements\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub security: Option\u003cVec\u003cHashMap\u003cString, Vec\u003cString\u003e\u003e\u003e\u003e,\n    /// Tag definitions\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub tags: Option\u003cVec\u003cTag\u003e\u003e,\n    /// External documentation\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub external_docs: Option\u003cExternalDocumentation\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_core","src","route.rs"],"content":"//! Route-related structure definitions\n\nuse serde::{Deserialize, Serialize};\nuse std::collections::{BTreeMap, HashMap};\n\nuse crate::SchemaRef;\n\n/// HTTP method\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum HttpMethod {\n    Get,\n    Post,\n    Put,\n    Patch,\n    Delete,\n    Head,\n    Options,\n    Trace,\n}\n\nimpl From\u003c\u0026str\u003e for HttpMethod {\n    fn from(value: \u0026str) -\u003e Self {\n        match value.to_uppercase().as_str() {\n            \"GET\" =\u003e HttpMethod::Get,\n            \"POST\" =\u003e HttpMethod::Post,\n            \"PUT\" =\u003e HttpMethod::Put,\n            \"PATCH\" =\u003e HttpMethod::Patch,\n            \"DELETE\" =\u003e HttpMethod::Delete,\n            \"HEAD\" =\u003e HttpMethod::Head,\n            \"OPTIONS\" =\u003e HttpMethod::Options,\n            \"TRACE\" =\u003e HttpMethod::Trace,\n            _ =\u003e HttpMethod::Get, // default value\n        }\n    }\n}\n\n/// Parameter location in the request\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum ParameterLocation {\n    Query,\n    Header,\n    Path,\n    Cookie,\n}\n\n/// Parameter definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Parameter {\n    /// Parameter name\n    pub name: String,\n    /// Parameter location\n    pub r#in: ParameterLocation,\n    /// Parameter description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// Whether the parameter is required\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub required: Option\u003cbool\u003e,\n    /// Schema reference or inline schema\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub schema: Option\u003cSchemaRef\u003e,\n    /// Example value\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub example: Option\u003cserde_json::Value\u003e,\n}\n\n/// Request body definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct RequestBody {\n    /// Request body description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// Whether the request body is required\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub required: Option\u003cbool\u003e,\n    /// Schema per Content-Type\n    pub content: BTreeMap\u003cString, MediaType\u003e,\n}\n\n/// Media type definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct MediaType {\n    /// Schema reference or inline schema\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub schema: Option\u003cSchemaRef\u003e,\n    /// Example\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub example: Option\u003cserde_json::Value\u003e,\n    /// Examples\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub examples: Option\u003cHashMap\u003cString, Example\u003e\u003e,\n}\n\n/// Example definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Example {\n    /// Example summary\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub summary: Option\u003cString\u003e,\n    /// Example description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// Example value\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub value: Option\u003cserde_json::Value\u003e,\n}\n\n/// Response definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Response {\n    /// Response description\n    pub description: String,\n    /// Header definitions\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub headers: Option\u003cHashMap\u003cString, Header\u003e\u003e,\n    /// Schema per Content-Type\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub content: Option\u003cBTreeMap\u003cString, MediaType\u003e\u003e,\n}\n\n/// Header definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Header {\n    /// Header description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// Schema reference or inline schema\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub schema: Option\u003cSchemaRef\u003e,\n}\n\n/// OpenAPI Operation definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Operation {\n    /// Operation ID (unique identifier)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub operation_id: Option\u003cString\u003e,\n    /// List of tags\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub tags: Option\u003cVec\u003cString\u003e\u003e,\n    /// Summary\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub summary: Option\u003cString\u003e,\n    /// Description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// List of parameters\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub parameters: Option\u003cVec\u003cParameter\u003e\u003e,\n    /// Request body\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub request_body: Option\u003cRequestBody\u003e,\n    /// Response definitions (status code -\u003e Response)\n    pub responses: BTreeMap\u003cString, Response\u003e,\n    /// Security requirements\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub security: Option\u003cVec\u003cHashMap\u003cString, Vec\u003cString\u003e\u003e\u003e\u003e,\n}\n\n/// Path Item definition (all HTTP methods for a specific path)\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct PathItem {\n    /// GET method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub get: Option\u003cOperation\u003e,\n    /// POST method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub post: Option\u003cOperation\u003e,\n    /// PUT method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub put: Option\u003cOperation\u003e,\n    /// PATCH method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub patch: Option\u003cOperation\u003e,\n    /// DELETE method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub delete: Option\u003cOperation\u003e,\n    /// HEAD method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub head: Option\u003cOperation\u003e,\n    /// OPTIONS method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub options: Option\u003cOperation\u003e,\n    /// TRACE method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub trace: Option\u003cOperation\u003e,\n    /// Path parameters\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub parameters: Option\u003cVec\u003cParameter\u003e\u003e,\n    /// Summary\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub summary: Option\u003cString\u003e,\n    /// Description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n}\n\nimpl PathItem {\n    /// Set an operation for a specific HTTP method\n    pub fn set_operation(\u0026mut self, method: HttpMethod, operation: Operation) {\n        match method {\n            HttpMethod::Get =\u003e self.get = Some(operation),\n            HttpMethod::Post =\u003e self.post = Some(operation),\n            HttpMethod::Put =\u003e self.put = Some(operation),\n            HttpMethod::Patch =\u003e self.patch = Some(operation),\n            HttpMethod::Delete =\u003e self.delete = Some(operation),\n            HttpMethod::Head =\u003e self.head = Some(operation),\n            HttpMethod::Options =\u003e self.options = Some(operation),\n            HttpMethod::Trace =\u003e self.trace = Some(operation),\n        }\n    }\n\n    /// Get an operation for a specific HTTP method\n    pub fn get_operation(\u0026self, method: \u0026HttpMethod) -\u003e Option\u003c\u0026Operation\u003e {\n        match method {\n            HttpMethod::Get =\u003e self.get.as_ref(),\n            HttpMethod::Post =\u003e self.post.as_ref(),\n            HttpMethod::Put =\u003e self.put.as_ref(),\n            HttpMethod::Patch =\u003e self.patch.as_ref(),\n            HttpMethod::Delete =\u003e self.delete.as_ref(),\n            HttpMethod::Head =\u003e self.head.as_ref(),\n            HttpMethod::Options =\u003e self.options.as_ref(),\n            HttpMethod::Trace =\u003e self.trace.as_ref(),\n        }\n    }\n}\n\n/// Route information (for internal use)\n#[derive(Debug, Clone)]\npub struct RouteInfo {\n    /// HTTP method\n    pub method: HttpMethod,\n    /// Path\n    pub path: String,\n    /// Operation information\n    pub operation: Operation,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rstest::rstest;\n\n    #[rstest]\n    #[case(\"GET\", HttpMethod::Get)]\n    #[case(\"get\", HttpMethod::Get)]\n    #[case(\"Get\", HttpMethod::Get)]\n    #[case(\"POST\", HttpMethod::Post)]\n    #[case(\"post\", HttpMethod::Post)]\n    #[case(\"Post\", HttpMethod::Post)]\n    #[case(\"PUT\", HttpMethod::Put)]\n    #[case(\"put\", HttpMethod::Put)]\n    #[case(\"Put\", HttpMethod::Put)]\n    #[case(\"PATCH\", HttpMethod::Patch)]\n    #[case(\"patch\", HttpMethod::Patch)]\n    #[case(\"Patch\", HttpMethod::Patch)]\n    #[case(\"DELETE\", HttpMethod::Delete)]\n    #[case(\"delete\", HttpMethod::Delete)]\n    #[case(\"Delete\", HttpMethod::Delete)]\n    #[case(\"HEAD\", HttpMethod::Head)]\n    #[case(\"head\", HttpMethod::Head)]\n    #[case(\"Head\", HttpMethod::Head)]\n    #[case(\"OPTIONS\", HttpMethod::Options)]\n    #[case(\"options\", HttpMethod::Options)]\n    #[case(\"Options\", HttpMethod::Options)]\n    #[case(\"TRACE\", HttpMethod::Trace)]\n    #[case(\"trace\", HttpMethod::Trace)]\n    #[case(\"Trace\", HttpMethod::Trace)]\n    fn test_http_method_from_str(#[case] input: \u0026str, #[case] expected: HttpMethod) {\n        let result = HttpMethod::from(input);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_http_method_from_invalid_str() {\n        // Invalid method should default to Get\n        let result = HttpMethod::from(\"INVALID\");\n        assert_eq!(result, HttpMethod::Get);\n    }\n\n    #[test]\n    fn test_http_method_serialization() {\n        // Test serde serialization (should be UPPERCASE)\n        let method = HttpMethod::Get;\n        let serialized = serde_json::to_string(\u0026method).unwrap();\n        assert_eq!(serialized, \"\\\"GET\\\"\");\n\n        let method = HttpMethod::Post;\n        let serialized = serde_json::to_string(\u0026method).unwrap();\n        assert_eq!(serialized, \"\\\"POST\\\"\");\n\n        let method = HttpMethod::Delete;\n        let serialized = serde_json::to_string(\u0026method).unwrap();\n        assert_eq!(serialized, \"\\\"DELETE\\\"\");\n    }\n\n    #[test]\n    fn test_http_method_deserialization() {\n        // Test serde deserialization\n        let method: HttpMethod = serde_json::from_str(\"\\\"GET\\\"\").unwrap();\n        assert_eq!(method, HttpMethod::Get);\n\n        let method: HttpMethod = serde_json::from_str(\"\\\"POST\\\"\").unwrap();\n        assert_eq!(method, HttpMethod::Post);\n\n        let method: HttpMethod = serde_json::from_str(\"\\\"DELETE\\\"\").unwrap();\n        assert_eq!(method, HttpMethod::Delete);\n    }\n\n    #[test]\n    fn test_path_item_set_operation() {\n        let mut path_item = PathItem {\n            get: None,\n            post: None,\n            put: None,\n            patch: None,\n            delete: None,\n            head: None,\n            options: None,\n            trace: None,\n            parameters: None,\n            summary: None,\n            description: None,\n        };\n\n        let operation = Operation {\n            operation_id: Some(\"test_operation\".to_string()),\n            tags: None,\n            summary: None,\n            description: None,\n            parameters: None,\n            request_body: None,\n            responses: BTreeMap::new(),\n            security: None,\n        };\n\n        // Test setting GET operation\n        path_item.set_operation(HttpMethod::Get, operation.clone());\n        assert!(path_item.get.is_some());\n        assert_eq!(\n            path_item.get.as_ref().unwrap().operation_id,\n            Some(\"test_operation\".to_string())\n        );\n\n        // Test setting POST operation\n        let mut operation_post = operation.clone();\n        operation_post.operation_id = Some(\"post_operation\".to_string());\n        path_item.set_operation(HttpMethod::Post, operation_post);\n        assert!(path_item.post.is_some());\n        assert_eq!(\n            path_item.post.as_ref().unwrap().operation_id,\n            Some(\"post_operation\".to_string())\n        );\n\n        // Test setting PUT operation\n        let mut operation_put = operation.clone();\n        operation_put.operation_id = Some(\"put_operation\".to_string());\n        path_item.set_operation(HttpMethod::Put, operation_put);\n        assert!(path_item.put.is_some());\n\n        // Test setting PATCH operation\n        let mut operation_patch = operation.clone();\n        operation_patch.operation_id = Some(\"patch_operation\".to_string());\n        path_item.set_operation(HttpMethod::Patch, operation_patch);\n        assert!(path_item.patch.is_some());\n\n        // Test setting DELETE operation\n        let mut operation_delete = operation.clone();\n        operation_delete.operation_id = Some(\"delete_operation\".to_string());\n        path_item.set_operation(HttpMethod::Delete, operation_delete);\n        assert!(path_item.delete.is_some());\n\n        // Test setting HEAD operation\n        let mut operation_head = operation.clone();\n        operation_head.operation_id = Some(\"head_operation\".to_string());\n        path_item.set_operation(HttpMethod::Head, operation_head);\n        assert!(path_item.head.is_some());\n\n        // Test setting OPTIONS operation\n        let mut operation_options = operation.clone();\n        operation_options.operation_id = Some(\"options_operation\".to_string());\n        path_item.set_operation(HttpMethod::Options, operation_options);\n        assert!(path_item.options.is_some());\n\n        // Test setting TRACE operation\n        let mut operation_trace = operation;\n        operation_trace.operation_id = Some(\"trace_operation\".to_string());\n        path_item.set_operation(HttpMethod::Trace, operation_trace);\n        assert!(path_item.trace.is_some());\n    }\n\n    #[test]\n    fn test_path_item_get_operation() {\n        let mut path_item = PathItem {\n            get: None,\n            post: None,\n            put: None,\n            patch: None,\n            delete: None,\n            head: None,\n            options: None,\n            trace: None,\n            parameters: None,\n            summary: None,\n            description: None,\n        };\n\n        let operation = Operation {\n            operation_id: Some(\"test_operation\".to_string()),\n            tags: None,\n            summary: None,\n            description: None,\n            parameters: None,\n            request_body: None,\n            responses: BTreeMap::new(),\n            security: None,\n        };\n\n        // Initially, all operations should be None\n        assert!(path_item.get_operation(\u0026HttpMethod::Get).is_none());\n        assert!(path_item.get_operation(\u0026HttpMethod::Post).is_none());\n\n        // Set GET operation\n        path_item.set_operation(HttpMethod::Get, operation.clone());\n        let retrieved = path_item.get_operation(\u0026HttpMethod::Get);\n        assert!(retrieved.is_some());\n        assert_eq!(\n            retrieved.unwrap().operation_id,\n            Some(\"test_operation\".to_string())\n        );\n\n        // Set POST operation\n        let mut operation_post = operation.clone();\n        operation_post.operation_id = Some(\"post_operation\".to_string());\n        path_item.set_operation(HttpMethod::Post, operation_post);\n        let retrieved = path_item.get_operation(\u0026HttpMethod::Post);\n        assert!(retrieved.is_some());\n        assert_eq!(\n            retrieved.unwrap().operation_id,\n            Some(\"post_operation\".to_string())\n        );\n\n        // Test all methods\n        path_item.set_operation(HttpMethod::Put, operation.clone());\n        assert!(path_item.get_operation(\u0026HttpMethod::Put).is_some());\n\n        path_item.set_operation(HttpMethod::Patch, operation.clone());\n        assert!(path_item.get_operation(\u0026HttpMethod::Patch).is_some());\n\n        path_item.set_operation(HttpMethod::Delete, operation.clone());\n        assert!(path_item.get_operation(\u0026HttpMethod::Delete).is_some());\n\n        path_item.set_operation(HttpMethod::Head, operation.clone());\n        assert!(path_item.get_operation(\u0026HttpMethod::Head).is_some());\n\n        path_item.set_operation(HttpMethod::Options, operation.clone());\n        assert!(path_item.get_operation(\u0026HttpMethod::Options).is_some());\n\n        path_item.set_operation(HttpMethod::Trace, operation);\n        assert!(path_item.get_operation(\u0026HttpMethod::Trace).is_some());\n    }\n\n    #[test]\n    fn test_path_item_set_operation_overwrites() {\n        let mut path_item = PathItem {\n            get: None,\n            post: None,\n            put: None,\n            patch: None,\n            delete: None,\n            head: None,\n            options: None,\n            trace: None,\n            parameters: None,\n            summary: None,\n            description: None,\n        };\n\n        let operation1 = Operation {\n            operation_id: Some(\"first\".to_string()),\n            tags: None,\n            summary: None,\n            description: None,\n            parameters: None,\n            request_body: None,\n            responses: BTreeMap::new(),\n            security: None,\n        };\n\n        let operation2 = Operation {\n            operation_id: Some(\"second\".to_string()),\n            tags: None,\n            summary: None,\n            description: None,\n            parameters: None,\n            request_body: None,\n            responses: BTreeMap::new(),\n            security: None,\n        };\n\n        // Set first operation\n        path_item.set_operation(HttpMethod::Get, operation1);\n        assert_eq!(\n            path_item.get.as_ref().unwrap().operation_id,\n            Some(\"first\".to_string())\n        );\n\n        // Overwrite with second operation\n        path_item.set_operation(HttpMethod::Get, operation2);\n        assert_eq!(\n            path_item.get.as_ref().unwrap().operation_id,\n            Some(\"second\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_http_method_equality() {\n        let method1 = HttpMethod::Get;\n        let method2 = HttpMethod::Get;\n        let method3 = HttpMethod::Post;\n\n        assert_eq!(method1, method2);\n        assert_ne!(method1, method3);\n    }\n\n    #[test]\n    fn test_http_method_clone() {\n        let method = HttpMethod::Get;\n        let cloned = method.clone();\n        assert_eq!(method, cloned);\n    }\n\n    #[test]\n    fn test_http_method_hash() {\n        use std::collections::HashMap;\n\n        let mut map = HashMap::new();\n        map.insert(HttpMethod::Get, \"GET method\");\n        map.insert(HttpMethod::Post, \"POST method\");\n\n        assert_eq!(map.get(\u0026HttpMethod::Get), Some(\u0026\"GET method\"));\n        assert_eq!(map.get(\u0026HttpMethod::Post), Some(\u0026\"POST method\"));\n        assert_eq!(map.get(\u0026HttpMethod::Put), None);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":24,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":25,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":26,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":27,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":28,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":29,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":30,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":31,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":32,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":210,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":211,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":212,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":213,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":214,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":215,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":216,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":217,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":218,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":219,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":224,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":225,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":226,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":227,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":228,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":229,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":230,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":231,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":232,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":233,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":31,"coverable":31},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_core","src","schema.rs"],"content":"//! Schema-related structure definitions\r\n\r\nuse serde::{Deserialize, Serialize};\r\nuse std::collections::{BTreeMap, HashMap};\r\n\r\n/// Schema reference or inline schema\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(untagged)]\r\npub enum SchemaRef {\r\n    /// Schema reference (e.g., \"#/components/schemas/User\")\r\n    Ref(Reference),\r\n    /// Inline schema\r\n    Inline(Box\u003cSchema\u003e),\r\n}\r\n\r\n/// Reference definition\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Reference {\r\n    /// Reference path (e.g., \"#/components/schemas/User\")\r\n    #[serde(rename = \"$ref\")]\r\n    pub ref_path: String,\r\n}\r\n\r\nimpl Reference {\r\n    /// Create a new reference\r\n    pub fn new(ref_path: String) -\u003e Self {\r\n        Self { ref_path }\r\n    }\r\n\r\n    /// Create a component schema reference\r\n    pub fn schema(name: \u0026str) -\u003e Self {\r\n        Reference::new(format!(\"#/components/schemas/{}\", name))\r\n    }\r\n}\r\n\r\n/// JSON Schema type\r\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\r\n#[serde(rename_all = \"lowercase\")]\r\npub enum SchemaType {\r\n    String,\r\n    Number,\r\n    Integer,\r\n    Boolean,\r\n    Array,\r\n    Object,\r\n    Null,\r\n}\r\n\r\n/// Number format\r\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\r\n#[serde(rename_all = \"lowercase\")]\r\npub enum NumberFormat {\r\n    Float,\r\n    Double,\r\n    Int32,\r\n    Int64,\r\n}\r\n\r\n/// String format\r\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\r\n#[serde(rename_all = \"lowercase\")]\r\npub enum StringFormat {\r\n    Date,\r\n    DateTime,\r\n    Password,\r\n    Byte,\r\n    Binary,\r\n    Email,\r\n    Uuid,\r\n    Uri,\r\n    Hostname,\r\n    IpV4,\r\n    IpV6,\r\n}\r\n\r\n/// JSON Schema definition\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct Schema {\r\n    /// Schema reference ($ref) - if present, other fields are ignored\r\n    #[serde(rename = \"$ref\")]\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub ref_path: Option\u003cString\u003e,\r\n    /// Schema type\r\n    #[serde(rename = \"type\")]\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub schema_type: Option\u003cSchemaType\u003e,\r\n    /// Format (for numbers or strings)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub format: Option\u003cString\u003e,\r\n    /// Title\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub title: Option\u003cString\u003e,\r\n    /// Description\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub description: Option\u003cString\u003e,\r\n    /// Default value\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub default: Option\u003cserde_json::Value\u003e,\r\n    /// Example\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub example: Option\u003cserde_json::Value\u003e,\r\n    /// Examples\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub examples: Option\u003cVec\u003cserde_json::Value\u003e\u003e,\r\n\r\n    // Number constraints\r\n    /// Minimum value\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub minimum: Option\u003cf64\u003e,\r\n    /// Maximum value\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub maximum: Option\u003cf64\u003e,\r\n    /// Exclusive minimum\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub exclusive_minimum: Option\u003cbool\u003e,\r\n    /// Exclusive maximum\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub exclusive_maximum: Option\u003cbool\u003e,\r\n    /// Multiple of\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub multiple_of: Option\u003cf64\u003e,\r\n\r\n    // String constraints\r\n    /// Minimum length\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub min_length: Option\u003cusize\u003e,\r\n    /// Maximum length\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub max_length: Option\u003cusize\u003e,\r\n    /// Pattern (regex)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub pattern: Option\u003cString\u003e,\r\n\r\n    // Array constraints\r\n    /// Array item schema\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub items: Option\u003cBox\u003cSchemaRef\u003e\u003e,\r\n    /// Prefix items for tuple arrays (OpenAPI 3.1 / JSON Schema 2020-12)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub prefix_items: Option\u003cVec\u003cSchemaRef\u003e\u003e,\r\n    /// Minimum number of items\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub min_items: Option\u003cusize\u003e,\r\n    /// Maximum number of items\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub max_items: Option\u003cusize\u003e,\r\n    /// Unique items flag\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub unique_items: Option\u003cbool\u003e,\r\n\r\n    // Object constraints\r\n    /// Property definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub properties: Option\u003cBTreeMap\u003cString, SchemaRef\u003e\u003e,\r\n    /// List of required properties\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub required: Option\u003cVec\u003cString\u003e\u003e,\r\n    /// Whether additional properties are allowed (can be boolean or SchemaRef)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub additional_properties: Option\u003cserde_json::Value\u003e,\r\n    /// Minimum number of properties\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub min_properties: Option\u003cusize\u003e,\r\n    /// Maximum number of properties\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub max_properties: Option\u003cusize\u003e,\r\n\r\n    // General constraints\r\n    /// Enum values\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub r#enum: Option\u003cVec\u003cserde_json::Value\u003e\u003e,\r\n    /// All conditions must be satisfied (AND)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub all_of: Option\u003cVec\u003cSchemaRef\u003e\u003e,\r\n    /// At least one condition must be satisfied (OR)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub any_of: Option\u003cVec\u003cSchemaRef\u003e\u003e,\r\n    /// Exactly one condition must be satisfied (XOR)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub one_of: Option\u003cVec\u003cSchemaRef\u003e\u003e,\r\n    /// Condition must not be satisfied (NOT)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub not: Option\u003cBox\u003cSchemaRef\u003e\u003e,\r\n\r\n    /// Nullable flag\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub nullable: Option\u003cbool\u003e,\r\n    /// Read-only flag\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub read_only: Option\u003cbool\u003e,\r\n    /// Write-only flag\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub write_only: Option\u003cbool\u003e,\r\n    /// External documentation reference\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub external_docs: Option\u003cExternalDocumentation\u003e,\r\n\r\n    // JSON Schema 2020-12 dynamic references\r\n    /// Definitions ($defs) - reusable schema definitions\r\n    #[serde(rename = \"$defs\")]\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub defs: Option\u003cBTreeMap\u003cString, Schema\u003e\u003e,\r\n    /// Dynamic anchor ($dynamicAnchor) - defines a dynamic anchor\r\n    #[serde(rename = \"$dynamicAnchor\")]\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub dynamic_anchor: Option\u003cString\u003e,\r\n    /// Dynamic reference ($dynamicRef) - references a dynamic anchor\r\n    #[serde(rename = \"$dynamicRef\")]\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub dynamic_ref: Option\u003cString\u003e,\r\n}\r\n\r\nimpl Schema {\r\n    /// Create a new schema\r\n    pub fn new(schema_type: SchemaType) -\u003e Self {\r\n        Self {\r\n            ref_path: None,\r\n            schema_type: Some(schema_type),\r\n            format: None,\r\n            title: None,\r\n            description: None,\r\n            default: None,\r\n            example: None,\r\n            examples: None,\r\n            minimum: None,\r\n            maximum: None,\r\n            exclusive_minimum: None,\r\n            exclusive_maximum: None,\r\n            multiple_of: None,\r\n            min_length: None,\r\n            max_length: None,\r\n            pattern: None,\r\n            items: None,\r\n            prefix_items: None,\r\n            min_items: None,\r\n            max_items: None,\r\n            unique_items: None,\r\n            properties: None,\r\n            required: None,\r\n            additional_properties: None,\r\n            min_properties: None,\r\n            max_properties: None,\r\n            r#enum: None,\r\n            all_of: None,\r\n            any_of: None,\r\n            one_of: None,\r\n            not: None,\r\n            nullable: None,\r\n            read_only: None,\r\n            write_only: None,\r\n            external_docs: None,\r\n            defs: None,\r\n            dynamic_anchor: None,\r\n            dynamic_ref: None,\r\n        }\r\n    }\r\n\r\n    /// Create a string schema\r\n    pub fn string() -\u003e Self {\r\n        Self::new(SchemaType::String)\r\n    }\r\n\r\n    /// Create an integer schema\r\n    pub fn integer() -\u003e Self {\r\n        Self::new(SchemaType::Integer)\r\n    }\r\n\r\n    /// Create a number schema\r\n    pub fn number() -\u003e Self {\r\n        Self::new(SchemaType::Number)\r\n    }\r\n\r\n    /// Create a boolean schema\r\n    pub fn boolean() -\u003e Self {\r\n        Self::new(SchemaType::Boolean)\r\n    }\r\n\r\n    /// Create an array schema\r\n    pub fn array(items: SchemaRef) -\u003e Self {\r\n        Self {\r\n            items: Some(Box::new(items)),\r\n            ..Self::new(SchemaType::Array)\r\n        }\r\n    }\r\n\r\n    /// Create an object schema\r\n    pub fn object() -\u003e Self {\r\n        Self {\r\n            properties: Some(BTreeMap::new()),\r\n            required: Some(Vec::new()),\r\n            ..Self::new(SchemaType::Object)\r\n        }\r\n    }\r\n}\r\n\r\n/// External documentation reference\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct ExternalDocumentation {\r\n    /// Documentation description\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub description: Option\u003cString\u003e,\r\n    /// Documentation URL\r\n    pub url: String,\r\n}\r\n\r\n/// OpenAPI Components (reusable components)\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct Components {\r\n    /// Schema definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub schemas: Option\u003cBTreeMap\u003cString, Schema\u003e\u003e,\r\n    /// Response definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub responses: Option\u003cHashMap\u003cString, crate::route::Response\u003e\u003e,\r\n    /// Parameter definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub parameters: Option\u003cHashMap\u003cString, crate::route::Parameter\u003e\u003e,\r\n    /// Example definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub examples: Option\u003cHashMap\u003cString, crate::route::Example\u003e\u003e,\r\n    /// Request body definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub request_bodies: Option\u003cHashMap\u003cString, crate::route::RequestBody\u003e\u003e,\r\n    /// Header definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub headers: Option\u003cHashMap\u003cString, crate::route::Header\u003e\u003e,\r\n    /// Security scheme definitions\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub security_schemes: Option\u003cHashMap\u003cString, SecurityScheme\u003e\u003e,\r\n}\r\n\r\n/// Security scheme type\r\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub enum SecuritySchemeType {\r\n    ApiKey,\r\n    Http,\r\n    MutualTls,\r\n    OAuth2,\r\n    OpenIdConnect,\r\n}\r\n\r\n/// Security scheme definition\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct SecurityScheme {\r\n    /// Security scheme type\r\n    pub r#type: SecuritySchemeType,\r\n    /// Description\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub description: Option\u003cString\u003e,\r\n    /// Name (for API Key)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub name: Option\u003cString\u003e,\r\n    /// Location (for API Key: query, header, cookie)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub r#in: Option\u003cString\u003e,\r\n    /// Scheme (for HTTP: bearer, basic, etc.)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub scheme: Option\u003cString\u003e,\r\n    /// Bearer format (for HTTP Bearer)\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub bearer_format: Option\u003cString\u003e,\r\n}\r\n\r\n/// Builder trait for types that can be converted to OpenAPI Schema\r\npub trait SchemaBuilder: Sized {\r\n    // This trait is used as a marker for derive macro\r\n    // The actual schema conversion will be implemented separately\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use rstest::rstest;\r\n\r\n    #[rstest]\r\n    #[case(Schema::string(), SchemaType::String)]\r\n    #[case(Schema::integer(), SchemaType::Integer)]\r\n    #[case(Schema::number(), SchemaType::Number)]\r\n    #[case(Schema::boolean(), SchemaType::Boolean)]\r\n    fn primitive_helpers_set_schema_type(#[case] schema: Schema, #[case] expected: SchemaType) {\r\n        assert_eq!(schema.schema_type, Some(expected));\r\n    }\r\n\r\n    #[test]\r\n    fn array_helper_sets_type_and_items() {\r\n        let item_schema = Schema::boolean();\r\n        let schema = Schema::array(SchemaRef::Inline(Box::new(item_schema.clone())));\r\n\r\n        assert_eq!(schema.schema_type, Some(SchemaType::Array));\r\n        let items = schema.items.expect(\"items should be set\");\r\n        match *items {\r\n            SchemaRef::Inline(inner) =\u003e {\r\n                assert_eq!(inner.schema_type, Some(SchemaType::Boolean));\r\n            }\r\n            SchemaRef::Ref(_) =\u003e panic!(\"array helper should set inline items\"),\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn object_helper_initializes_collections() {\r\n        let schema = Schema::object();\r\n\r\n        assert_eq!(schema.schema_type, Some(SchemaType::Object));\r\n        let props = schema.properties.expect(\"properties should be initialized\");\r\n        assert!(props.is_empty());\r\n        let required = schema.required.expect(\"required should be initialized\");\r\n        assert!(required.is_empty());\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":31,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":32,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":216,"address":[],"length":0,"stats":{"Line":11096869481840902144}},{"line":219,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":260,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":261,"address":[],"length":0,"stats":{"Line":10952754293765046272}},{"line":265,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":266,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":270,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":271,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":275,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":276,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":280,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":282,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":288,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":290,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":291,"address":[],"length":0,"stats":{"Line":3602879701896396800}}],"covered":18,"coverable":18},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","args.rs"],"content":"pub struct RouteArgs {\r\n    pub method: Option\u003csyn::Ident\u003e,\r\n    pub path: Option\u003csyn::LitStr\u003e,\r\n    pub error_status: Option\u003csyn::ExprArray\u003e,\r\n    pub tags: Option\u003csyn::ExprArray\u003e,\r\n    pub description: Option\u003csyn::LitStr\u003e,\r\n}\r\n\r\nimpl syn::parse::Parse for RouteArgs {\r\n    fn parse(input: syn::parse::ParseStream) -\u003e syn::Result\u003cSelf\u003e {\r\n        let mut method: Option\u003csyn::Ident\u003e = None;\r\n        let mut path: Option\u003csyn::LitStr\u003e = None;\r\n        let mut error_status: Option\u003csyn::ExprArray\u003e = None;\r\n        let mut tags: Option\u003csyn::ExprArray\u003e = None;\r\n        let mut description: Option\u003csyn::LitStr\u003e = None;\r\n\r\n        // Parse comma-separated list of arguments\r\n        while !input.is_empty() {\r\n            let lookahead = input.lookahead1();\r\n\r\n            if lookahead.peek(syn::Ident) {\r\n                // Try to parse as method identifier (get, post, etc.)\r\n                let ident: syn::Ident = input.parse()?;\r\n                let ident_str = ident.to_string().to_lowercase();\r\n                match ident_str.as_str() {\r\n                    \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\" | \"head\" | \"options\" =\u003e {\r\n                        method = Some(ident);\r\n                    }\r\n                    \"path\" =\u003e {\r\n                        input.parse::\u003csyn::Token![=]\u003e()?;\r\n                        let lit: syn::LitStr = input.parse()?;\r\n                        path = Some(lit);\r\n                    }\r\n                    \"error_status\" =\u003e {\r\n                        input.parse::\u003csyn::Token![=]\u003e()?;\r\n                        let array: syn::ExprArray = input.parse()?;\r\n                        error_status = Some(array);\r\n                    }\r\n                    \"tags\" =\u003e {\r\n                        input.parse::\u003csyn::Token![=]\u003e()?;\r\n                        let array: syn::ExprArray = input.parse()?;\r\n                        tags = Some(array);\r\n                    }\r\n                    \"description\" =\u003e {\r\n                        input.parse::\u003csyn::Token![=]\u003e()?;\r\n                        let lit: syn::LitStr = input.parse()?;\r\n                        description = Some(lit);\r\n                    }\r\n                    _ =\u003e {\r\n                        return Err(lookahead.error());\r\n                    }\r\n                }\r\n\r\n                // Check if there's a comma\r\n                if input.peek(syn::Token![,]) {\r\n                    input.parse::\u003csyn::Token![,]\u003e()?;\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                return Err(lookahead.error());\r\n            }\r\n        }\r\n\r\n        Ok(RouteArgs {\r\n            method,\r\n            path,\r\n            error_status,\r\n            tags,\r\n            description,\r\n        })\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use rstest::rstest;\r\n\r\n    #[rstest]\r\n    // Method only\r\n    #[case(\"get\", true, Some(\"get\"), None, None)]\r\n    #[case(\"post\", true, Some(\"post\"), None, None)]\r\n    #[case(\"put\", true, Some(\"put\"), None, None)]\r\n    #[case(\"patch\", true, Some(\"patch\"), None, None)]\r\n    #[case(\"delete\", true, Some(\"delete\"), None, None)]\r\n    #[case(\"head\", true, Some(\"head\"), None, None)]\r\n    #[case(\"options\", true, Some(\"options\"), None, None)]\r\n    // Path only\r\n    #[case(\"path = \\\"/api\\\"\", true, None, Some(\"/api\"), None)]\r\n    #[case(\"path = \\\"/users\\\"\", true, None, Some(\"/users\"), None)]\r\n    #[case(\"path = \\\"/api/v1\\\"\", true, None, Some(\"/api/v1\"), None)]\r\n    // Method and path\r\n    #[case(\"get, path = \\\"/api\\\"\", true, Some(\"get\"), Some(\"/api\"), None)]\r\n    #[case(\"post, path = \\\"/users\\\"\", true, Some(\"post\"), Some(\"/users\"), None)]\r\n    #[case(\"path = \\\"/api\\\", get\", true, Some(\"get\"), Some(\"/api\"), None)]\r\n    // Error status only\r\n    #[case(\"error_status = [400]\", true, None, None, Some(vec![400]))]\r\n    #[case(\"error_status = [400, 404]\", true, None, None, Some(vec![400, 404]))]\r\n    #[case(\"error_status = [400, 404, 500]\", true, None, None, Some(vec![400, 404, 500]))]\r\n    // Method and error_status\r\n    #[case(\"get, error_status = [400]\", true, Some(\"get\"), None, Some(vec![400]))]\r\n    #[case(\"post, error_status = [400, 404]\", true, Some(\"post\"), None, Some(vec![400, 404]))]\r\n    // Path and error_status\r\n    #[case(\"path = \\\"/api\\\", error_status = [400]\", true, None, Some(\"/api\"), Some(vec![400]))]\r\n    // All three\r\n    #[case(\"get, path = \\\"/api\\\", error_status = [400]\", true, Some(\"get\"), Some(\"/api\"), Some(vec![400]))]\r\n    #[case(\"post, path = \\\"/users\\\", error_status = [400, 404]\", true, Some(\"post\"), Some(\"/users\"), Some(vec![400, 404]))]\r\n    #[case(\"path = \\\"/api\\\", get, error_status = [400]\", true, Some(\"get\"), Some(\"/api\"), Some(vec![400]))]\r\n    // Empty input\r\n    #[case(\"\", true, None, None, None)]\r\n    // Invalid cases\r\n    #[case(\"invalid\", false, None, None, None)]\r\n    #[case(\"path\", false, None, None, None)]\r\n    #[case(\"error_status\", false, None, None, None)]\r\n    #[case(\"get, invalid\", false, None, None, None)]\r\n    #[case(\"path =\", false, None, None, None)]\r\n    #[case(\"error_status =\", false, None, None, None)]\r\n    // Non-Ident tokens (should trigger line 40)\r\n    #[case(\"123\", false, None, None, None)]\r\n    #[case(\"\\\"string\\\"\", false, None, None, None)]\r\n    #[case(\"=\", false, None, None, None)]\r\n    #[case(\"[\", false, None, None, None)]\r\n    #[case(\"]\", false, None, None, None)]\r\n    #[case(\",\", false, None, None, None)]\r\n    #[case(\"get, 123\", false, None, None, None)]\r\n    #[case(\"get, =\", false, None, None, None)]\r\n    fn test_route_args_parse(\r\n        #[case] input: \u0026str,\r\n        #[case] should_parse: bool,\r\n        #[case] expected_method: Option\u003c\u0026str\u003e,\r\n        #[case] expected_path: Option\u003c\u0026str\u003e,\r\n        #[case] expected_error_status: Option\u003cVec\u003cu16\u003e\u003e,\r\n    ) {\r\n        let result = syn::parse_str::\u003cRouteArgs\u003e(input);\r\n\r\n        match (should_parse, result) {\r\n            (true, Ok(route_args)) =\u003e {\r\n                // Check method\r\n                if let Some(exp_method) = expected_method {\r\n                    assert!(\r\n                        route_args.method.is_some(),\r\n                        \"Expected method {} but got None for input: {}\",\r\n                        exp_method,\r\n                        input\r\n                    );\r\n                    assert_eq!(\r\n                        route_args.method.as_ref().unwrap().to_string(),\r\n                        exp_method,\r\n                        \"Method mismatch for input: {}\",\r\n                        input\r\n                    );\r\n                } else {\r\n                    assert!(\r\n                        route_args.method.is_none(),\r\n                        \"Expected no method but got {:?} for input: {}\",\r\n                        route_args.method,\r\n                        input\r\n                    );\r\n                }\r\n\r\n                // Check path\r\n                if let Some(exp_path) = expected_path {\r\n                    assert!(\r\n                        route_args.path.is_some(),\r\n                        \"Expected path {} but got None for input: {}\",\r\n                        exp_path,\r\n                        input\r\n                    );\r\n                    assert_eq!(\r\n                        route_args.path.as_ref().unwrap().value(),\r\n                        exp_path,\r\n                        \"Path mismatch for input: {}\",\r\n                        input\r\n                    );\r\n                } else {\r\n                    assert!(\r\n                        route_args.path.is_none(),\r\n                        \"Expected no path but got {:?} for input: {}\",\r\n                        route_args.path,\r\n                        input\r\n                    );\r\n                }\r\n\r\n                // Check error_status\r\n                if let Some(exp_status) = expected_error_status {\r\n                    assert!(\r\n                        route_args.error_status.is_some(),\r\n                        \"Expected error_status {:?} but got None for input: {}\",\r\n                        exp_status,\r\n                        input\r\n                    );\r\n                    let array = route_args.error_status.as_ref().unwrap();\r\n                    let mut status_codes = Vec::new();\r\n                    for elem in \u0026array.elems {\r\n                        if let syn::Expr::Lit(syn::ExprLit {\r\n                            lit: syn::Lit::Int(lit_int),\r\n                            ..\r\n                        }) = elem\r\n                            \u0026\u0026 let Ok(code) = lit_int.base10_parse::\u003cu16\u003e()\r\n                        {\r\n                            status_codes.push(code);\r\n                        }\r\n                    }\r\n                    assert_eq!(\r\n                        status_codes, exp_status,\r\n                        \"Error status mismatch for input: {}\",\r\n                        input\r\n                    );\r\n                } else {\r\n                    assert!(\r\n                        route_args.error_status.is_none(),\r\n                        \"Expected no error_status but got {:?} for input: {}\",\r\n                        route_args.error_status,\r\n                        input\r\n                    );\r\n                }\r\n            }\r\n            (false, Err(_)) =\u003e {\r\n                // Expected error, test passes\r\n            }\r\n            (true, Err(e)) =\u003e {\r\n                panic!(\r\n                    \"Expected successful parse but got error: {} for input: {}\",\r\n                    e, input\r\n                );\r\n            }\r\n            (false, Ok(_)) =\u003e {\r\n                panic!(\"Expected parse error but got success for input: {}\", input);\r\n            }\r\n        }\r\n    }\r\n\r\n    #[rstest]\r\n    // Tags only\r\n    #[case(\"tags = [\\\"users\\\"]\", true, vec![\"users\"])]\r\n    #[case(\"tags = [\\\"users\\\", \\\"admin\\\"]\", true, vec![\"users\", \"admin\"])]\r\n    #[case(\"tags = [\\\"api\\\", \\\"v1\\\", \\\"users\\\"]\", true, vec![\"api\", \"v1\", \"users\"])]\r\n    // Tags with method\r\n    #[case(\"get, tags = [\\\"users\\\"]\", true, vec![\"users\"])]\r\n    #[case(\"post, tags = [\\\"users\\\", \\\"create\\\"]\", true, vec![\"users\", \"create\"])]\r\n    // Tags with path\r\n    #[case(\"path = \\\"/api\\\", tags = [\\\"api\\\"]\", true, vec![\"api\"])]\r\n    // Tags with method and path\r\n    #[case(\"get, path = \\\"/users\\\", tags = [\\\"users\\\"]\", true, vec![\"users\"])]\r\n    // Empty tags array\r\n    #[case(\"tags = []\", true, vec![])]\r\n    fn test_route_args_parse_tags(\r\n        #[case] input: \u0026str,\r\n        #[case] should_parse: bool,\r\n        #[case] expected_tags: Vec\u003c\u0026str\u003e,\r\n    ) {\r\n        let result = syn::parse_str::\u003cRouteArgs\u003e(input);\r\n\r\n        match (should_parse, result) {\r\n            (true, Ok(route_args)) =\u003e {\r\n                if expected_tags.is_empty() {\r\n                    // Empty array should result in Some with empty vec\r\n                    if let Some(tags_array) = \u0026route_args.tags {\r\n                        assert!(tags_array.elems.is_empty());\r\n                    }\r\n                } else {\r\n                    assert!(\r\n                        route_args.tags.is_some(),\r\n                        \"Expected tags but got None for input: {}\",\r\n                        input\r\n                    );\r\n                    let tags_array = route_args.tags.as_ref().unwrap();\r\n                    let mut parsed_tags = Vec::new();\r\n                    for elem in \u0026tags_array.elems {\r\n                        if let syn::Expr::Lit(syn::ExprLit {\r\n                            lit: syn::Lit::Str(lit_str),\r\n                            ..\r\n                        }) = elem\r\n                        {\r\n                            parsed_tags.push(lit_str.value());\r\n                        }\r\n                    }\r\n                    assert_eq!(\r\n                        parsed_tags, expected_tags,\r\n                        \"Tags mismatch for input: {}\",\r\n                        input\r\n                    );\r\n                }\r\n            }\r\n            (false, Err(_)) =\u003e {\r\n                // Expected error, test passes\r\n            }\r\n            (true, Err(e)) =\u003e {\r\n                panic!(\r\n                    \"Expected successful parse but got error: {} for input: {}\",\r\n                    e, input\r\n                );\r\n            }\r\n            (false, Ok(_)) =\u003e {\r\n                panic!(\"Expected parse error but got success for input: {}\", input);\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":10,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":11,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":12,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":13,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":16,"address":[],"length":0,"stats":{"Line":10304235947423694848}},{"line":17,"address":[],"length":0,"stats":{"Line":11817445422220181504}},{"line":19,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":21,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":22,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":23,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":24,"address":[],"length":0,"stats":{"Line":8574853690513424384}},{"line":25,"address":[],"length":0,"stats":{"Line":5692549928996306944}},{"line":27,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":28,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":29,"address":[],"length":0,"stats":{"Line":7133701809754865664}},{"line":30,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":32,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":33,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":34,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":35,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":37,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":38,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":39,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":40,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":43,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":48,"address":[],"length":0,"stats":{"Line":17870283321406128126}},{"line":49,"address":[],"length":0,"stats":{"Line":14699749183737298943}},{"line":51,"address":[],"length":0,"stats":{"Line":6196953087261802495}},{"line":54,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":58,"address":[],"length":0,"stats":{"Line":6196953087261802495}},{"line":59,"address":[],"length":0,"stats":{"Line":12393906174523604990}},{"line":60,"address":[],"length":0,"stats":{"Line":12393906174523604990}},{"line":61,"address":[],"length":0,"stats":{"Line":6196953087261802495}},{"line":62,"address":[],"length":0,"stats":{"Line":6196953087261802495}}],"covered":35,"coverable":35},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","collector.rs"],"content":"//! Collector for routes and structs\r\n\r\nuse crate::file_utils::{collect_files, file_to_segments};\r\nuse crate::metadata::{CollectedMetadata, RouteMetadata};\r\nuse crate::route::{extract_doc_comment, extract_route_info};\r\nuse anyhow::{Context, Result};\r\nuse std::path::Path;\r\nuse syn::Item;\r\n\r\n/// Collect routes and structs from a folder\r\npub fn collect_metadata(folder_path: \u0026Path, folder_name: \u0026str) -\u003e Result\u003cCollectedMetadata\u003e {\r\n    let mut metadata = CollectedMetadata::new();\r\n\r\n    let files = collect_files(folder_path).with_context(|| {\r\n        format!(\r\n            \"Failed to collect files from wtf: {}\",\r\n            folder_path.display()\r\n        )\r\n    })?;\r\n\r\n    for file in files {\r\n        if !file.extension().map(|e| e == \"rs\").unwrap_or(false) {\r\n            continue;\r\n        }\r\n\r\n        let content = std::fs::read_to_string(\u0026file)\r\n            .with_context(|| format!(\"Failed to read file: {}\", file.display()))?;\r\n\r\n        let file_ast = syn::parse_file(\u0026content)\r\n            .with_context(|| format!(\"Failed to parse file: {}\", file.display()))?;\r\n\r\n        // Get module path\r\n        let segments = file\r\n            .strip_prefix(folder_path)\r\n            .map(|file_stem| file_to_segments(file_stem, folder_path))\r\n            .context(format!(\r\n                \"Failed to strip prefix from file: {} (base: {})\",\r\n                file.display(),\r\n                folder_path.display()\r\n            ))?;\r\n\r\n        let module_path = if folder_name.is_empty() {\r\n            segments.join(\"::\")\r\n        } else {\r\n            format!(\"{}::{}\", folder_name, segments.join(\"::\"))\r\n        };\r\n\r\n        let file_path = file.display().to_string();\r\n\r\n        // Collect routes\r\n        for item in \u0026file_ast.items {\r\n            if let Item::Fn(fn_item) = item\r\n                \u0026\u0026 let Some(route_info) = extract_route_info(\u0026fn_item.attrs)\r\n            {\r\n                let route_path = if let Some(custom_path) = \u0026route_info.path {\r\n                    let base = format!(\"/{}\", segments.join(\"/\"));\r\n                    let trimmed_base = base.trim_end_matches('/');\r\n                    format!(\"{}/{}\", trimmed_base, custom_path.trim_start_matches('/'))\r\n                } else {\r\n                    format!(\"/{}\", segments.join(\"/\"))\r\n                };\r\n                let route_path = route_path.replace('_', \"-\");\r\n\r\n                // Description priority: route attribute \u003e doc comment\r\n                let description = route_info\r\n                    .description\r\n                    .clone()\r\n                    .or_else(|| extract_doc_comment(\u0026fn_item.attrs));\r\n\r\n                metadata.routes.push(RouteMetadata {\r\n                    method: route_info.method,\r\n                    path: route_path,\r\n                    function_name: fn_item.sig.ident.to_string(),\r\n                    module_path: module_path.clone(),\r\n                    file_path: file_path.clone(),\r\n                    signature: quote::quote!(#fn_item).to_string(),\r\n                    error_status: route_info.error_status.clone(),\r\n                    tags: route_info.tags.clone(),\r\n                    description,\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    Ok(metadata)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use rstest::rstest;\r\n    use std::fs;\r\n    use tempfile::TempDir;\r\n\r\n    fn create_temp_file(dir: \u0026TempDir, filename: \u0026str, content: \u0026str) -\u003e std::path::PathBuf {\r\n        let file_path = dir.path().join(filename);\r\n        if let Some(parent) = file_path.parent() {\r\n            fs::create_dir_all(parent).expect(\"Failed to create parent directory\");\r\n        }\r\n        fs::write(\u0026file_path, content).expect(\"Failed to write temp file\");\r\n        file_path\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_empty_folder() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert!(metadata.routes.is_empty());\r\n        assert!(metadata.structs.is_empty());\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[rstest]\r\n    #[case::single_get_route(\r\n        \"routes\",\r\n        vec![(\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        )],\r\n        \"get\",\r\n        \"/users\",\r\n        \"get_users\",\r\n        \"routes::users\",\r\n    )]\r\n    #[case::single_post_route(\r\n        \"routes\",\r\n        vec![(\r\n            \"create_user.rs\",\r\n            r#\"\r\n#[route(post)]\r\npub fn create_user() -\u003e String {\r\n    \"created\".to_string()\r\n}\r\n\"#,\r\n        )],\r\n        \"post\",\r\n        \"/create-user\",\r\n        \"create_user\",\r\n        \"routes::create_user\",\r\n    )]\r\n    #[case::route_with_custom_path(\r\n        \"routes\",\r\n        vec![(\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get, path = \"/api/users\")]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        )],\r\n        \"get\",\r\n        \"/users/api/users\",\r\n        \"get_users\",\r\n        \"routes::users\",\r\n    )]\r\n    #[case::route_with_error_status(\r\n        \"routes\",\r\n        vec![(\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get, error_status = [400, 404])]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        )],\r\n        \"get\",\r\n        \"/users\",\r\n        \"get_users\",\r\n        \"routes::users\",\r\n    )]\r\n    #[case::nested_module(\r\n        \"routes\",\r\n        vec![(\r\n            \"api/users.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        )],\r\n        \"get\",\r\n        \"/api/users\",\r\n        \"get_users\",\r\n        \"routes::api::users\",\r\n    )]\r\n    #[case::deeply_nested_module(\r\n        \"routes\",\r\n        vec![(\r\n            \"api/v1/users.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        )],\r\n        \"get\",\r\n        \"/api/v1/users\",\r\n        \"get_users\",\r\n        \"routes::api::v1::users\",\r\n    )]\r\n    fn test_collect_metadata_routes(\r\n        #[case] folder_name: \u0026str,\r\n        #[case] files: Vec\u003c(\u0026str, \u0026str)\u003e,\r\n        #[case] expected_method: \u0026str,\r\n        #[case] expected_path: \u0026str,\r\n        #[case] expected_function_name: \u0026str,\r\n        #[case] expected_module_path: \u0026str,\r\n    ) {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n\r\n        for (filename, content) in \u0026files {\r\n            create_temp_file(\u0026temp_dir, filename, content);\r\n        }\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        let route = \u0026metadata.routes[0];\r\n        assert_eq!(route.method, expected_method);\r\n        assert_eq!(route.path, expected_path);\r\n        assert_eq!(route.function_name, expected_function_name);\r\n        assert_eq!(route.module_path, expected_module_path);\r\n        if let Some((first_filename, _)) = files.first() {\r\n            assert!(\r\n                route\r\n                    .file_path\r\n                    .contains(first_filename.split('/').next().unwrap())\r\n            );\r\n        }\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_single_struct() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 0);\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_struct_without_schema() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"user.rs\",\r\n            r#\"\r\npub struct User {\r\n    pub id: i32,\r\n    pub name: String,\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 0);\r\n        assert_eq!(metadata.structs.len(), 0);\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_route_and_struct() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"user.rs\",\r\n            r#\"\r\nuse vespera::Schema;\r\n\r\n#[derive(Schema)]\r\npub struct User {\r\n    pub id: i32,\r\n    pub name: String,\r\n}\r\n\r\n#[route(get)]\r\npub fn get_user() -\u003e User {\r\n    User { id: 1, name: \"Alice\".to_string() }\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 1);\r\n\r\n        let route = \u0026metadata.routes[0];\r\n        assert_eq!(route.function_name, \"get_user\");\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_multiple_routes() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\r\n#[route(post)]\r\npub fn create_users() -\u003e String {\r\n    \"created\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"posts.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_posts() -\u003e String {\r\n    \"posts\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 3);\r\n        assert_eq!(metadata.structs.len(), 0);\r\n\r\n        // Check all routes are present\r\n        let function_names: Vec\u003c\u0026str\u003e = metadata\r\n            .routes\r\n            .iter()\r\n            .map(|r| r.function_name.as_str())\r\n            .collect();\r\n        assert!(function_names.contains(\u0026\"get_users\"));\r\n        assert!(function_names.contains(\u0026\"create_users\"));\r\n        assert!(function_names.contains(\u0026\"get_posts\"));\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_multiple_structs() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"user.rs\",\r\n            r#\"\r\nuse vespera::Schema;\r\n\r\n#[derive(Schema)]\r\npub struct User {\r\n    pub id: i32,\r\n    pub name: String,\r\n}\r\n\"#,\r\n        );\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"post.rs\",\r\n            r#\"\r\nuse vespera::Schema;\r\n\r\n#[derive(Schema)]\r\npub struct Post {\r\n    pub id: i32,\r\n    pub title: String,\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 0);\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_with_mod_rs() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"mod.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn index() -\u003e String {\r\n    \"index\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 1);\r\n        let route = \u0026metadata.routes[0];\r\n        assert_eq!(route.function_name, \"index\");\r\n        assert_eq!(route.path, \"/\");\r\n        assert_eq!(route.module_path, \"routes::\");\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_empty_folder_name() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 1);\r\n        let route = \u0026metadata.routes[0];\r\n        assert_eq!(route.module_path, \"users\");\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_ignores_non_rs_files() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        create_temp_file(\u0026temp_dir, \"config.txt\", \"some config content\");\r\n\r\n        create_temp_file(\u0026temp_dir, \"readme.md\", \"# Readme\");\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        // Only .rs file should be processed\r\n        assert_eq!(metadata.routes.len(), 1);\r\n        assert_eq!(metadata.structs.len(), 0);\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_ignores_invalid_syntax() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"valid.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        create_temp_file(\u0026temp_dir, \"invalid.rs\", \"invalid rust syntax {\");\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name);\r\n\r\n        // Only valid file should be processed\r\n        assert!(metadata.is_err());\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_error_status() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"users.rs\",\r\n            r#\"\r\n#[route(get, error_status = [400, 404, 500])]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 1);\r\n        let route = \u0026metadata.routes[0];\r\n        assert_eq!(route.method, \"get\");\r\n        assert!(route.error_status.is_some());\r\n        let error_status = route.error_status.as_ref().unwrap();\r\n        assert_eq!(error_status.len(), 3);\r\n        assert!(error_status.contains(\u0026400));\r\n        assert!(error_status.contains(\u0026404));\r\n        assert!(error_status.contains(\u0026500));\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_all_http_methods() {\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"routes.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_handler() -\u003e String { \"get\".to_string() }\r\n\r\n#[route(post)]\r\npub fn post_handler() -\u003e String { \"post\".to_string() }\r\n\r\n#[route(put)]\r\npub fn put_handler() -\u003e String { \"put\".to_string() }\r\n\r\n#[route(patch)]\r\npub fn patch_handler() -\u003e String { \"patch\".to_string() }\r\n\r\n#[route(delete)]\r\npub fn delete_handler() -\u003e String { \"delete\".to_string() }\r\n\r\n#[route(head)]\r\npub fn head_handler() -\u003e String { \"head\".to_string() }\r\n\r\n#[route(options)]\r\npub fn options_handler() -\u003e String { \"options\".to_string() }\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        assert_eq!(metadata.routes.len(), 7);\r\n\r\n        let methods: Vec\u003c\u0026str\u003e = metadata.routes.iter().map(|r| r.method.as_str()).collect();\r\n        assert!(methods.contains(\u0026\"get\"));\r\n        assert!(methods.contains(\u0026\"post\"));\r\n        assert!(methods.contains(\u0026\"put\"));\r\n        assert!(methods.contains(\u0026\"patch\"));\r\n        assert!(methods.contains(\u0026\"delete\"));\r\n        assert!(methods.contains(\u0026\"head\"));\r\n        assert!(methods.contains(\u0026\"options\"));\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_collect_files_error() {\r\n        // Test: collect_files returns error (non-existent directory)\r\n        let non_existent_path = std::path::Path::new(\"/nonexistent/path/that/does/not/exist\");\r\n        let folder_name = \"routes\";\r\n\r\n        let result = collect_metadata(non_existent_path, folder_name);\r\n\r\n        // Should return error when collect_files fails\r\n        assert!(result.is_err());\r\n        let error_msg = result.unwrap_err().to_string();\r\n        assert!(error_msg.contains(\"Failed to collect files\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_file_read_error() {\r\n        // Test line 25: file read error\r\n        // This is difficult to test directly, but we can test with a file that becomes\r\n        // inaccessible. However, in practice, if the file exists, read_to_string usually succeeds.\r\n        // For coverage purposes, we'll create a scenario where the file might fail to read.\r\n        // Actually, this is hard to simulate reliably, so we'll skip this for now.\r\n        // The continue path is already covered by invalid syntax tests.\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_strip_prefix_error() {\r\n        // Test line 37: strip_prefix fails\r\n        // Note: This is a defensive programming path that is unlikely to be executed\r\n        // in practice because collect_files always returns files under folder_path.\r\n        // However, path normalization differences could theoretically cause this.\r\n        // For coverage purposes, we test the normal case where strip_prefix succeeds.\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        // Create a subdirectory\r\n        let sub_dir = temp_dir.path().join(\"routes\");\r\n        std::fs::create_dir_all(\u0026sub_dir).expect(\"Failed to create subdirectory\");\r\n\r\n        // Create a file in the subdirectory\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"routes/valid.rs\",\r\n            r#\"\r\n#[route(get)]\r\npub fn get_users() -\u003e String {\r\n    \"users\".to_string()\r\n}\r\n\"#,\r\n        );\r\n\r\n        // Collect metadata from the subdirectory\r\n        let metadata = collect_metadata(\u0026sub_dir, folder_name).unwrap();\r\n\r\n        // Should collect the route (strip_prefix succeeds in normal cases)\r\n        assert_eq!(metadata.routes.len(), 1);\r\n\r\n        // The continue path on line 37 is defensive code that handles edge cases\r\n        // where path normalization might cause strip_prefix to fail, but this is\r\n        // extremely rare in practice.\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_struct_without_derive() {\r\n        // Test line 81: attr.path().is_ident(\"derive\") returns false\r\n        // Struct with non-derive attributes should not be collected\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"user.rs\",\r\n            r#\"\r\n#[allow(dead_code)]\r\npub struct User {\r\n    pub id: i32,\r\n    pub name: String,\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        // Struct without Schema derive should not be collected\r\n        assert_eq!(metadata.structs.len(), 0);\r\n\r\n        drop(temp_dir);\r\n    }\r\n\r\n    #[test]\r\n    fn test_collect_metadata_struct_with_other_derive() {\r\n        // Test line 81: struct with other derive attributes (not Schema)\r\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\r\n        let folder_name = \"routes\";\r\n\r\n        create_temp_file(\r\n            \u0026temp_dir,\r\n            \"user.rs\",\r\n            r#\"\r\n#[derive(Debug, Clone)]\r\npub struct User {\r\n    pub id: i32,\r\n    pub name: String,\r\n}\r\n\"#,\r\n        );\r\n\r\n        let metadata = collect_metadata(temp_dir.path(), folder_name).unwrap();\r\n\r\n        // Struct with only Debug/Clone derive (no Schema) should not be collected\r\n        assert_eq!(metadata.structs.len(), 0);\r\n\r\n        drop(temp_dir);\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":12,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":14,"address":[],"length":0,"stats":{"Line":10088063165309911040}},{"line":15,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":16,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":17,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":21,"address":[],"length":0,"stats":{"Line":7710162562058289152}},{"line":22,"address":[],"length":0,"stats":{"Line":13330654897016668160}},{"line":23,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":26,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":27,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":29,"address":[],"length":0,"stats":{"Line":7493989779944505344}},{"line":30,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":33,"address":[],"length":0,"stats":{"Line":7349874591868649472}},{"line":34,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":35,"address":[],"length":0,"stats":{"Line":9799832789158199296}},{"line":36,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":37,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":38,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":39,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":42,"address":[],"length":0,"stats":{"Line":7349874591868649472}},{"line":43,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":45,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":48,"address":[],"length":0,"stats":{"Line":7349874591868649472}},{"line":51,"address":[],"length":0,"stats":{"Line":7349874591868649471}},{"line":52,"address":[],"length":0,"stats":{"Line":4251398048237748223}},{"line":53,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":55,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":56,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":57,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":58,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":60,"address":[],"length":0,"stats":{"Line":10088063165309911040}},{"line":62,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":64,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":65,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":66,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":67,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":68,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":69,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":70,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":71,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":72,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":78,"address":[],"length":0,"stats":{"Line":2377900603251621888}}],"covered":43,"coverable":43},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","file_utils.rs"],"content":"use anyhow::{Context, Result};\nuse std::path::{Path, PathBuf};\n\npub fn collect_files(folder_path: \u0026Path) -\u003e Result\u003cVec\u003cPathBuf\u003e\u003e {\n    let mut files = Vec::new();\n    for entry in std::fs::read_dir(folder_path)\n        .with_context(|| format!(\"Failed to read directory: {}\", folder_path.display()))?\n    {\n        let entry = entry.with_context(|| \"Failed to read directory entry\")?;\n        let path = entry.path();\n        if path.is_file() {\n            files.push(folder_path.join(path));\n        } else if path.is_dir() {\n            files.extend(collect_files(\u0026folder_path.join(\u0026path))?);\n        }\n    }\n    Ok(files)\n}\n\npub fn file_to_segments(file: \u0026Path, base_path: \u0026Path) -\u003e Vec\u003cString\u003e {\n    let file_stem = if let Ok(file_stem) = file.strip_prefix(base_path) {\n        file_stem.display().to_string()\n    } else {\n        file.display().to_string()\n    };\n    let file_stem = file_stem.replace(\".rs\", \"\").replace(\"\\\\\", \"/\");\n    let mut segments: Vec\u003cString\u003e = file_stem\n        .split(\"/\")\n        .filter(|s| !s.is_empty())\n        .map(|s| s.to_string())\n        .collect();\n    if let Some(last) = segments.last()\n        \u0026\u0026 last == \"mod\"\n    {\n        segments.pop();\n    }\n    segments\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rstest::rstest;\n    use std::fs;\n    use std::path::PathBuf;\n    use tempfile::TempDir;\n\n    #[rstest]\n    // Simple file paths\n    #[case(\"routes/users.rs\", \"routes\", vec![\"users\"])]\n    #[case(\"routes/posts.rs\", \"routes\", vec![\"posts\"])]\n    #[case(\"routes/users.rs\", \"routes/\", vec![\"users\"])]\n    // Nested directories\n    #[case(\"routes/admin/users.rs\", \"routes\", vec![\"admin\", \"users\"])]\n    #[case(\"routes/api/v1/users.rs\", \"routes\", vec![\"api\", \"v1\", \"users\"])]\n    #[case(\"routes/admin/settings.rs\", \"routes\", vec![\"admin\", \"settings\"])]\n    // Deep nesting\n    #[case(\"routes/api/v1/users/profile.rs\", \"routes\", vec![\"api\", \"v1\", \"users\", \"profile\"])]\n    // mod.rs files\n    #[case(\"routes/mod.rs\", \"routes\", vec![])]\n    #[case(\"routes/admin/mod.rs\", \"routes\", vec![\"admin\"])]\n    #[case(\"routes/api/v1/mod.rs\", \"routes\", vec![\"api\", \"v1\"])]\n    // mod in middle (should not be removed)\n    #[case(\"routes/mod_users.rs\", \"routes\", vec![\"mod_users\"])]\n    // Windows-style paths (backslashes)\n    #[case(\"routes\\\\users.rs\", \"routes\", vec![\"users\"])]\n    #[case(\"routes\\\\admin\\\\users.rs\", \"routes\", vec![\"admin\", \"users\"])]\n    #[case(\"routes\\\\mod.rs\", \"routes\", vec![])]\n    // Files without .rs extension (should still work)\n    #[case(\"routes/users\", \"routes\", vec![\"users\"])]\n    #[case(\"routes/admin/users\", \"routes\", vec![\"admin\", \"users\"])]\n    // Empty segments\n    #[case(\"routes//users.rs\", \"routes\", vec![\"users\"])]\n    #[case(\"routes///admin//users.rs\", \"routes\", vec![\"admin\", \"users\"])]\n    // Base path not matching\n    #[case(\"/absolute/path/users.rs\", \"routes\", vec![\"absolute\", \"path\", \"users\"])]\n    #[case(\"different/path/users.rs\", \"routes\", vec![\"different\", \"path\", \"users\"])]\n    // Root level files\n    #[case(\"users.rs\", \".\", vec![\"users\"])]\n    #[case(\"mod.rs\", \".\", vec![])]\n    fn test_file_to_segments(\n        #[case] file_path: \u0026str,\n        #[case] base_path: \u0026str,\n        #[case] expected: Vec\u003c\u0026str\u003e,\n    ) {\n        // Normalize paths by replacing backslashes with forward slashes\n        // This ensures tests work cross-platform (Windows uses \\, Unix uses /)\n        let normalized_file_path = file_path.replace(\"\\\\\", \"/\");\n        let normalized_base_path = base_path.replace(\"\\\\\", \"/\");\n        let file = PathBuf::from(normalized_file_path);\n        let base = PathBuf::from(normalized_base_path);\n        let result = file_to_segments(\u0026file, \u0026base);\n        let expected_vec: Vec\u003cString\u003e = expected.iter().map(|s| s.to_string()).collect();\n        assert_eq!(\n            result, expected_vec,\n            \"Failed for file: {}, base: {}\",\n            file_path, base_path\n        );\n    }\n\n    fn create_test_structure(\n        temp_dir: \u0026TempDir,\n        structure: \u0026[(\u0026str, bool)],\n    ) -\u003e Result\u003c(), std::io::Error\u003e {\n        // (path, is_file)\n        for (path, is_file) in structure {\n            let full_path = temp_dir.path().join(path);\n            if *is_file {\n                if let Some(parent) = full_path.parent() {\n                    fs::create_dir_all(parent)?;\n                }\n                fs::write(\u0026full_path, \"test content\")?;\n            } else {\n                fs::create_dir_all(\u0026full_path)?;\n            }\n        }\n        Ok(())\n    }\n\n    fn normalize_paths(paths: \u0026[PathBuf], base: \u0026Path) -\u003e Vec\u003cString\u003e {\n        let mut normalized: Vec\u003cString\u003e = paths\n            .iter()\n            .map(|p| {\n                p.strip_prefix(base)\n                    .unwrap_or(p)\n                    .to_string_lossy()\n                    .replace(\"\\\\\", \"/\")\n            })\n            .collect();\n        normalized.sort();\n        normalized\n    }\n\n    #[rstest]\n    // Empty directory\n    #[case(vec![], vec![])]\n    // Single file\n    #[case(vec![(\"file1.rs\", true)], vec![\"file1.rs\"])]\n    // Multiple files in root\n    #[case(\n        vec![(\"file1.rs\", true), (\"file2.rs\", true), (\"file3.rs\", true)],\n        vec![\"file1.rs\", \"file2.rs\", \"file3.rs\"]\n    )]\n    // Single nested directory with file\n    #[case(\n        vec![(\"subdir\", false), (\"subdir/file.rs\", true)],\n        vec![\"subdir/file.rs\"]\n    )]\n    // Multiple nested directories\n    #[case(\n        vec![\n            (\"dir1\", false),\n            (\"dir1/file1.rs\", true),\n            (\"dir2\", false),\n            (\"dir2/file2.rs\", true),\n        ],\n        vec![\"dir1/file1.rs\", \"dir2/file2.rs\"]\n    )]\n    // Deep nesting\n    #[case(\n        vec![\n            (\"a\", false),\n            (\"a/b\", false),\n            (\"a/b/c\", false),\n            (\"a/b/c/file.rs\", true),\n        ],\n        vec![\"a/b/c/file.rs\"]\n    )]\n    // Mixed structure\n    #[case(\n        vec![\n            (\"root.rs\", true),\n            (\"dir1\", false),\n            (\"dir1/file1.rs\", true),\n            (\"dir1/file2.rs\", true),\n            (\"dir2\", false),\n            (\"dir2/subdir\", false),\n            (\"dir2/subdir/file.rs\", true),\n        ],\n        vec![\"dir1/file1.rs\", \"dir1/file2.rs\", \"dir2/subdir/file.rs\", \"root.rs\"]\n    )]\n    // Files with different extensions\n    #[case(\n        vec![\n            (\"file.rs\", true),\n            (\"file.txt\", true),\n            (\"file.md\", true),\n        ],\n        vec![\"file.md\", \"file.rs\", \"file.txt\"]\n    )]\n    // Empty subdirectories (should be ignored)\n    #[case(\n        vec![\n            (\"empty_dir\", false),\n            (\"file.rs\", true),\n        ],\n        vec![\"file.rs\"]\n    )]\n    fn test_collect_files(#[case] structure: Vec\u003c(\u0026str, bool)\u003e, #[case] expected_files: Vec\u003c\u0026str\u003e) {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        create_test_structure(\u0026temp_dir, \u0026structure).expect(\"Failed to create test structure\");\n\n        let result = collect_files(temp_dir.path()).expect(\"collect_files failed\");\n        let mut normalized_result = normalize_paths(\u0026result, temp_dir.path());\n        normalized_result.sort();\n\n        let mut expected_normalized: Vec\u003cString\u003e =\n            expected_files.iter().map(|s| s.to_string()).collect();\n        expected_normalized.sort();\n\n        assert_eq!(\n            normalized_result, expected_normalized,\n            \"Failed for structure: {:?}\",\n            structure\n        );\n\n        temp_dir.close().expect(\"Failed to close temp dir\");\n    }\n\n    #[test]\n    fn test_collect_files_nonexistent_directory() {\n        let nonexistent = PathBuf::from(\"/nonexistent/path/that/does/not/exist\");\n        let result = collect_files(\u0026nonexistent);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_collect_files_recursive_deep() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n\n        // Create a very deep nested structure\n        let mut path = temp_dir.path().to_path_buf();\n        for i in 0..5 {\n            path = path.join(format!(\"level{}\", i));\n            fs::create_dir_all(\u0026path).expect(\"Failed to create nested dir\");\n        }\n\n        // Create a file at the deepest level\n        let file_path = path.join(\"deep_file.rs\");\n        fs::write(\u0026file_path, \"content\").expect(\"Failed to write file\");\n\n        let result = collect_files(temp_dir.path()).expect(\"collect_files failed\");\n        assert_eq!(result.len(), 1);\n        assert!(result[0].ends_with(\"deep_file.rs\"));\n\n        temp_dir.close().expect(\"Failed to close temp dir\");\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":4827858800541171712}},{"line":5,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":6,"address":[],"length":0,"stats":{"Line":15132094747964866560}},{"line":7,"address":[],"length":0,"stats":{"Line":5548434740920451072}},{"line":9,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":10,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":11,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":12,"address":[],"length":0,"stats":{"Line":15852670688344145920}},{"line":13,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":14,"address":[],"length":0,"stats":{"Line":6052837899185946623}},{"line":17,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":20,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":21,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":22,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":24,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":26,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":27,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":29,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":30,"address":[],"length":0,"stats":{"Line":15420325124116578304}},{"line":32,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":33,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":35,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":37,"address":[],"length":0,"stats":{"Line":4035225266123964416}}],"covered":23,"coverable":23},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","lib.rs"],"content":"mod args;\nmod collector;\nmod file_utils;\nmod metadata;\nmod method;\nmod openapi_generator;\nmod parser;\nmod route;\n\nuse proc_macro::TokenStream;\nuse proc_macro2::Span;\nuse quote::quote;\nuse std::path::Path;\nuse std::sync::{LazyLock, Mutex};\nuse syn::LitStr;\nuse syn::bracketed;\nuse syn::parse::{Parse, ParseStream};\nuse syn::punctuated::Punctuated;\n\nuse crate::collector::collect_metadata;\nuse crate::metadata::{CollectedMetadata, StructMetadata};\nuse crate::method::http_method_to_token_stream;\nuse crate::openapi_generator::generate_openapi_doc_with_metadata;\nuse vespera_core::openapi::Server;\nuse vespera_core::route::HttpMethod;\n\n/// route attribute macro\n#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -\u003e TokenStream {\n    // Validate attribute arguments\n    if let Err(e) = syn::parse::\u003cargs::RouteArgs\u003e(attr) {\n        return e.to_compile_error().into();\n    }\n\n    // Validate that item is a function\n    let item_fn = match syn::parse::\u003csyn::ItemFn\u003e(item.clone()) {\n        Ok(f) =\u003e f,\n        Err(e) =\u003e {\n            return syn::Error::new(e.span(), \"route attribute can only be applied to functions\")\n                .to_compile_error()\n                .into();\n        }\n    };\n\n    // Validate function is pub\n    if !matches!(item_fn.vis, syn::Visibility::Public(_)) {\n        return syn::Error::new_spanned(item_fn.sig.fn_token, \"route function must be public\")\n            .to_compile_error()\n            .into();\n    }\n\n    // Validate function is async\n    if item_fn.sig.asyncness.is_none() {\n        return syn::Error::new_spanned(item_fn.sig.fn_token, \"route function must be async\")\n            .to_compile_error()\n            .into();\n    }\n\n    item\n}\n\n// Schema Storage global variable\nstatic SCHEMA_STORAGE: LazyLock\u003cMutex\u003cVec\u003cStructMetadata\u003e\u003e\u003e =\n    LazyLock::new(|| Mutex::new(Vec::new()));\n\n/// Derive macro for Schema\n#[proc_macro_derive(Schema)]\npub fn derive_schema(input: TokenStream) -\u003e TokenStream {\n    let input = syn::parse_macro_input!(input as syn::DeriveInput);\n    let name = \u0026input.ident;\n    let generics = \u0026input.generics;\n\n    let mut schema_storage = SCHEMA_STORAGE.lock().unwrap();\n    schema_storage.push(StructMetadata {\n        name: name.to_string(),\n        definition: quote::quote!(#input).to_string(),\n    });\n\n    // Mark both struct and enum as having SchemaBuilder\n    // For generic types, include the generic parameters in the impl\n    // The actual schema generation will be done at runtime\n    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n    let expanded = quote! {\n        impl #impl_generics vespera::schema::SchemaBuilder for #name #ty_generics #where_clause {}\n    };\n\n    TokenStream::from(expanded)\n}\n\n/// Server configuration for OpenAPI\n#[derive(Clone)]\nstruct ServerConfig {\n    url: String,\n    description: Option\u003cString\u003e,\n}\n\nstruct AutoRouterInput {\n    dir: Option\u003cLitStr\u003e,\n    openapi: Option\u003cVec\u003cLitStr\u003e\u003e,\n    title: Option\u003cLitStr\u003e,\n    version: Option\u003cLitStr\u003e,\n    docs_url: Option\u003cLitStr\u003e,\n    redoc_url: Option\u003cLitStr\u003e,\n    servers: Option\u003cVec\u003cServerConfig\u003e\u003e,\n}\n\nimpl Parse for AutoRouterInput {\n    fn parse(input: ParseStream) -\u003e syn::Result\u003cSelf\u003e {\n        let mut dir = None;\n        let mut openapi = None;\n        let mut title = None;\n        let mut version = None;\n        let mut docs_url = None;\n        let mut redoc_url = None;\n        let mut servers = None;\n\n        while !input.is_empty() {\n            let lookahead = input.lookahead1();\n\n            if lookahead.peek(syn::Ident) {\n                let ident: syn::Ident = input.parse()?;\n                let ident_str = ident.to_string();\n\n                match ident_str.as_str() {\n                    \"dir\" =\u003e {\n                        input.parse::\u003csyn::Token![=]\u003e()?;\n                        dir = Some(input.parse()?);\n                    }\n                    \"openapi\" =\u003e {\n                        openapi = Some(parse_openapi_values(input)?);\n                    }\n                    \"docs_url\" =\u003e {\n                        input.parse::\u003csyn::Token![=]\u003e()?;\n                        docs_url = Some(input.parse()?);\n                    }\n                    \"redoc_url\" =\u003e {\n                        input.parse::\u003csyn::Token![=]\u003e()?;\n                        redoc_url = Some(input.parse()?);\n                    }\n                    \"title\" =\u003e {\n                        input.parse::\u003csyn::Token![=]\u003e()?;\n                        title = Some(input.parse()?);\n                    }\n                    \"version\" =\u003e {\n                        input.parse::\u003csyn::Token![=]\u003e()?;\n                        version = Some(input.parse()?);\n                    }\n                    \"servers\" =\u003e {\n                        servers = Some(parse_servers_values(input)?);\n                    }\n                    _ =\u003e {\n                        return Err(syn::Error::new(\n                            ident.span(),\n                            format!(\n                                \"unknown field: `{}`. Expected `dir`, `openapi`, `title`, `version`, `docs_url`, `redoc_url`, or `servers`\",\n                                ident_str\n                            ),\n                        ));\n                    }\n                }\n            } else if lookahead.peek(syn::LitStr) {\n                // If just a string, treat it as dir (for backward compatibility)\n                dir = Some(input.parse()?);\n            } else {\n                return Err(lookahead.error());\n            }\n\n            if input.peek(syn::Token![,]) {\n                input.parse::\u003csyn::Token![,]\u003e()?;\n            } else {\n                break;\n            }\n        }\n\n        Ok(AutoRouterInput {\n            dir: dir.or_else(|| {\n                std::env::var(\"VESPERA_DIR\")\n                    .map(|f| LitStr::new(\u0026f, Span::call_site()))\n                    .ok()\n            }),\n            openapi: openapi.or_else(|| {\n                std::env::var(\"VESPERA_OPENAPI\")\n                    .map(|f| vec![LitStr::new(\u0026f, Span::call_site())])\n                    .ok()\n            }),\n            title: title.or_else(|| {\n                std::env::var(\"VESPERA_TITLE\")\n                    .map(|f| LitStr::new(\u0026f, Span::call_site()))\n                    .ok()\n            }),\n            version: version\n                .or_else(|| {\n                    std::env::var(\"VESPERA_VERSION\")\n                        .map(|f| LitStr::new(\u0026f, Span::call_site()))\n                        .ok()\n                })\n                .or_else(|| {\n                    std::env::var(\"CARGO_PKG_VERSION\")\n                        .map(|f| LitStr::new(\u0026f, Span::call_site()))\n                        .ok()\n                }),\n            docs_url: docs_url.or_else(|| {\n                std::env::var(\"VESPERA_DOCS_URL\")\n                    .map(|f| LitStr::new(\u0026f, Span::call_site()))\n                    .ok()\n            }),\n            redoc_url: redoc_url.or_else(|| {\n                std::env::var(\"VESPERA_REDOC_URL\")\n                    .map(|f| LitStr::new(\u0026f, Span::call_site()))\n                    .ok()\n            }),\n            servers: servers.or_else(|| {\n                std::env::var(\"VESPERA_SERVER_URL\")\n                    .ok()\n                    .filter(|url| url.starts_with(\"http://\") || url.starts_with(\"https://\"))\n                    .map(|url| {\n                        vec![ServerConfig {\n                            url,\n                            description: std::env::var(\"VESPERA_SERVER_DESCRIPTION\").ok(),\n                        }]\n                    })\n            }),\n        })\n    }\n}\n\nfn parse_openapi_values(input: ParseStream) -\u003e syn::Result\u003cVec\u003cLitStr\u003e\u003e {\n    input.parse::\u003csyn::Token![=]\u003e()?;\n\n    if input.peek(syn::token::Bracket) {\n        let content;\n        let _ = bracketed!(content in input);\n        let entries: Punctuated\u003cLitStr, syn::Token![,]\u003e =\n            content.parse_terminated(|input| input.parse::\u003cLitStr\u003e(), syn::Token![,])?;\n        Ok(entries.into_iter().collect())\n    } else {\n        let single: LitStr = input.parse()?;\n        Ok(vec![single])\n    }\n}\n\n/// Validate that a URL starts with http:// or https://\nfn validate_server_url(url: \u0026LitStr) -\u003e syn::Result\u003cString\u003e {\n    let url_value = url.value();\n    if !url_value.starts_with(\"http://\") \u0026\u0026 !url_value.starts_with(\"https://\") {\n        return Err(syn::Error::new(\n            url.span(),\n            format!(\n                \"invalid server URL: `{}`. URL must start with `http://` or `https://`\",\n                url_value\n            ),\n        ));\n    }\n    Ok(url_value)\n}\n\n/// Parse server values in various formats:\n/// - `servers = \"url\"` - single URL\n/// - `servers = [\"url1\", \"url2\"]` - multiple URLs (strings only)\n/// - `servers = [(\"url\", \"description\")]` - tuple format with descriptions\n/// - `servers = [{url = \"...\", description = \"...\"}]` - struct-like format\n/// - `servers = {url = \"...\", description = \"...\"}` - single server struct-like format\nfn parse_servers_values(input: ParseStream) -\u003e syn::Result\u003cVec\u003cServerConfig\u003e\u003e {\n    use syn::token::{Brace, Paren};\n\n    input.parse::\u003csyn::Token![=]\u003e()?;\n\n    if input.peek(syn::token::Bracket) {\n        // Array format: [...]\n        let content;\n        let _ = bracketed!(content in input);\n\n        let mut servers = Vec::new();\n\n        while !content.is_empty() {\n            if content.peek(Paren) {\n                // Parse tuple: (\"url\", \"description\")\n                let tuple_content;\n                syn::parenthesized!(tuple_content in content);\n                let url: LitStr = tuple_content.parse()?;\n                let url_value = validate_server_url(\u0026url)?;\n                let description = if tuple_content.peek(syn::Token![,]) {\n                    tuple_content.parse::\u003csyn::Token![,]\u003e()?;\n                    Some(tuple_content.parse::\u003cLitStr\u003e()?.value())\n                } else {\n                    None\n                };\n                servers.push(ServerConfig {\n                    url: url_value,\n                    description,\n                });\n            } else if content.peek(Brace) {\n                // Parse struct-like: {url = \"...\", description = \"...\"}\n                let server = parse_server_struct(\u0026content)?;\n                servers.push(server);\n            } else {\n                // Parse simple string: \"url\"\n                let url: LitStr = content.parse()?;\n                let url_value = validate_server_url(\u0026url)?;\n                servers.push(ServerConfig {\n                    url: url_value,\n                    description: None,\n                });\n            }\n\n            if content.peek(syn::Token![,]) {\n                content.parse::\u003csyn::Token![,]\u003e()?;\n            } else {\n                break;\n            }\n        }\n\n        Ok(servers)\n    } else if input.peek(syn::token::Brace) {\n        // Single struct-like format: servers = {url = \"...\", description = \"...\"}\n        let server = parse_server_struct(input)?;\n        Ok(vec![server])\n    } else {\n        // Single string: servers = \"url\"\n        let single: LitStr = input.parse()?;\n        let url_value = validate_server_url(\u0026single)?;\n        Ok(vec![ServerConfig {\n            url: url_value,\n            description: None,\n        }])\n    }\n}\n\n/// Parse a single server in struct-like format: {url = \"...\", description = \"...\"}\nfn parse_server_struct(input: ParseStream) -\u003e syn::Result\u003cServerConfig\u003e {\n    let content;\n    syn::braced!(content in input);\n\n    let mut url: Option\u003cString\u003e = None;\n    let mut description: Option\u003cString\u003e = None;\n\n    while !content.is_empty() {\n        let ident: syn::Ident = content.parse()?;\n        let ident_str = ident.to_string();\n\n        match ident_str.as_str() {\n            \"url\" =\u003e {\n                content.parse::\u003csyn::Token![=]\u003e()?;\n                let url_lit: LitStr = content.parse()?;\n                url = Some(validate_server_url(\u0026url_lit)?);\n            }\n            \"description\" =\u003e {\n                content.parse::\u003csyn::Token![=]\u003e()?;\n                description = Some(content.parse::\u003cLitStr\u003e()?.value());\n            }\n            _ =\u003e {\n                return Err(syn::Error::new(\n                    ident.span(),\n                    format!(\n                        \"unknown field: `{}`. Expected `url` or `description`\",\n                        ident_str\n                    ),\n                ));\n            }\n        }\n\n        if content.peek(syn::Token![,]) {\n            content.parse::\u003csyn::Token![,]\u003e()?;\n        } else {\n            break;\n        }\n    }\n\n    let url = url.ok_or_else(|| {\n        syn::Error::new(\n            proc_macro2::Span::call_site(),\n            \"server config requires `url` field\",\n        )\n    })?;\n\n    Ok(ServerConfig { url, description })\n}\n\n#[proc_macro]\npub fn vespera(input: TokenStream) -\u003e TokenStream {\n    let input = syn::parse_macro_input!(input as AutoRouterInput);\n\n    let folder_name = input\n        .dir\n        .map(|f| f.value())\n        .unwrap_or_else(|| \"routes\".to_string());\n\n    let openapi_file_names = input\n        .openapi\n        .unwrap_or_default()\n        .into_iter()\n        .map(|f| f.value())\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let title = input.title.map(|t| t.value());\n    let version = input.version.map(|v| v.value());\n    let docs_url = input.docs_url.map(|u| u.value());\n    let redoc_url = input.redoc_url.map(|u| u.value());\n    let servers = input.servers.map(|svrs| {\n        svrs.into_iter()\n            .map(|s| Server {\n                url: s.url,\n                description: s.description,\n                variables: None,\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e()\n    });\n\n    let folder_path = find_folder_path(\u0026folder_name);\n\n    if !folder_path.exists() {\n        return syn::Error::new(\n            Span::call_site(),\n            format!(\"Folder not found: {}\", folder_name),\n        )\n        .to_compile_error()\n        .into();\n    }\n\n    let mut metadata = match collect_metadata(\u0026folder_path, \u0026folder_name) {\n        Ok(metadata) =\u003e metadata,\n        Err(e) =\u003e {\n            return syn::Error::new(\n                Span::call_site(),\n                format!(\"Failed to collect metadata: {}\", e),\n            )\n            .to_compile_error()\n            .into();\n        }\n    };\n    let schemas = SCHEMA_STORAGE.lock().unwrap().clone();\n\n    metadata.structs.extend(schemas);\n\n    let mut docs_info = None;\n    let mut redoc_info = None;\n\n    if !openapi_file_names.is_empty() || docs_url.is_some() || redoc_url.is_some() {\n        // Generate OpenAPI document using collected metadata\n\n        // Serialize to JSON\n        let json_str = match serde_json::to_string_pretty(\u0026generate_openapi_doc_with_metadata(\n            title, version, servers, \u0026metadata,\n        )) {\n            Ok(json) =\u003e json,\n            Err(e) =\u003e {\n                return syn::Error::new(\n                    Span::call_site(),\n                    format!(\"Failed to serialize OpenAPI document: {}\", e),\n                )\n                .to_compile_error()\n                .into();\n            }\n        };\n        for openapi_file_name in \u0026openapi_file_names {\n            // create directory if not exists\n            let file_path = Path::new(openapi_file_name);\n            if let Some(parent) = file_path.parent() {\n                std::fs::create_dir_all(parent).expect(\"Failed to create parent directory\");\n            }\n\n            if let Err(e) = std::fs::write(file_path, \u0026json_str) {\n                return syn::Error::new(\n                    Span::call_site(),\n                    format!(\n                        \"Failed to write OpenAPI document to {}: {}\",\n                        openapi_file_name, e\n                    ),\n                )\n                .to_compile_error()\n                .into();\n            }\n        }\n        if let Some(docs_url) = docs_url {\n            docs_info = Some((docs_url, json_str.clone()));\n        }\n        if let Some(redoc_url) = redoc_url {\n            redoc_info = Some((redoc_url, json_str));\n        }\n    }\n\n    generate_router_code(\u0026metadata, docs_info, redoc_info).into()\n}\n\nfn find_folder_path(folder_name: \u0026str) -\u003e std::path::PathBuf {\n    let root = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n    let path = format!(\"{}/src/{}\", root, folder_name);\n    let path = Path::new(\u0026path);\n    if path.exists() \u0026\u0026 path.is_dir() {\n        return path.to_path_buf();\n    }\n\n    Path::new(folder_name).to_path_buf()\n}\n\nfn generate_router_code(\n    metadata: \u0026CollectedMetadata,\n    docs_info: Option\u003c(String, String)\u003e,\n    redoc_info: Option\u003c(String, String)\u003e,\n) -\u003e proc_macro2::TokenStream {\n    let mut router_nests = Vec::new();\n\n    for route in \u0026metadata.routes {\n        let http_method = HttpMethod::from(route.method.as_str());\n        let method_path = http_method_to_token_stream(http_method);\n        let path = \u0026route.path;\n        let module_path = \u0026route.module_path;\n        let function_name = \u0026route.function_name;\n\n        let mut p: syn::punctuated::Punctuated\u003csyn::PathSegment, syn::Token![::]\u003e =\n            syn::punctuated::Punctuated::new();\n        p.push(syn::PathSegment {\n            ident: syn::Ident::new(\"crate\", Span::call_site()),\n            arguments: syn::PathArguments::None,\n        });\n        p.extend(\n            module_path\n                .split(\"::\")\n                .filter_map(|s| {\n                    if s.is_empty() {\n                        None\n                    } else {\n                        Some(syn::PathSegment {\n                            ident: syn::Ident::new(s, Span::call_site()),\n                            arguments: syn::PathArguments::None,\n                        })\n                    }\n                })\n                .collect::\u003cVec\u003csyn::PathSegment\u003e\u003e(),\n        );\n        let func_name = syn::Ident::new(function_name, Span::call_site());\n        router_nests.push(quote!(\n            .route(#path, #method_path(#p::#func_name))\n        ));\n    }\n\n    if let Some((docs_url, spec)) = docs_info {\n        let method_path = http_method_to_token_stream(HttpMethod::Get);\n\n        let html = format!(\n            r#\"\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"UTF-8\"\u003e\n  \u003ctitle\u003eSwagger UI\u003c/title\u003e\n  \u003clink rel=\"stylesheet\" href=\"https://unpkg.com/swagger-ui-dist/swagger-ui.css\" /\u003e\n\u003c/head\u003e\n\u003cbody style=\"margin: 0; padding: 0;\"\u003e\n\u003cdiv id=\"swagger-ui\"\u003e\u003c/div\u003e\n\n\u003cscript src=\"https://unpkg.com/swagger-ui-dist/swagger-ui-bundle.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"https://unpkg.com/swagger-ui-dist/swagger-ui-standalone-preset.js\"\u003e\u003c/script\u003e\n\n\u003cscript\u003e\n  const openapiSpec = {spec_json};\n\n  window.onload = () =\u003e {{\n    SwaggerUIBundle({{\n      spec: openapiSpec,\n      dom_id: \"\\#swagger-ui\",\n      presets: [\n        SwaggerUIBundle.presets.apis,\n        SwaggerUIStandalonePreset\n      ],\n      layout: \"StandaloneLayout\"\n    }});\n  }};\n\u003c/script\u003e\n\n\u003c/body\u003e\n\u003c/html\u003e\n\"#,\n            spec_json = spec\n        )\n        .replace(\"\\n\", \"\");\n\n        router_nests.push(quote!(\n            .route(#docs_url, #method_path(|| async { vespera::axum::response::Html(#html) }))\n        ));\n    }\n\n    if let Some((redoc_url, spec)) = redoc_info {\n        let method_path = http_method_to_token_stream(HttpMethod::Get);\n\n        let html = format!(\n            r#\"\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"UTF-8\"\u003e\n  \u003ctitle\u003eReDoc\u003c/title\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e\n  \u003cstyle\u003e\n    body {{\n      margin: 0;\n      padding: 0;\n    }}\n  \u003c/style\u003e\n  \u003clink rel=\"stylesheet\" href=\"https://unpkg.com/redoc/bundles/redoc.standalone.css\" /\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003cdiv id=\"redoc-container\"\u003e\u003c/div\u003e\n  \u003cscript src=\"https://unpkg.com/redoc/bundles/redoc.standalone.js\"\u003e\u003c/script\u003e\n  \u003cscript\u003e\n    const openapiSpec = {spec_json};\n    Redoc.init(openapiSpec, {{}}, document.getElementById(\"redoc-container\"));\n  \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n\"#,\n            spec_json = spec\n        )\n        .replace(\"\\n\", \"\");\n\n        router_nests.push(quote!(\n            .route(#redoc_url, #method_path(|| async { vespera::axum::response::Html(#html) }))\n        ));\n    }\n\n    quote! {\n        vespera::axum::Router::new()\n            #( #router_nests )*\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rstest::rstest;\n    use std::fs;\n    use tempfile::TempDir;\n\n    fn create_temp_file(dir: \u0026TempDir, filename: \u0026str, content: \u0026str) -\u003e std::path::PathBuf {\n        let file_path = dir.path().join(filename);\n        if let Some(parent) = file_path.parent() {\n            fs::create_dir_all(parent).expect(\"Failed to create parent directory\");\n        }\n        fs::write(\u0026file_path, content).expect(\"Failed to write temp file\");\n        file_path\n    }\n\n    #[test]\n    fn test_generate_router_code_empty() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let folder_name = \"routes\";\n\n        let result = generate_router_code(\n            \u0026collect_metadata(temp_dir.path(), folder_name).unwrap(),\n            None,\n            None,\n        );\n        let code = result.to_string();\n\n        // Should generate empty router\n        // quote! generates \"vespera :: axum :: Router :: new ()\" format\n        assert!(\n            code.contains(\"Router\") \u0026\u0026 code.contains(\"new\"),\n            \"Code should contain Router::new(), got: {}\",\n            code\n        );\n        assert!(\n            !code.contains(\"route\"),\n            \"Code should not contain route, got: {}\",\n            code\n        );\n\n        drop(temp_dir);\n    }\n\n    #[rstest]\n    #[case::single_get_route(\n        \"routes\",\n        vec![(\n            \"users.rs\",\n            r#\"\n#[route(get)]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#,\n        )],\n        \"get\",\n        \"/users\",\n        \"routes::users::get_users\",\n    )]\n    #[case::single_post_route(\n        \"routes\",\n        vec![(\n            \"create_user.rs\",\n            r#\"\n#[route(post)]\npub fn create_user() -\u003e String {\n    \"created\".to_string()\n}\n\"#,\n        )],\n        \"post\",\n        \"/create-user\",\n        \"routes::create_user::create_user\",\n    )]\n    #[case::single_put_route(\n        \"routes\",\n        vec![(\n            \"update_user.rs\",\n            r#\"\n#[route(put)]\npub fn update_user() -\u003e String {\n    \"updated\".to_string()\n}\n\"#,\n        )],\n        \"put\",\n        \"/update-user\",\n        \"routes::update_user::update_user\",\n    )]\n    #[case::single_delete_route(\n        \"routes\",\n        vec![(\n            \"delete_user.rs\",\n            r#\"\n#[route(delete)]\npub fn delete_user() -\u003e String {\n    \"deleted\".to_string()\n}\n\"#,\n        )],\n        \"delete\",\n        \"/delete-user\",\n        \"routes::delete_user::delete_user\",\n    )]\n    #[case::single_patch_route(\n        \"routes\",\n        vec![(\n            \"patch_user.rs\",\n            r#\"\n#[route(patch)]\npub fn patch_user() -\u003e String {\n    \"patched\".to_string()\n}\n\"#,\n        )],\n        \"patch\",\n        \"/patch-user\",\n        \"routes::patch_user::patch_user\",\n    )]\n    #[case::route_with_custom_path(\n        \"routes\",\n        vec![(\n            \"users.rs\",\n            r#\"\n#[route(get, path = \"/api/users\")]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#,\n        )],\n        \"get\",\n        \"/users/api/users\",\n        \"routes::users::get_users\",\n    )]\n    #[case::nested_module(\n        \"routes\",\n        vec![(\n            \"api/users.rs\",\n            r#\"\n#[route(get)]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#,\n        )],\n        \"get\",\n        \"/api/users\",\n        \"routes::api::users::get_users\",\n    )]\n    #[case::deeply_nested_module(\n        \"routes\",\n        vec![(\n            \"api/v1/users.rs\",\n            r#\"\n#[route(get)]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#,\n        )],\n        \"get\",\n        \"/api/v1/users\",\n        \"routes::api::v1::users::get_users\",\n    )]\n    fn test_generate_router_code_single_route(\n        #[case] folder_name: \u0026str,\n        #[case] files: Vec\u003c(\u0026str, \u0026str)\u003e,\n        #[case] expected_method: \u0026str,\n        #[case] expected_path: \u0026str,\n        #[case] expected_function_path: \u0026str,\n    ) {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n\n        for (filename, content) in files {\n            create_temp_file(\u0026temp_dir, filename, content);\n        }\n\n        let result = generate_router_code(\n            \u0026collect_metadata(temp_dir.path(), folder_name).unwrap(),\n            None,\n            None,\n        );\n        let code = result.to_string();\n\n        // Check router initialization (quote! generates \"vespera :: axum :: Router :: new ()\")\n        assert!(\n            code.contains(\"Router\") \u0026\u0026 code.contains(\"new\"),\n            \"Code should contain Router::new(), got: {}\",\n            code\n        );\n\n        // Check route method\n        assert!(\n            code.contains(expected_method),\n            \"Code should contain method: {}, got: {}\",\n            expected_method,\n            code\n        );\n\n        // Check route path\n        assert!(\n            code.contains(expected_path),\n            \"Code should contain path: {}, got: {}\",\n            expected_path,\n            code\n        );\n\n        // Check function path (quote! adds spaces, so we check for parts)\n        let function_parts: Vec\u003c\u0026str\u003e = expected_function_path.split(\"::\").collect();\n        for part in \u0026function_parts {\n            if !part.is_empty() {\n                assert!(\n                    code.contains(part),\n                    \"Code should contain function part: {}, got: {}\",\n                    part,\n                    code\n                );\n            }\n        }\n\n        drop(temp_dir);\n    }\n\n    #[test]\n    fn test_generate_router_code_multiple_routes() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let folder_name = \"routes\";\n\n        // Create multiple route files\n        create_temp_file(\n            \u0026temp_dir,\n            \"users.rs\",\n            r#\"\n#[route(get)]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#,\n        );\n\n        create_temp_file(\n            \u0026temp_dir,\n            \"create_user.rs\",\n            r#\"\n#[route(post)]\npub fn create_user() -\u003e String {\n    \"created\".to_string()\n}\n\"#,\n        );\n\n        create_temp_file(\n            \u0026temp_dir,\n            \"update_user.rs\",\n            r#\"\n#[route(put)]\npub fn update_user() -\u003e String {\n    \"updated\".to_string()\n}\n\"#,\n        );\n\n        let result = generate_router_code(\n            \u0026collect_metadata(temp_dir.path(), folder_name).unwrap(),\n            None,\n            None,\n        );\n        let code = result.to_string();\n\n        // Check router initialization (quote! generates \"vespera :: axum :: Router :: new ()\")\n        assert!(code.contains(\"Router\") \u0026\u0026 code.contains(\"new\"));\n\n        // Check all routes are present\n        assert!(code.contains(\"get_users\"));\n        assert!(code.contains(\"create_user\"));\n        assert!(code.contains(\"update_user\"));\n\n        // Check methods\n        assert!(code.contains(\"get\"));\n        assert!(code.contains(\"post\"));\n        assert!(code.contains(\"put\"));\n\n        // Count route calls (quote! generates \". route (\" with spaces)\n        // Count occurrences of \". route (\" pattern\n        let route_count = code.matches(\". route (\").count();\n        assert_eq!(\n            route_count, 3,\n            \"Should have 3 route calls, got: {}, code: {}\",\n            route_count, code\n        );\n\n        drop(temp_dir);\n    }\n\n    #[test]\n    fn test_generate_router_code_same_path_different_methods() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let folder_name = \"routes\";\n\n        // Create routes with same path but different methods\n        create_temp_file(\n            \u0026temp_dir,\n            \"users.rs\",\n            r#\"\n#[route(get)]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\n#[route(post)]\npub fn create_users() -\u003e String {\n    \"created\".to_string()\n}\n\"#,\n        );\n\n        let result = generate_router_code(\n            \u0026collect_metadata(temp_dir.path(), folder_name).unwrap(),\n            None,\n            None,\n        );\n        let code = result.to_string();\n\n        // Check router initialization (quote! generates \"vespera :: axum :: Router :: new ()\")\n        assert!(code.contains(\"Router\") \u0026\u0026 code.contains(\"new\"));\n\n        // Check both routes are present\n        assert!(code.contains(\"get_users\"));\n        assert!(code.contains(\"create_users\"));\n\n        // Check methods\n        assert!(code.contains(\"get\"));\n        assert!(code.contains(\"post\"));\n\n        // Should have 2 routes (quote! generates \". route (\" with spaces)\n        let route_count = code.matches(\". route (\").count();\n        assert_eq!(\n            route_count, 2,\n            \"Should have 2 routes, got: {}, code: {}\",\n            route_count, code\n        );\n\n        drop(temp_dir);\n    }\n\n    #[test]\n    fn test_generate_router_code_with_mod_rs() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let folder_name = \"routes\";\n\n        // Create mod.rs file\n        create_temp_file(\n            \u0026temp_dir,\n            \"mod.rs\",\n            r#\"\n#[route(get)]\npub fn index() -\u003e String {\n    \"index\".to_string()\n}\n\"#,\n        );\n\n        let result = generate_router_code(\n            \u0026collect_metadata(temp_dir.path(), folder_name).unwrap(),\n            None,\n            None,\n        );\n        let code = result.to_string();\n\n        // Check router initialization (quote! generates \"vespera :: axum :: Router :: new ()\")\n        assert!(code.contains(\"Router\") \u0026\u0026 code.contains(\"new\"));\n\n        // Check route is present\n        assert!(code.contains(\"index\"));\n\n        // Path should be / (mod.rs maps to root, segments is empty)\n        // quote! generates \"\\\"/\\\"\"\n        assert!(code.contains(\"\\\"/\\\"\"));\n\n        drop(temp_dir);\n    }\n\n    #[test]\n    fn test_generate_router_code_empty_folder_name() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let folder_name = \"\";\n\n        create_temp_file(\n            \u0026temp_dir,\n            \"users.rs\",\n            r#\"\n#[route(get)]\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#,\n        );\n\n        let result = generate_router_code(\n            \u0026collect_metadata(temp_dir.path(), folder_name).unwrap(),\n            None,\n            None,\n        );\n        let code = result.to_string();\n\n        // Check router initialization (quote! generates \"vespera :: axum :: Router :: new ()\")\n        assert!(code.contains(\"Router\") \u0026\u0026 code.contains(\"new\"));\n\n        // Check route is present\n        assert!(code.contains(\"get_users\"));\n\n        // Module path should not have double colons\n        assert!(!code.contains(\"::users::users\"));\n\n        drop(temp_dir);\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":318,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":320,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":321,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":322,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":323,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":324,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":325,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":327,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":328,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":329,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":330,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":331,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":333,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":334,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":335,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":336,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":337,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":338,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":340,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":341,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":342,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":346,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":348,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":349,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":354,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":936748722493063168}}],"covered":28,"coverable":204},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","metadata.rs"],"content":"//! Metadata collection and storage for routes and schemas\n\nuse serde::{Deserialize, Serialize};\n\n/// Route metadata\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RouteMetadata {\n    /// HTTP method\n    pub method: String,\n    /// Route path\n    pub path: String,\n    /// Function name\n    pub function_name: String,\n    /// Module path\n    pub module_path: String,\n    /// File path\n    pub file_path: String,\n    /// Function signature (as string for serialization)\n    pub signature: String,\n    /// Additional error status codes from error_status attribute\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub error_status: Option\u003cVec\u003cu16\u003e\u003e,\n    /// Tags for OpenAPI grouping\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub tags: Option\u003cVec\u003cString\u003e\u003e,\n    /// Description for OpenAPI (from route attribute or doc comment)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n}\n\n/// Struct metadata\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StructMetadata {\n    /// Struct name\n    pub name: String,\n    /// Struct definition (as string for serialization)\n    pub definition: String,\n}\n\n/// Collected metadata\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CollectedMetadata {\n    /// Routes\n    pub routes: Vec\u003cRouteMetadata\u003e,\n    /// Structs\n    pub structs: Vec\u003cStructMetadata\u003e,\n}\n\nimpl CollectedMetadata {\n    pub fn new() -\u003e Self {\n        Self {\n            routes: Vec::new(),\n            structs: Vec::new(),\n        }\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":49,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":50,"address":[],"length":0,"stats":{"Line":3602879701896396800}}],"covered":3,"coverable":3},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","method.rs"],"content":"use proc_macro2::TokenStream;\nuse quote::quote;\nuse vespera_core::route::HttpMethod;\n\n/// Convert HttpMethod to axum routing TokenStream\npub fn http_method_to_token_stream(method: HttpMethod) -\u003e TokenStream {\n    match method {\n        HttpMethod::Get =\u003e quote! { vespera::axum::routing::get },\n        HttpMethod::Post =\u003e quote! { vespera::axum::routing::post },\n        HttpMethod::Put =\u003e quote! { vespera::axum::routing::put },\n        HttpMethod::Patch =\u003e quote! { vespera::axum::routing::patch },\n        HttpMethod::Delete =\u003e quote! { vespera::axum::routing::delete },\n        HttpMethod::Head =\u003e quote! { vespera::axum::routing::head },\n        HttpMethod::Options =\u003e quote! { vespera::axum::routing::options },\n        HttpMethod::Trace =\u003e quote! { vespera::axum::routing::trace },\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rstest::rstest;\n\n    #[rstest]\n    #[case(HttpMethod::Get, \"get\")]\n    #[case(HttpMethod::Post, \"post\")]\n    #[case(HttpMethod::Put, \"put\")]\n    #[case(HttpMethod::Patch, \"patch\")]\n    #[case(HttpMethod::Delete, \"delete\")]\n    #[case(HttpMethod::Head, \"head\")]\n    #[case(HttpMethod::Options, \"options\")]\n    #[case(HttpMethod::Trace, \"trace\")]\n    fn test_http_method_to_token_stream(\n        #[case] method: HttpMethod,\n        #[case] expected_method_name: \u0026str,\n    ) {\n        let result = http_method_to_token_stream(method);\n        let code = result.to_string();\n\n        // Check that the code contains the expected method name\n        // quote! generates \"vespera :: axum :: routing :: get\" format\n        assert!(\n            code.contains(expected_method_name),\n            \"Code should contain method name: {}, got: {}\",\n            expected_method_name,\n            code\n        );\n\n        // Check that it contains the routing path\n        assert!(\n            code.contains(\"routing\"),\n            \"Code should contain 'routing', got: {}\",\n            code\n        );\n\n        // Check that it contains the axum path\n        assert!(\n            code.contains(\"axum\"),\n            \"Code should contain 'axum', got: {}\",\n            code\n        );\n\n        // Check that it contains the vespera path\n        assert!(\n            code.contains(\"vespera\"),\n            \"Code should contain 'vespera', got: {}\",\n            code\n        );\n    }\n\n    #[test]\n    fn test_http_method_to_token_stream_all_methods() {\n        // Test that all methods generate valid TokenStreams\n        let methods = vec![\n            HttpMethod::Get,\n            HttpMethod::Post,\n            HttpMethod::Put,\n            HttpMethod::Patch,\n            HttpMethod::Delete,\n            HttpMethod::Head,\n            HttpMethod::Options,\n            HttpMethod::Trace,\n        ];\n\n        for method in methods {\n            let result = http_method_to_token_stream(method.clone());\n            let code = result.to_string();\n\n            // Each should generate a valid TokenStream\n            assert!(\n                !code.is_empty(),\n                \"TokenStream should not be empty for {:?}\",\n                method\n            );\n            assert!(\n                code.contains(\"routing\"),\n                \"TokenStream should contain 'routing' for {:?}, got: {}\",\n                method,\n                code\n            );\n        }\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":7,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":8,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":9,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":10,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":11,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":12,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":13,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":15,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":10,"coverable":10},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","openapi_generator.rs"],"content":"//! OpenAPI document generator\n\nuse std::collections::{BTreeMap, BTreeSet};\nuse vespera_core::{\n    openapi::{Info, OpenApi, OpenApiVersion, Server, Tag},\n    route::{HttpMethod, PathItem},\n    schema::Components,\n};\n\nuse crate::metadata::CollectedMetadata;\nuse crate::parser::{\n    build_operation_from_function, extract_default, extract_field_rename, extract_rename_all,\n    parse_enum_to_schema, parse_struct_to_schema, rename_field,\n};\n\n/// Generate OpenAPI document from collected metadata\npub fn generate_openapi_doc_with_metadata(\n    title: Option\u003cString\u003e,\n    version: Option\u003cString\u003e,\n    servers: Option\u003cVec\u003cServer\u003e\u003e,\n    metadata: \u0026CollectedMetadata,\n) -\u003e OpenApi {\n    let mut paths: BTreeMap\u003cString, PathItem\u003e = BTreeMap::new();\n    let mut schemas: BTreeMap\u003cString, vespera_core::schema::Schema\u003e = BTreeMap::new();\n    let mut known_schema_names: std::collections::HashMap\u003cString, String\u003e =\n        std::collections::HashMap::new();\n    let mut struct_definitions: std::collections::HashMap\u003cString, String\u003e =\n        std::collections::HashMap::new();\n    let mut all_tags: BTreeSet\u003cString\u003e = BTreeSet::new();\n\n    // First, register all schema names and store struct definitions\n    for struct_meta in \u0026metadata.structs {\n        let schema_name = struct_meta.name.clone();\n        known_schema_names.insert(schema_name.clone(), schema_name);\n        struct_definitions.insert(struct_meta.name.clone(), struct_meta.definition.clone());\n    }\n\n    // Then, parse all struct and enum schemas (now they can reference each other)\n    for struct_meta in \u0026metadata.structs {\n        let parsed = syn::parse_str::\u003csyn::Item\u003e(\u0026struct_meta.definition).unwrap();\n        let mut schema = match \u0026parsed {\n            syn::Item::Struct(struct_item) =\u003e {\n                parse_struct_to_schema(struct_item, \u0026known_schema_names, \u0026struct_definitions)\n            }\n            syn::Item::Enum(enum_item) =\u003e {\n                parse_enum_to_schema(enum_item, \u0026known_schema_names, \u0026struct_definitions)\n            }\n            _ =\u003e {\n                // Fallback to struct parsing for backward compatibility\n                parse_struct_to_schema(\n                    \u0026syn::parse_str(\u0026struct_meta.definition).unwrap(),\n                    \u0026known_schema_names,\n                    \u0026struct_definitions,\n                )\n            }\n        };\n\n        // Process default values for struct fields\n        if let syn::Item::Struct(struct_item) = \u0026parsed {\n            // Find the file where this struct is defined\n            // Try to find a route file that contains this struct\n            let struct_file = metadata\n                .routes\n                .iter()\n                .find_map(|route| {\n                    // Check if the file contains the struct definition\n                    if let Ok(file_content) = std::fs::read_to_string(\u0026route.file_path) {\n                        // Check if the struct name appears in the file (more specific check)\n                        // Look for \"struct StructName\" pattern\n                        let struct_pattern = format!(\"struct {}\", struct_meta.name);\n                        if file_content.contains(\u0026struct_pattern) {\n                            return Some(route.file_path.clone());\n                        }\n                    }\n                    None\n                })\n                .or_else(|| {\n                    // Fallback: try all route files to find the struct\n                    for route in \u0026metadata.routes {\n                        if let Ok(file_content) = std::fs::read_to_string(\u0026route.file_path) {\n                            let struct_pattern = format!(\"struct {}\", struct_meta.name);\n                            if file_content.contains(\u0026struct_pattern) {\n                                return Some(route.file_path.clone());\n                            }\n                        }\n                    }\n                    // Last resort: use first route file if available\n                    metadata.routes.first().map(|r| r.file_path.clone())\n                });\n\n            if let Some(file_path) = struct_file\n                \u0026\u0026 let Ok(file_content) = std::fs::read_to_string(\u0026file_path)\n                \u0026\u0026 let Ok(file_ast) = syn::parse_file(\u0026file_content)\n            {\n                // Process default functions for struct fields\n                process_default_functions(struct_item, \u0026file_ast, \u0026mut schema);\n            }\n        }\n\n        let schema_name = struct_meta.name.clone();\n        schemas.insert(schema_name.clone(), schema);\n    }\n\n    // Process routes from metadata\n    for route_meta in \u0026metadata.routes {\n        // Try to parse the file to get the actual function\n        let content = match std::fs::read_to_string(\u0026route_meta.file_path) {\n            Ok(content) =\u003e content,\n            Err(e) =\u003e {\n                eprintln!(\n                    \"Warning: Failed to read file {}: {}\",\n                    route_meta.file_path, e\n                );\n                continue;\n            }\n        };\n\n        let file_ast = match syn::parse_file(\u0026content) {\n            Ok(ast) =\u003e ast,\n            Err(e) =\u003e {\n                eprintln!(\n                    \"Warning: Failed to parse file {}: {}\",\n                    route_meta.file_path, e\n                );\n                continue;\n            }\n        };\n\n        for item in file_ast.items {\n            if let syn::Item::Fn(fn_item) = item\n                \u0026\u0026 fn_item.sig.ident == route_meta.function_name\n            {\n                let method = HttpMethod::from(route_meta.method.as_str());\n\n                // Collect tags for global tags list\n                if let Some(tags) = \u0026route_meta.tags {\n                    for tag in tags {\n                        all_tags.insert(tag.clone());\n                    }\n                }\n\n                // Build operation from function signature\n                let mut operation = build_operation_from_function(\n                    \u0026fn_item.sig,\n                    \u0026route_meta.path,\n                    \u0026known_schema_names,\n                    \u0026struct_definitions,\n                    route_meta.error_status.as_deref(),\n                    route_meta.tags.as_deref(),\n                );\n\n                // Set description from metadata\n                if let Some(desc) = \u0026route_meta.description {\n                    operation.description = Some(desc.clone());\n                }\n\n                // Get or create PathItem\n                let path_item = paths\n                    .entry(route_meta.path.clone())\n                    .or_insert_with(|| PathItem {\n                        get: None,\n                        post: None,\n                        put: None,\n                        patch: None,\n                        delete: None,\n                        head: None,\n                        options: None,\n                        trace: None,\n                        parameters: None,\n                        summary: None,\n                        description: None,\n                    });\n\n                // Set operation for the method\n                path_item.set_operation(method, operation);\n                break;\n            }\n        }\n    }\n\n    // Build OpenAPI document\n    OpenApi {\n        openapi: OpenApiVersion::V3_1_0,\n        info: Info {\n            title: title.unwrap_or_else(|| \"API\".to_string()),\n            version: version.unwrap_or_else(|| \"1.0.0\".to_string()),\n            description: None,\n            terms_of_service: None,\n            contact: None,\n            license: None,\n            summary: None,\n        },\n        servers: servers.or_else(|| {\n            Some(vec![Server {\n                url: \"http://localhost:3000\".to_string(),\n                description: None,\n                variables: None,\n            }])\n        }),\n        paths,\n        components: Some(Components {\n            schemas: if schemas.is_empty() {\n                None\n            } else {\n                Some(schemas)\n            },\n            responses: None,\n            parameters: None,\n            examples: None,\n            request_bodies: None,\n            headers: None,\n            security_schemes: None,\n        }),\n        security: None,\n        tags: if all_tags.is_empty() {\n            None\n        } else {\n            Some(\n                all_tags\n                    .into_iter()\n                    .map(|name| Tag {\n                        name,\n                        description: None,\n                        external_docs: None,\n                    })\n                    .collect(),\n            )\n        },\n        external_docs: None,\n    }\n}\n\n/// Process default functions for struct fields\n/// This function extracts default values from functions specified in #[serde(default = \"function_name\")]\nfn process_default_functions(\n    struct_item: \u0026syn::ItemStruct,\n    file_ast: \u0026syn::File,\n    schema: \u0026mut vespera_core::schema::Schema,\n) {\n    use syn::Fields;\n    use vespera_core::schema::SchemaRef;\n\n    // Extract rename_all from struct level\n    let struct_rename_all = extract_rename_all(\u0026struct_item.attrs);\n\n    // Get properties from schema\n    let properties = match \u0026mut schema.properties {\n        Some(props) =\u003e props,\n        None =\u003e return, // No properties to process\n    };\n\n    // Process each field in the struct\n    if let Fields::Named(fields_named) = \u0026struct_item.fields {\n        for field in \u0026fields_named.named {\n            // Extract default function name\n            let default_info = match extract_default(\u0026field.attrs) {\n                Some(Some(func_name)) =\u003e func_name, // default = \"function_name\"\n                Some(None) =\u003e {\n                    // Simple default (no function) - we can set type-specific defaults\n                    let rust_field_name = field\n                        .ident\n                        .as_ref()\n                        .map(|i| i.to_string())\n                        .unwrap_or_else(|| \"unknown\".to_string());\n\n                    let field_name = if let Some(renamed) = extract_field_rename(\u0026field.attrs) {\n                        renamed\n                    } else {\n                        rename_field(\u0026rust_field_name, struct_rename_all.as_deref())\n                    };\n\n                    // Set type-specific default for simple default\n                    if let Some(prop_schema_ref) = properties.get_mut(\u0026field_name)\n                        \u0026\u0026 let SchemaRef::Inline(prop_schema) = prop_schema_ref\n                        \u0026\u0026 prop_schema.default.is_none()\n                        \u0026\u0026 let Some(default_value) = get_type_default(\u0026field.ty)\n                    {\n                        prop_schema.default = Some(default_value);\n                    }\n                    continue;\n                }\n                None =\u003e continue, // No default attribute\n            };\n\n            // Find the function in the file AST\n            let func = find_function_in_file(file_ast, \u0026default_info);\n            if let Some(func_item) = func {\n                // Extract default value from function body\n                if let Some(default_value) = extract_default_value_from_function(func_item) {\n                    // Get the field name (with rename applied)\n                    let rust_field_name = field\n                        .ident\n                        .as_ref()\n                        .map(|i| i.to_string())\n                        .unwrap_or_else(|| \"unknown\".to_string());\n\n                    let field_name = if let Some(renamed) = extract_field_rename(\u0026field.attrs) {\n                        renamed\n                    } else {\n                        rename_field(\u0026rust_field_name, struct_rename_all.as_deref())\n                    };\n\n                    // Set default value in schema\n                    if let Some(prop_schema_ref) = properties.get_mut(\u0026field_name)\n                        \u0026\u0026 let SchemaRef::Inline(prop_schema) = prop_schema_ref\n                    {\n                        prop_schema.default = Some(default_value);\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Find a function by name in the file AST\nfn find_function_in_file\u003c'a\u003e(\n    file_ast: \u0026'a syn::File,\n    function_name: \u0026str,\n) -\u003e Option\u003c\u0026'a syn::ItemFn\u003e {\n    for item in \u0026file_ast.items {\n        if let syn::Item::Fn(fn_item) = item\n            \u0026\u0026 fn_item.sig.ident == function_name\n        {\n            return Some(fn_item);\n        }\n    }\n    None\n}\n\n/// Extract default value from function body\n/// This tries to extract literal values from common patterns like:\n/// - \"value\".to_string() -\u003e \"value\"\n/// - 42 -\u003e 42\n/// - true -\u003e true\n/// - vec![] -\u003e []\nfn extract_default_value_from_function(func: \u0026syn::ItemFn) -\u003e Option\u003cserde_json::Value\u003e {\n    // Try to find return statement or expression\n    for stmt in \u0026func.block.stmts {\n        if let syn::Stmt::Expr(expr, _) = stmt {\n            // Direct expression (like \"value\".to_string())\n            if let Some(value) = extract_value_from_expr(expr) {\n                return Some(value);\n            }\n            // Or return statement\n            if let syn::Expr::Return(ret) = expr\n                \u0026\u0026 let Some(expr) = \u0026ret.expr\n                \u0026\u0026 let Some(value) = extract_value_from_expr(expr)\n            {\n                return Some(value);\n            }\n        }\n    }\n\n    None\n}\n\n/// Extract value from expression\nfn extract_value_from_expr(expr: \u0026syn::Expr) -\u003e Option\u003cserde_json::Value\u003e {\n    use syn::{Expr, ExprLit, ExprMacro, Lit};\n\n    match expr {\n        // Literal values\n        Expr::Lit(ExprLit { lit, .. }) =\u003e match lit {\n            Lit::Str(s) =\u003e Some(serde_json::Value::String(s.value())),\n            Lit::Int(i) =\u003e {\n                if let Ok(val) = i.base10_parse::\u003ci64\u003e() {\n                    Some(serde_json::Value::Number(val.into()))\n                } else {\n                    None\n                }\n            }\n            Lit::Float(f) =\u003e {\n                if let Ok(val) = f.base10_parse::\u003cf64\u003e() {\n                    Some(serde_json::Value::Number(\n                        serde_json::Number::from_f64(val).unwrap_or(serde_json::Number::from(0)),\n                    ))\n                } else {\n                    None\n                }\n            }\n            Lit::Bool(b) =\u003e Some(serde_json::Value::Bool(b.value)),\n            _ =\u003e None,\n        },\n        // Method calls like \"value\".to_string()\n        Expr::MethodCall(method_call) =\u003e {\n            if method_call.method == \"to_string\" {\n                // Get the receiver (the string literal)\n                // Try direct match first\n                if let Expr::Lit(ExprLit {\n                    lit: Lit::Str(s), ..\n                }) = method_call.receiver.as_ref()\n                {\n                    return Some(serde_json::Value::String(s.value()));\n                }\n                // Try to extract from nested expressions (e.g., if the receiver is wrapped)\n                if let Some(value) = extract_value_from_expr(method_call.receiver.as_ref()) {\n                    return Some(value);\n                }\n            }\n            None\n        }\n        // Macro calls like vec![]\n        Expr::Macro(ExprMacro { mac, .. }) =\u003e {\n            if mac.path.is_ident(\"vec\") {\n                // Try to parse vec![] as empty array\n                return Some(serde_json::Value::Array(vec![]));\n            }\n            None\n        }\n        _ =\u003e None,\n    }\n}\n\n/// Get type-specific default value for simple #[serde(default)]\nfn get_type_default(ty: \u0026syn::Type) -\u003e Option\u003cserde_json::Value\u003e {\n    use syn::Type;\n    match ty {\n        Type::Path(type_path) =\u003e {\n            if let Some(segment) = type_path.path.segments.last() {\n                match segment.ident.to_string().as_str() {\n                    \"String\" =\u003e Some(serde_json::Value::String(String::new())),\n                    \"i8\" | \"i16\" | \"i32\" | \"i64\" | \"u8\" | \"u16\" | \"u32\" | \"u64\" =\u003e {\n                        Some(serde_json::Value::Number(serde_json::Number::from(0)))\n                    }\n                    \"f32\" | \"f64\" =\u003e Some(serde_json::Value::Number(\n                        serde_json::Number::from_f64(0.0).unwrap_or(serde_json::Number::from(0)),\n                    )),\n                    \"bool\" =\u003e Some(serde_json::Value::Bool(false)),\n                    _ =\u003e None,\n                }\n            } else {\n                None\n            }\n        }\n        _ =\u003e None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::metadata::{CollectedMetadata, RouteMetadata, StructMetadata};\n    use rstest::rstest;\n    use std::fs;\n    use std::path::PathBuf;\n    use tempfile::TempDir;\n\n    fn create_temp_file(dir: \u0026TempDir, filename: \u0026str, content: \u0026str) -\u003e PathBuf {\n        let file_path = dir.path().join(filename);\n        fs::write(\u0026file_path, content).expect(\"Failed to write temp file\");\n        file_path\n    }\n\n    #[test]\n    fn test_generate_openapi_empty_metadata() {\n        let metadata = CollectedMetadata::new();\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        assert_eq!(doc.openapi, OpenApiVersion::V3_1_0);\n        assert_eq!(doc.info.title, \"API\");\n        assert_eq!(doc.info.version, \"1.0.0\");\n        assert!(doc.paths.is_empty());\n        assert!(doc.components.as_ref().unwrap().schemas.is_none());\n        assert_eq!(doc.servers.as_ref().unwrap().len(), 1);\n        assert_eq!(\n            doc.servers.as_ref().unwrap()[0].url,\n            \"http://localhost:3000\"\n        );\n    }\n\n    #[rstest]\n    #[case(None, None, \"API\", \"1.0.0\")]\n    #[case(Some(\"My API\".to_string()), None, \"My API\", \"1.0.0\")]\n    #[case(None, Some(\"2.0.0\".to_string()), \"API\", \"2.0.0\")]\n    #[case(Some(\"Test API\".to_string()), Some(\"3.0.0\".to_string()), \"Test API\", \"3.0.0\")]\n    fn test_generate_openapi_title_version(\n        #[case] title: Option\u003cString\u003e,\n        #[case] version: Option\u003cString\u003e,\n        #[case] expected_title: \u0026str,\n        #[case] expected_version: \u0026str,\n    ) {\n        let metadata = CollectedMetadata::new();\n\n        let doc = generate_openapi_doc_with_metadata(title, version, None, \u0026metadata);\n\n        assert_eq!(doc.info.title, expected_title);\n        assert_eq!(doc.info.version, expected_version);\n    }\n\n    #[test]\n    fn test_generate_openapi_with_route() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n\n        // Create a test route file\n        let route_content = r#\"\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#;\n        let route_file = create_temp_file(\u0026temp_dir, \"users.rs\", route_content);\n\n        let mut metadata = CollectedMetadata::new();\n        metadata.routes.push(RouteMetadata {\n            method: \"GET\".to_string(),\n            path: \"/users\".to_string(),\n            function_name: \"get_users\".to_string(),\n            module_path: \"test::users\".to_string(),\n            file_path: route_file.to_string_lossy().to_string(),\n            signature: \"fn get_users() -\u003e String\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        });\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        assert!(doc.paths.contains_key(\"/users\"));\n        let path_item = doc.paths.get(\"/users\").unwrap();\n        assert!(path_item.get.is_some());\n        let operation = path_item.get.as_ref().unwrap();\n        assert_eq!(operation.operation_id, Some(\"get_users\".to_string()));\n    }\n\n    #[test]\n    fn test_generate_openapi_with_struct() {\n        let mut metadata = CollectedMetadata::new();\n        metadata.structs.push(StructMetadata {\n            name: \"User\".to_string(),\n            definition: \"struct User { id: i32, name: String }\".to_string(),\n        });\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        assert!(doc.components.as_ref().unwrap().schemas.is_some());\n        let schemas = doc.components.as_ref().unwrap().schemas.as_ref().unwrap();\n        assert!(schemas.contains_key(\"User\"));\n    }\n\n    #[test]\n    fn test_generate_openapi_with_enum() {\n        let mut metadata = CollectedMetadata::new();\n        metadata.structs.push(StructMetadata {\n            name: \"Status\".to_string(),\n            definition: \"enum Status { Active, Inactive, Pending }\".to_string(),\n        });\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        assert!(doc.components.as_ref().unwrap().schemas.is_some());\n        let schemas = doc.components.as_ref().unwrap().schemas.as_ref().unwrap();\n        assert!(schemas.contains_key(\"Status\"));\n    }\n\n    #[test]\n    fn test_generate_openapi_with_enum_with_data() {\n        // Test enum with data (tuple and struct variants) to ensure full coverage\n        let mut metadata = CollectedMetadata::new();\n        metadata.structs.push(StructMetadata {\n            name: \"Message\".to_string(),\n            definition: \"enum Message { Text(String), User { id: i32, name: String } }\".to_string(),\n        });\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        assert!(doc.components.as_ref().unwrap().schemas.is_some());\n        let schemas = doc.components.as_ref().unwrap().schemas.as_ref().unwrap();\n        assert!(schemas.contains_key(\"Message\"));\n    }\n\n    #[test]\n    fn test_generate_openapi_with_enum_and_route() {\n        // Test enum used in route to ensure enum parsing is called in route context\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let route_content = r#\"\npub fn get_status() -\u003e Status {\n    Status::Active\n}\n\"#;\n        let route_file = create_temp_file(\u0026temp_dir, \"status_route.rs\", route_content);\n\n        let mut metadata = CollectedMetadata::new();\n        metadata.structs.push(StructMetadata {\n            name: \"Status\".to_string(),\n            definition: \"enum Status { Active, Inactive }\".to_string(),\n        });\n        metadata.routes.push(RouteMetadata {\n            method: \"GET\".to_string(),\n            path: \"/status\".to_string(),\n            function_name: \"get_status\".to_string(),\n            module_path: \"test::status_route\".to_string(),\n            file_path: route_file.to_string_lossy().to_string(),\n            signature: \"fn get_status() -\u003e Status\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        });\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        // Check enum schema\n        assert!(doc.components.as_ref().unwrap().schemas.is_some());\n        let schemas = doc.components.as_ref().unwrap().schemas.as_ref().unwrap();\n        assert!(schemas.contains_key(\"Status\"));\n\n        // Check route\n        assert!(doc.paths.contains_key(\"/status\"));\n    }\n\n    #[test]\n    #[should_panic(expected = \"expected `struct`\")]\n    fn test_generate_openapi_with_fallback_item() {\n        // Test fallback case for non-struct, non-enum items (lines 46-48)\n        // Use a const item which will be parsed as syn::Item::Const first\n        // This triggers the fallback case (_ branch) which tries to parse as struct\n        // The fallback will fail to parse const as struct, causing a panic\n        // This test verifies that the fallback path (46-48) is executed\n        let mut metadata = CollectedMetadata::new();\n        metadata.structs.push(StructMetadata {\n            name: \"Config\".to_string(),\n            // This will be parsed as syn::Item::Const, triggering the fallback case\n            definition: \"const CONFIG: i32 = 42;\".to_string(),\n        });\n\n        // This should panic when fallback tries to parse const as struct\n        let _doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n    }\n\n    #[test]\n    fn test_generate_openapi_with_route_and_struct() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let route_content = r#\"\nuse crate::user::User;\n\npub fn get_user() -\u003e User {\n    User { id: 1, name: \"Alice\".to_string() }\n}\n\"#;\n        let route_file = create_temp_file(\u0026temp_dir, \"user_route.rs\", route_content);\n\n        let mut metadata = CollectedMetadata::new();\n        metadata.structs.push(StructMetadata {\n            name: \"User\".to_string(),\n            definition: \"struct User { id: i32, name: String }\".to_string(),\n        });\n        metadata.routes.push(RouteMetadata {\n            method: \"GET\".to_string(),\n            path: \"/user\".to_string(),\n            function_name: \"get_user\".to_string(),\n            module_path: \"test::user_route\".to_string(),\n            file_path: route_file.to_string_lossy().to_string(),\n            signature: \"fn get_user() -\u003e User\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        });\n\n        let doc = generate_openapi_doc_with_metadata(\n            Some(\"Test API\".to_string()),\n            Some(\"1.0.0\".to_string()),\n            None,\n            \u0026metadata,\n        );\n\n        // Check struct schema\n        assert!(doc.components.as_ref().unwrap().schemas.is_some());\n        let schemas = doc.components.as_ref().unwrap().schemas.as_ref().unwrap();\n        assert!(schemas.contains_key(\"User\"));\n\n        // Check route\n        assert!(doc.paths.contains_key(\"/user\"));\n        let path_item = doc.paths.get(\"/user\").unwrap();\n        assert!(path_item.get.is_some());\n    }\n\n    #[test]\n    fn test_generate_openapi_multiple_routes() {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n\n        let route1_content = r#\"\npub fn get_users() -\u003e String {\n    \"users\".to_string()\n}\n\"#;\n        let route1_file = create_temp_file(\u0026temp_dir, \"users.rs\", route1_content);\n\n        let route2_content = r#\"\npub fn create_user() -\u003e String {\n    \"created\".to_string()\n}\n\"#;\n        let route2_file = create_temp_file(\u0026temp_dir, \"create_user.rs\", route2_content);\n\n        let mut metadata = CollectedMetadata::new();\n        metadata.routes.push(RouteMetadata {\n            method: \"GET\".to_string(),\n            path: \"/users\".to_string(),\n            function_name: \"get_users\".to_string(),\n            module_path: \"test::users\".to_string(),\n            file_path: route1_file.to_string_lossy().to_string(),\n            signature: \"fn get_users() -\u003e String\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        });\n        metadata.routes.push(RouteMetadata {\n            method: \"POST\".to_string(),\n            path: \"/users\".to_string(),\n            function_name: \"create_user\".to_string(),\n            module_path: \"test::create_user\".to_string(),\n            file_path: route2_file.to_string_lossy().to_string(),\n            signature: \"fn create_user() -\u003e String\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        });\n\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        assert_eq!(doc.paths.len(), 1); // Same path, different methods\n        let path_item = doc.paths.get(\"/users\").unwrap();\n        assert!(path_item.get.is_some());\n        assert!(path_item.post.is_some());\n    }\n\n    #[rstest]\n    // Test file read failures\n    #[case::route_file_read_failure(\n        None,\n        Some(RouteMetadata {\n            method: \"GET\".to_string(),\n            path: \"/users\".to_string(),\n            function_name: \"get_users\".to_string(),\n            module_path: \"test::users\".to_string(),\n            file_path: \"/nonexistent/route.rs\".to_string(),\n            signature: \"fn get_users() -\u003e String\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        }),\n        false, // struct should not be added\n        false, // route should not be added\n    )]\n    #[case::route_file_parse_failure(\n        None,\n        Some(RouteMetadata {\n            method: \"GET\".to_string(),\n            path: \"/users\".to_string(),\n            function_name: \"get_users\".to_string(),\n            module_path: \"test::users\".to_string(),\n            file_path: \"\".to_string(), // Will be set to temp file with invalid syntax\n            signature: \"fn get_users() -\u003e String\".to_string(),\n            error_status: None,\n            tags: None,\n            description: None,\n        }),\n        false, // struct should not be added\n        false, // route should not be added\n    )]\n    fn test_generate_openapi_file_errors(\n        #[case] struct_meta: Option\u003cStructMetadata\u003e,\n        #[case] route_meta: Option\u003cRouteMetadata\u003e,\n        #[case] expect_struct: bool,\n        #[case] expect_route: bool,\n    ) {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let mut metadata = CollectedMetadata::new();\n\n        // Handle struct metadata\n        if let Some(struct_m) = struct_meta {\n            // If file_path is empty, create invalid syntax file\n            metadata.structs.push(struct_m);\n        }\n\n        // Handle route metadata\n        if let Some(mut route_m) = route_meta {\n            // If file_path is empty, create invalid syntax file\n            if route_m.file_path.is_empty() {\n                let invalid_file =\n                    create_temp_file(\u0026temp_dir, \"invalid_route.rs\", \"invalid rust syntax {\");\n                route_m.file_path = invalid_file.to_string_lossy().to_string();\n            }\n            metadata.routes.push(route_m);\n        }\n\n        // Should not panic, just skip invalid files\n        let doc = generate_openapi_doc_with_metadata(None, None, None, \u0026metadata);\n\n        // Check struct\n        if expect_struct {\n            assert!(doc.components.as_ref().unwrap().schemas.is_some());\n            let schemas = doc.components.as_ref().unwrap().schemas.as_ref().unwrap();\n            assert!(schemas.contains_key(\"User\"));\n        } else if let Some(schemas) = doc.components.as_ref().unwrap().schemas.as_ref() {\n            assert!(!schemas.contains_key(\"User\"));\n        }\n\n        // Check route\n        if expect_route {\n            assert!(doc.paths.contains_key(\"/users\"));\n        } else {\n            assert!(!doc.paths.contains_key(\"/users\"));\n        }\n\n        // Ensure TempDir is properly closed\n        drop(temp_dir);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":22,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":23,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":24,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":25,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":26,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":27,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":28,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":31,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":32,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":33,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":34,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":38,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":39,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":40,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":41,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":42,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":44,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":45,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":50,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":51,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":58,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":61,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":62,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":64,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":69,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":70,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":76,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":78,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":79,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":80,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":81,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":90,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":92,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":96,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":97,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":101,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":103,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":104,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":105,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":110,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":114,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":115,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":116,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":117,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":118,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":121,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":125,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":126,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":127,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":129,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":132,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":133,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":134,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":140,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":141,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":142,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":143,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":144,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":145,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":149,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":150,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":151,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":152,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":153,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":154,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":155,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":156,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":157,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":158,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":159,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":160,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":161,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":162,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":166,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":167,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":184,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":204,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":224,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":233,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":236,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":237,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":243,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":245,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}}],"covered":92,"coverable":180},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","is_keyword_type.rs"],"content":"use syn::{Type, TypePath};\r\n\r\n#[allow(dead_code)]\r\npub enum KeywordType {\r\n    HeaderMap,\r\n    StatusCode,\r\n    Json,\r\n    Path,\r\n    Query,\r\n    Header,\r\n    TypedHeader,\r\n    Result,\r\n}\r\n\r\nimpl KeywordType {\r\n    pub fn as_str(\u0026self) -\u003e \u0026str {\r\n        match self {\r\n            KeywordType::HeaderMap =\u003e \"HeaderMap\",\r\n            KeywordType::StatusCode =\u003e \"StatusCode\",\r\n            KeywordType::Json =\u003e \"Json\",\r\n            KeywordType::Path =\u003e \"Path\",\r\n            KeywordType::Query =\u003e \"Query\",\r\n            KeywordType::Header =\u003e \"Header\",\r\n            KeywordType::TypedHeader =\u003e \"TypedHeader\",\r\n            KeywordType::Result =\u003e \"Result\",\r\n        }\r\n    }\r\n}\r\n\r\npub fn is_keyword_type(ty: \u0026Type, keyword: \u0026KeywordType) -\u003e bool {\r\n    if let Type::Path(type_path) = ty {\r\n        is_keyword_type_by_type_path(type_path, keyword)\r\n    } else {\r\n        false\r\n    }\r\n}\r\n\r\npub fn is_keyword_type_by_type_path(ty: \u0026TypePath, keyword: \u0026KeywordType) -\u003e bool {\r\n    ty.path.segments.last().unwrap().ident == keyword.as_str()\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use rstest::rstest;\r\n    use syn::parse_str;\r\n\r\n    fn syn_type(ty: \u0026str) -\u003e Type {\r\n        parse_str::\u003cType\u003e(ty).expect(\"Failed to parse type\")\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\"HeaderMap\", KeywordType::HeaderMap, true)]\r\n    #[case(\"StatusCode\", KeywordType::StatusCode, true)]\r\n    #[case(\"Json\", KeywordType::Json, true)]\r\n    #[case(\"Path\", KeywordType::Path, true)]\r\n    #[case(\"Query\", KeywordType::Query, true)]\r\n    #[case(\"Header\", KeywordType::Header, true)]\r\n    #[case(\"TypedHeader\", KeywordType::TypedHeader, true)]\r\n    #[case(\"String\", KeywordType::HeaderMap, false)]\r\n    #[case(\"HeaderMap\", KeywordType::Json, false)]\r\n    #[case(\"axum::http::HeaderMap\", KeywordType::HeaderMap, true)]\r\n    #[case(\"axum::http::StatusCode\", KeywordType::StatusCode, true)]\r\n    #[case(\"othermod::Json\", KeywordType::Json, true)]\r\n    #[case(\"CustomType\", KeywordType::Path, false)]\r\n    #[case(\"Result\", KeywordType::Result, true)]\r\n    #[case(\"Result\u003cString, String\u003e\", KeywordType::Result, true)]\r\n    #[case(\"!\", KeywordType::Result, false)]\r\n    fn test_is_keyword_type(\r\n        #[case] ty_str: \u0026str,\r\n        #[case] keyword: KeywordType,\r\n        #[case] expected: bool,\r\n    ) {\r\n        let ty = syn_type(ty_str);\r\n        assert_eq!(is_keyword_type(\u0026ty, \u0026keyword), expected);\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":17,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":18,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":19,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":21,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":30,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":31,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":32,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":38,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":39,"address":[],"length":0,"stats":{"Line":10808639105689190400}}],"covered":16,"coverable":16},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","mod.rs"],"content":"mod is_keyword_type;\nmod operation;\nmod parameters;\nmod path;\nmod request_body;\nmod response;\nmod schema;\npub use operation::build_operation_from_function;\npub use schema::{\n    extract_default, extract_field_rename, extract_rename_all, parse_enum_to_schema,\n    parse_struct_to_schema, rename_field,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","operation.rs"],"content":"use std::collections::BTreeMap;\n\nuse syn::{FnArg, PatType, Type};\nuse vespera_core::{\n    route::{MediaType, Operation, Parameter, ParameterLocation, RequestBody, Response},\n    schema::{Schema, SchemaRef},\n};\n\nuse super::{\n    parameters::parse_function_parameter, path::extract_path_parameters,\n    request_body::parse_request_body, response::parse_return_type,\n    schema::parse_type_to_schema_ref_with_schemas,\n};\n\n/// Build Operation from function signature\npub fn build_operation_from_function(\n    sig: \u0026syn::Signature,\n    path: \u0026str,\n    known_schemas: \u0026std::collections::HashMap\u003cString, String\u003e,\n    struct_definitions: \u0026std::collections::HashMap\u003cString, String\u003e,\n    error_status: Option\u003c\u0026[u16]\u003e,\n    tags: Option\u003c\u0026[String]\u003e,\n) -\u003e Operation {\n    let path_params = extract_path_parameters(path);\n    let mut parameters = Vec::new();\n    let mut request_body = None;\n    let mut path_extractor_type: Option\u003cType\u003e = None;\n\n    // First pass: find Path\u003cT\u003e extractor and extract its type\n    for input in \u0026sig.inputs {\n        if let FnArg::Typed(PatType { ty, .. }) = input\n            \u0026\u0026 let Type::Path(type_path) = ty.as_ref()\n        {\n            let path_segments = \u0026type_path.path;\n            if !path_segments.segments.is_empty() {\n                let segment = path_segments.segments.last().unwrap();\n                if segment.ident == \"Path\"\n                    \u0026\u0026 let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\n                    \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first()\n                {\n                    path_extractor_type = Some(inner_ty.clone());\n                    break;\n                }\n            }\n        }\n    }\n\n    // Generate path parameters from path string (not from function signature)\n    // This is the primary source of truth for path parameters\n    if !path_params.is_empty() {\n        if let Some(ty) = path_extractor_type {\n            // Check if it's a tuple type\n            if let Type::Tuple(tuple) = ty {\n                // For tuple types, match each path parameter with tuple element type\n                for (idx, param_name) in path_params.iter().enumerate() {\n                    if let Some(elem_ty) = tuple.elems.get(idx) {\n                        parameters.push(Parameter {\n                            name: param_name.clone(),\n                            r#in: ParameterLocation::Path,\n                            description: None,\n                            required: Some(true),\n                            schema: Some(parse_type_to_schema_ref_with_schemas(\n                                elem_ty,\n                                known_schemas,\n                                struct_definitions,\n                            )),\n                            example: None,\n                        });\n                    } else {\n                        // If tuple doesn't have enough elements, use String as default\n                        parameters.push(Parameter {\n                            name: param_name.clone(),\n                            r#in: ParameterLocation::Path,\n                            description: None,\n                            required: Some(true),\n                            schema: Some(parse_type_to_schema_ref_with_schemas(\n                                \u0026syn::parse_str::\u003cType\u003e(\"String\").unwrap(),\n                                known_schemas,\n                                struct_definitions,\n                            )),\n                            example: None,\n                        });\n                    }\n                }\n            } else {\n                // Single path parameter\n                if path_params.len() == 1 {\n                    parameters.push(Parameter {\n                        name: path_params[0].clone(),\n                        r#in: ParameterLocation::Path,\n                        description: None,\n                        required: Some(true),\n                        schema: Some(parse_type_to_schema_ref_with_schemas(\n                            \u0026ty,\n                            known_schemas,\n                            struct_definitions,\n                        )),\n                        example: None,\n                    });\n                } else {\n                    // Multiple path parameters but single type - use String for all\n                    for param_name in \u0026path_params {\n                        parameters.push(Parameter {\n                            name: param_name.clone(),\n                            r#in: ParameterLocation::Path,\n                            description: None,\n                            required: Some(true),\n                            schema: Some(parse_type_to_schema_ref_with_schemas(\n                                \u0026ty,\n                                known_schemas,\n                                struct_definitions,\n                            )),\n                            example: None,\n                        });\n                    }\n                }\n            }\n        } else {\n            // No Path extractor found, but path has parameters - use String as default\n            for param_name in \u0026path_params {\n                parameters.push(Parameter {\n                    name: param_name.clone(),\n                    r#in: ParameterLocation::Path,\n                    description: None,\n                    required: Some(true),\n                    schema: Some(parse_type_to_schema_ref_with_schemas(\n                        \u0026syn::parse_str::\u003cType\u003e(\"String\").unwrap(),\n                        known_schemas,\n                        struct_definitions,\n                    )),\n                    example: None,\n                });\n            }\n        }\n    }\n\n    // Parse function parameters (skip Path extractor as we already handled it)\n    for input in \u0026sig.inputs {\n        // Check if it's a request body (Json\u003cT\u003e)\n        if let Some(body) = parse_request_body(input, known_schemas, struct_definitions) {\n            request_body = Some(body);\n        } else {\n            // Skip Path extractor - we already handled path parameters above\n            let is_path_extractor = if let FnArg::Typed(PatType { ty, .. }) = input\n                \u0026\u0026 let Type::Path(type_path) = ty.as_ref()\n                \u0026\u0026 !\u0026type_path.path.segments.is_empty()\n            {\n                let segment = \u0026type_path.path.segments.last().unwrap();\n                segment.ident == \"Path\"\n            } else {\n                false\n            };\n\n            if !is_path_extractor\n                \u0026\u0026 let Some(params) =\n                    parse_function_parameter(input, \u0026path_params, known_schemas, struct_definitions)\n            {\n                parameters.extend(params);\n            }\n        }\n    }\n\n    // Fallback: if last arg is String/\u0026str and no body yet, treat as text/plain body\n    if request_body.is_none()\n        \u0026\u0026 let Some(FnArg::Typed(PatType { ty, .. })) = sig.inputs.last()\n    {\n        let is_string = match ty.as_ref() {\n            Type::Path(type_path) =\u003e type_path\n                .path\n                .segments\n                .last()\n                .map(|s| s.ident == \"String\" || s.ident == \"str\")\n                .unwrap_or(false),\n            Type::Reference(type_ref) =\u003e {\n                if let Type::Path(p) = type_ref.elem.as_ref() {\n                    p.path\n                        .segments\n                        .last()\n                        .map(|s| s.ident == \"String\" || s.ident == \"str\")\n                        .unwrap_or(false)\n                } else {\n                    false\n                }\n            }\n            _ =\u003e false,\n        };\n\n        if is_string {\n            let mut content = BTreeMap::new();\n            content.insert(\n                \"text/plain\".to_string(),\n                MediaType {\n                    schema: Some(SchemaRef::Inline(Box::new(Schema::string()))),\n                    example: None,\n                    examples: None,\n                },\n            );\n            request_body = Some(RequestBody {\n                description: None,\n                content,\n                required: Some(true),\n            });\n        }\n    }\n\n    // Parse return type - may return multiple responses (for Result types)\n    let mut responses = parse_return_type(\u0026sig.output, known_schemas, struct_definitions);\n\n    // Add additional error status codes from error_status attribute\n    if let Some(status_codes) = error_status {\n        // Find the error response schema (usually 400 or the first error response)\n        let error_schema = responses\n            .iter()\n            .find(|(code, _)| code != \u0026\u0026\"200\".to_string())\n            .and_then(|(_, resp)| {\n                resp.content\n                    .as_ref()?\n                    .get(\"application/json\")?\n                    .schema\n                    .clone()\n            });\n\n        if let Some(schema) = error_schema {\n            for \u0026status_code in status_codes {\n                let status_str = status_code.to_string();\n                // Only add if not already present\n                responses.entry(status_str).or_insert_with(|| {\n                    let mut err_content = BTreeMap::new();\n                    err_content.insert(\n                        \"application/json\".to_string(),\n                        MediaType {\n                            schema: Some(schema.clone()),\n                            example: None,\n                            examples: None,\n                        },\n                    );\n\n                    Response {\n                        description: \"Error response\".to_string(),\n                        headers: None,\n                        content: Some(err_content),\n                    }\n                });\n            }\n        }\n    }\n\n    Operation {\n        operation_id: Some(sig.ident.to_string()),\n        tags: tags.map(|t| t.to_vec()),\n        summary: None,\n        description: None,\n        parameters: if parameters.is_empty() {\n            None\n        } else {\n            Some(parameters)\n        },\n        request_body,\n        responses,\n        security: None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rstest::rstest;\n    use std::collections::HashMap;\n    use vespera_core::schema::{SchemaRef, SchemaType};\n\n    fn param_schema_type(param: \u0026Parameter) -\u003e Option\u003cSchemaType\u003e {\n        match param.schema.as_ref()? {\n            SchemaRef::Inline(schema) =\u003e schema.schema_type.clone(),\n            SchemaRef::Ref(_) =\u003e None,\n        }\n    }\n\n    fn build(sig_src: \u0026str, path: \u0026str, error_status: Option\u003c\u0026[u16]\u003e) -\u003e Operation {\n        let sig: syn::Signature = syn::parse_str(sig_src).expect(\"signature parse failed\");\n        build_operation_from_function(\n            \u0026sig,\n            path,\n            \u0026HashMap::new(),\n            \u0026HashMap::new(),\n            error_status,\n            None,\n        )\n    }\n\n    #[derive(Clone, Debug)]\n    struct ExpectedParam {\n        name: \u0026'static str,\n        schema: Option\u003cSchemaType\u003e,\n    }\n\n    #[derive(Clone, Debug)]\n    struct ExpectedBody {\n        content_type: \u0026'static str,\n        schema: Option\u003cSchemaType\u003e,\n    }\n\n    #[derive(Clone, Debug)]\n    struct ExpectedResp {\n        status: \u0026'static str,\n        schema: Option\u003cSchemaType\u003e,\n    }\n\n    fn assert_body(op: \u0026Operation, expected: \u0026Option\u003cExpectedBody\u003e) {\n        match expected {\n            None =\u003e assert!(op.request_body.is_none()),\n            Some(exp) =\u003e {\n                let body = op.request_body.as_ref().expect(\"request body expected\");\n                let media = body\n                    .content\n                    .get(exp.content_type)\n                    .or_else(|| {\n                        // allow fallback to the only available content type if expected is absent\n                        if body.content.len() == 1 {\n                            body.content.values().next()\n                        } else {\n                            None\n                        }\n                    })\n                    .expect(\"expected content type\");\n                if let Some(schema_ty) = \u0026exp.schema {\n                    match media.schema.as_ref().expect(\"schema expected\") {\n                        SchemaRef::Inline(schema) =\u003e {\n                            assert_eq!(schema.schema_type, Some(schema_ty.clone()));\n                        }\n                        SchemaRef::Ref(_) =\u003e panic!(\"expected inline schema\"),\n                    }\n                }\n            }\n        }\n    }\n\n    fn assert_params(op: \u0026Operation, expected: \u0026[ExpectedParam]) {\n        match op.parameters.as_ref() {\n            None =\u003e assert!(expected.is_empty()),\n            Some(params) =\u003e {\n                assert_eq!(params.len(), expected.len());\n                for (param, exp) in params.iter().zip(expected) {\n                    assert_eq!(param.name, exp.name);\n                    assert_eq!(param_schema_type(param), exp.schema);\n                }\n            }\n        }\n    }\n\n    fn assert_responses(op: \u0026Operation, expected: \u0026[ExpectedResp]) {\n        for exp in expected {\n            let resp = op.responses.get(exp.status).expect(\"response missing\");\n            let media = resp\n                .content\n                .as_ref()\n                .and_then(|c| c.get(\"application/json\"))\n                .or_else(|| resp.content.as_ref().and_then(|c| c.get(\"text/plain\")))\n                .expect(\"media type missing\");\n            if let Some(schema_ty) = \u0026exp.schema {\n                match media.schema.as_ref().expect(\"schema expected\") {\n                    SchemaRef::Inline(schema) =\u003e {\n                        assert_eq!(schema.schema_type, Some(schema_ty.clone()));\n                    }\n                    SchemaRef::Ref(_) =\u003e panic!(\"expected inline schema\"),\n                }\n            }\n        }\n    }\n\n    #[rstest]\n    #[case(\n        \"fn upload(data: String) -\u003e String\",\n        \"/upload\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![],\n        Some(ExpectedBody { content_type: \"text/plain\", schema: Some(SchemaType::String) }),\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn upload_ref(data: \u0026str) -\u003e String\",\n        \"/upload\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![],\n        Some(ExpectedBody { content_type: \"text/plain\", schema: Some(SchemaType::String) }),\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn get(Path(params): Path\u003c(i32,)\u003e) -\u003e String\",\n        \"/users/{id}/{name}\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![\n            ExpectedParam { name: \"id\", schema: Some(SchemaType::Integer) },\n            ExpectedParam { name: \"name\", schema: Some(SchemaType::String) },\n        ],\n        None,\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn get() -\u003e String\",\n        \"/items/{item_id}\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![ExpectedParam { name: \"item_id\", schema: Some(SchemaType::String) }],\n        None,\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn get(Path(id): Path\u003cString\u003e) -\u003e String\",\n        \"/shops/{shop_id}/items/{item_id}\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![\n            ExpectedParam { name: \"shop_id\", schema: Some(SchemaType::String) },\n            ExpectedParam { name: \"item_id\", schema: Some(SchemaType::String) },\n        ],\n        None,\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn create(Json(body): Json\u003cUser\u003e) -\u003e Result\u003cString, String\u003e\",\n        \"/create\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![],\n        Some(ExpectedBody { content_type: \"application/json\", schema: None }),\n        vec![\n            ExpectedResp { status: \"200\", schema: Some(SchemaType::String) },\n            ExpectedResp { status: \"400\", schema: Some(SchemaType::String) },\n        ]\n    )]\n    #[case(\n        \"fn get(Path(params): Path\u003c(i32,)\u003e) -\u003e String\",\n        \"/users/{id}/{name}/{extra}\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![\n            ExpectedParam { name: \"id\", schema: Some(SchemaType::Integer) },\n            ExpectedParam { name: \"name\", schema: Some(SchemaType::String) },\n            ExpectedParam { name: \"extra\", schema: Some(SchemaType::String) },\n        ],\n        None,\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn get() -\u003e String\",\n        \"/items/{item_id}/extra/{more}\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![\n            ExpectedParam { name: \"item_id\", schema: Some(SchemaType::String) },\n            ExpectedParam { name: \"more\", schema: Some(SchemaType::String) },\n        ],\n        None,\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn post(data: String) -\u003e String\",\n        \"/post\",\n        None::\u003c\u0026[u16]\u003e,\n        vec![],\n        Some(ExpectedBody { content_type: \"text/plain\", schema: Some(SchemaType::String) }),\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn no_error_extra() -\u003e String\",\n        \"/plain\",\n        Some(\u0026[500u16][..]),\n        vec![],\n        None,\n        vec![ExpectedResp { status: \"200\", schema: Some(SchemaType::String) }]\n    )]\n    #[case(\n        \"fn create() -\u003e Result\u003cString, String\u003e\",\n        \"/create\",\n        Some(\u0026[400u16, 500u16][..]),\n        vec![],\n        None,\n        vec![\n            ExpectedResp { status: \"200\", schema: Some(SchemaType::String) },\n            ExpectedResp { status: \"400\", schema: Some(SchemaType::String) },\n            ExpectedResp { status: \"500\", schema: Some(SchemaType::String) },\n        ]\n    )]\n    #[case(\n        \"fn create() -\u003e Result\u003cString, String\u003e\",\n        \"/create\",\n        Some(\u0026[401u16, 402u16][..]),\n        vec![],\n        None,\n        vec![\n            ExpectedResp { status: \"200\", schema: Some(SchemaType::String) },\n            ExpectedResp { status: \"400\", schema: Some(SchemaType::String) },\n            ExpectedResp { status: \"401\", schema: Some(SchemaType::String) },\n            ExpectedResp { status: \"402\", schema: Some(SchemaType::String) },\n        ]\n    )]\n    fn test_build_operation_cases(\n        #[case] sig_src: \u0026str,\n        #[case] path: \u0026str,\n        #[case] extra_status: Option\u003c\u0026[u16]\u003e,\n        #[case] expected_params: Vec\u003cExpectedParam\u003e,\n        #[case] expected_body: Option\u003cExpectedBody\u003e,\n        #[case] expected_resps: Vec\u003cExpectedResp\u003e,\n    ) {\n        let op = build(sig_src, path, extra_status);\n        assert_params(\u0026op, \u0026expected_params);\n        assert_body(\u0026op, \u0026expected_body);\n        assert_responses(\u0026op, \u0026expected_resps);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":24,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":25,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":26,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":27,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":30,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":31,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":32,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":34,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":35,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":36,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":37,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":38,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":39,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":41,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":42,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":50,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":51,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":53,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":55,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":56,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":57,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":58,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":59,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":60,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":61,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":62,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":63,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":64,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":71,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":72,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":73,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":74,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":75,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":77,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":78,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":79,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":81,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":87,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":103,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":104,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":105,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":106,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":107,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":108,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":109,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":110,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":111,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":113,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":120,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":121,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":122,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":123,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":124,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":125,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":126,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":127,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":128,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":129,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":131,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":138,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":140,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":141,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":144,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":145,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":146,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":148,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":149,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":165,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":167,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":168,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":169,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":170,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":172,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":6124895493223874560}},{"line":210,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":212,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":214,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":215,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":216,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":217,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":218,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":220,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":223,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":224,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":225,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":227,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":228,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":229,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":230,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":231,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":232,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":233,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":234,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":238,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":239,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":240,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":241,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":249,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":250,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":253,"address":[],"length":0,"stats":{"Line":2449958197289549824}}],"covered":108,"coverable":140},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","parameters.rs"],"content":"use std::collections::HashMap;\r\n\r\nuse syn::{FnArg, Pat, PatType, Type};\r\nuse vespera_core::{\r\n    route::{Parameter, ParameterLocation},\r\n    schema::{Schema, SchemaRef, SchemaType},\r\n};\r\n\r\nuse super::schema::{\r\n    extract_field_rename, extract_rename_all, is_primitive_type, parse_struct_to_schema,\r\n    parse_type_to_schema_ref_with_schemas, rename_field,\r\n};\r\n\r\n/// Analyze function parameter and convert to OpenAPI Parameter(s)\r\n/// Returns None if parameter should be ignored (e.g., Query\u003cHashMap\u003c...\u003e\u003e)\r\n/// Returns Some(Vec\u003cParameter\u003e) with one or more parameters\r\npub fn parse_function_parameter(\r\n    arg: \u0026FnArg,\r\n    path_params: \u0026[String],\r\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\r\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\r\n) -\u003e Option\u003cVec\u003cParameter\u003e\u003e {\r\n    match arg {\r\n        FnArg::Receiver(_) =\u003e None,\r\n        FnArg::Typed(PatType { pat, ty, .. }) =\u003e {\r\n            // Extract parameter name from pattern\r\n            let param_name = match pat.as_ref() {\r\n                Pat::Ident(ident) =\u003e ident.ident.to_string(),\r\n                Pat::TupleStruct(tuple_struct) =\u003e {\r\n                    // Handle Path(id) pattern\r\n                    if tuple_struct.elems.len() == 1\r\n                        \u0026\u0026 let Pat::Ident(ident) = \u0026tuple_struct.elems[0]\r\n                    {\r\n                        ident.ident.to_string()\r\n                    } else {\r\n                        return None;\r\n                    }\r\n                }\r\n                _ =\u003e return None,\r\n            };\r\n\r\n            // Check for Option\u003cTypedHeader\u003cT\u003e\u003e first\r\n            if let Type::Path(type_path) = ty.as_ref() {\r\n                let path = \u0026type_path.path;\r\n                if !path.segments.is_empty() {\r\n                    let segment = path.segments.first().unwrap();\r\n                    let ident_str = segment.ident.to_string();\r\n\r\n                    // Handle Option\u003cTypedHeader\u003cT\u003e\u003e\r\n                    if ident_str == \"Option\"\r\n                        \u0026\u0026 let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n                        \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first()\r\n                        \u0026\u0026 let Type::Path(inner_type_path) = inner_ty\r\n                        \u0026\u0026 !inner_type_path.path.segments.is_empty()\r\n                    {\r\n                        let inner_segment = inner_type_path.path.segments.last().unwrap();\r\n                        let inner_ident_str = inner_segment.ident.to_string();\r\n\r\n                        if inner_ident_str == \"TypedHeader\" {\r\n                            // TypedHeader always uses string schema regardless of inner type\r\n                            return Some(vec![Parameter {\r\n                                name: param_name.replace(\"_\", \"-\"),\r\n                                r#in: ParameterLocation::Header,\r\n                                description: None,\r\n                                required: Some(false),\r\n                                schema: Some(SchemaRef::Inline(Box::new(Schema::string()))),\r\n                                example: None,\r\n                            }]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Check for common Axum extractors first (before checking path_params)\r\n            // Handle both Path\u003cT\u003e and vespera::axum::extract::Path\u003cT\u003e by checking the last segment\r\n            if let Type::Path(type_path) = ty.as_ref() {\r\n                let path = \u0026type_path.path;\r\n                if !path.segments.is_empty() {\r\n                    // Check the last segment (handles both Path\u003cT\u003e and vespera::axum::extract::Path\u003cT\u003e)\r\n                    let segment = path.segments.last().unwrap();\r\n                    let ident_str = segment.ident.to_string();\r\n\r\n                    match ident_str.as_str() {\r\n                        \"Path\" =\u003e {\r\n                            // Path\u003cT\u003e extractor - use path parameter name from route if available\r\n                            if let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n                                \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) =\r\n                                    args.args.first()\r\n                            {\r\n                                // Check if inner type is a tuple (e.g., Path\u003c(String, String, String)\u003e)\r\n                                if let Type::Tuple(tuple) = inner_ty {\r\n                                    // For tuple types, extract parameters from path string\r\n                                    let mut parameters = Vec::new();\r\n                                    let tuple_elems = \u0026tuple.elems;\r\n\r\n                                    // Match tuple elements with path parameters\r\n                                    for (idx, elem_ty) in tuple_elems.iter().enumerate() {\r\n                                        if let Some(param_name) = path_params.get(idx) {\r\n                                            parameters.push(Parameter {\r\n                                                name: param_name.clone(),\r\n                                                r#in: ParameterLocation::Path,\r\n                                                description: None,\r\n                                                required: Some(true),\r\n                                                schema: Some(\r\n                                                    parse_type_to_schema_ref_with_schemas(\r\n                                                        elem_ty,\r\n                                                        known_schemas,\r\n                                                        struct_definitions,\r\n                                                    ),\r\n                                                ),\r\n                                                example: None,\r\n                                            });\r\n                                        }\r\n                                    }\r\n\r\n                                    if !parameters.is_empty() {\r\n                                        return Some(parameters);\r\n                                    }\r\n                                } else {\r\n                                    // Single path parameter\r\n                                    // Allow only when exactly one path parameter is provided\r\n                                    if path_params.len() != 1 {\r\n                                        return None;\r\n                                    }\r\n                                    let name = path_params[0].clone();\r\n                                    return Some(vec![Parameter {\r\n                                        name,\r\n                                        r#in: ParameterLocation::Path,\r\n                                        description: None,\r\n                                        required: Some(true),\r\n                                        schema: Some(parse_type_to_schema_ref_with_schemas(\r\n                                            inner_ty,\r\n                                            known_schemas,\r\n                                            struct_definitions,\r\n                                        )),\r\n                                        example: None,\r\n                                    }]);\r\n                                }\r\n                            }\r\n                        }\r\n                        \"Query\" =\u003e {\r\n                            // Query\u003cT\u003e extractor\r\n                            if let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n                                \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) =\r\n                                    args.args.first()\r\n                            {\r\n                                // Check if it's HashMap or BTreeMap - ignore these\r\n                                if is_map_type(inner_ty) {\r\n                                    return None;\r\n                                }\r\n\r\n                                // Check if it's a struct - expand to individual parameters\r\n                                if let Some(struct_params) = parse_query_struct_to_parameters(\r\n                                    inner_ty,\r\n                                    known_schemas,\r\n                                    struct_definitions,\r\n                                ) {\r\n                                    return Some(struct_params);\r\n                                }\r\n\r\n                                // Ignore primitive-like query params (including Vec/Option of primitive)\r\n                                if is_primitive_like(inner_ty) {\r\n                                    return None;\r\n                                }\r\n\r\n                                // Check if it's a known type (primitive or known schema)\r\n                                // If unknown, don't add parameter\r\n                                if !is_known_type(inner_ty, known_schemas, struct_definitions) {\r\n                                    return None;\r\n                                }\r\n\r\n                                // Otherwise, treat as single parameter\r\n                                return Some(vec![Parameter {\r\n                                    name: param_name.clone(),\r\n                                    r#in: ParameterLocation::Query,\r\n                                    description: None,\r\n                                    required: Some(true),\r\n                                    schema: Some(parse_type_to_schema_ref_with_schemas(\r\n                                        inner_ty,\r\n                                        known_schemas,\r\n                                        struct_definitions,\r\n                                    )),\r\n                                    example: None,\r\n                                }]);\r\n                            }\r\n                        }\r\n                        \"Header\" =\u003e {\r\n                            // Header\u003cT\u003e extractor\r\n                            if let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n                                \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) =\r\n                                    args.args.first()\r\n                            {\r\n                                // Ignore primitive-like headers\r\n                                if is_primitive_like(inner_ty) {\r\n                                    return None;\r\n                                }\r\n                                return Some(vec![Parameter {\r\n                                    name: param_name.clone(),\r\n                                    r#in: ParameterLocation::Header,\r\n                                    description: None,\r\n                                    required: Some(true),\r\n                                    schema: Some(parse_type_to_schema_ref_with_schemas(\r\n                                        inner_ty,\r\n                                        known_schemas,\r\n                                        struct_definitions,\r\n                                    )),\r\n                                    example: None,\r\n                                }]);\r\n                            }\r\n                        }\r\n                        \"TypedHeader\" =\u003e {\r\n                            // TypedHeader\u003cT\u003e extractor (axum::TypedHeader)\r\n                            // TypedHeader always uses string schema regardless of inner type\r\n                            return Some(vec![Parameter {\r\n                                name: param_name.replace(\"_\", \"-\"),\r\n                                r#in: ParameterLocation::Header,\r\n                                description: None,\r\n                                required: Some(true),\r\n                                schema: Some(SchemaRef::Inline(Box::new(Schema::string()))),\r\n                                example: None,\r\n                            }]);\r\n                        }\r\n                        \"Json\" =\u003e {\r\n                            // Json\u003cT\u003e extractor - this will be handled as RequestBody\r\n                            return None;\r\n                        }\r\n                        _ =\u003e {}\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Check if it's a path parameter (by name match) - for non-extractor cases\r\n            if path_params.contains(\u0026param_name) {\r\n                return Some(vec![Parameter {\r\n                    name: param_name.clone(),\r\n                    r#in: ParameterLocation::Path,\r\n                    description: None,\r\n                    required: Some(true),\r\n                    schema: Some(parse_type_to_schema_ref_with_schemas(\r\n                        ty,\r\n                        known_schemas,\r\n                        struct_definitions,\r\n                    )),\r\n                    example: None,\r\n                }]);\r\n            }\r\n\r\n            // Bare primitive without extractor is ignored (cannot infer location)\r\n            None\r\n        }\r\n    }\r\n}\r\n\r\nfn is_map_type(ty: \u0026Type) -\u003e bool {\r\n    if let Type::Path(type_path) = ty {\r\n        let path = \u0026type_path.path;\r\n        if !path.segments.is_empty() {\r\n            let segment = path.segments.last().unwrap();\r\n            let ident_str = segment.ident.to_string();\r\n            return ident_str == \"HashMap\" || ident_str == \"BTreeMap\";\r\n        }\r\n    }\r\n    false\r\n}\r\n\r\nfn is_primitive_like(ty: \u0026Type) -\u003e bool {\r\n    if is_primitive_type(ty) {\r\n        return true;\r\n    }\r\n    if let Type::Path(type_path) = ty\r\n        \u0026\u0026 let Some(seg) = type_path.path.segments.last()\r\n    {\r\n        let ident = seg.ident.to_string();\r\n        if let syn::PathArguments::AngleBracketed(args) = \u0026seg.arguments\r\n            \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first()\r\n            \u0026\u0026 (ident == \"Vec\" || ident == \"Option\")\r\n            \u0026\u0026 is_primitive_like(inner_ty)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    false\r\n}\r\n\r\nfn is_known_type(\r\n    ty: \u0026Type,\r\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\r\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\r\n) -\u003e bool {\r\n    // Check if it's a primitive type\r\n    if is_primitive_type(ty) {\r\n        return true;\r\n    }\r\n\r\n    // Check if it's a known struct\r\n    if let Type::Path(type_path) = ty {\r\n        let path = \u0026type_path.path;\r\n        if path.segments.is_empty() {\r\n            return false;\r\n        }\r\n\r\n        let segment = path.segments.last().unwrap();\r\n        let ident_str = segment.ident.to_string();\r\n\r\n        // Get type name (handle both simple and qualified paths)\r\n\r\n        // Check if it's in struct_definitions or known_schemas\r\n        if struct_definitions.contains_key(\u0026ident_str) || known_schemas.contains_key(\u0026ident_str) {\r\n            return true;\r\n        }\r\n\r\n        // Check for generic types like Vec\u003cT\u003e, Option\u003cT\u003e - recursively check inner type\r\n        if let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments {\r\n            match ident_str.as_str() {\r\n                \"Vec\" | \"Option\" =\u003e {\r\n                    if let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first() {\r\n                        return is_known_type(inner_ty, known_schemas, struct_definitions);\r\n                    }\r\n                }\r\n                _ =\u003e {}\r\n            }\r\n        }\r\n    }\r\n\r\n    false\r\n}\r\n\r\n/// Parse struct fields to individual query parameters\r\n/// Returns None if the type is not a struct or cannot be parsed\r\nfn parse_query_struct_to_parameters(\r\n    ty: \u0026Type,\r\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\r\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\r\n) -\u003e Option\u003cVec\u003cParameter\u003e\u003e {\r\n    // Check if it's a known struct\r\n    if let Type::Path(type_path) = ty {\r\n        let path = \u0026type_path.path;\r\n        if path.segments.is_empty() {\r\n            return None;\r\n        }\r\n\r\n        let segment = path.segments.last().unwrap();\r\n        let ident_str = segment.ident.to_string();\r\n\r\n        // Get type name (handle both simple and qualified paths)\r\n\r\n        // Check if it's a known struct\r\n        if let Some(struct_def) = struct_definitions.get(\u0026ident_str)\r\n            \u0026\u0026 let Ok(struct_item) = syn::parse_str::\u003csyn::ItemStruct\u003e(struct_def)\r\n        {\r\n            let mut parameters = Vec::new();\r\n\r\n            // Extract rename_all attribute from struct\r\n            let rename_all = extract_rename_all(\u0026struct_item.attrs);\r\n\r\n            if let syn::Fields::Named(fields_named) = \u0026struct_item.fields {\r\n                for field in \u0026fields_named.named {\r\n                    let rust_field_name = field\r\n                        .ident\r\n                        .as_ref()\r\n                        .map(|i| i.to_string())\r\n                        .unwrap_or_else(|| \"unknown\".to_string());\r\n\r\n                    // Check for field-level rename attribute first (takes precedence)\r\n                    let field_name = if let Some(renamed) = extract_field_rename(\u0026field.attrs) {\r\n                        renamed\r\n                    } else {\r\n                        // Apply rename_all transformation if present\r\n                        rename_field(\u0026rust_field_name, rename_all.as_deref())\r\n                    };\r\n\r\n                    let field_type = \u0026field.ty;\r\n\r\n                    // Check if field is Option\u003cT\u003e\r\n                    let is_optional = matches!(\r\n                        field_type,\r\n                        Type::Path(type_path)\r\n                            if type_path\r\n                                .path\r\n                                .segments\r\n                                .first()\r\n                                .map(|s| s.ident == \"Option\")\r\n                                .unwrap_or(false)\r\n                    );\r\n\r\n                    // Parse field type to schema (inline, not ref)\r\n                    // For Query parameters, we need inline schemas, not refs\r\n                    let mut field_schema = parse_type_to_schema_ref_with_schemas(\r\n                        field_type,\r\n                        known_schemas,\r\n                        struct_definitions,\r\n                    );\r\n\r\n                    // Convert ref to inline if needed (Query parameters should not use refs)\r\n                    // If it's a ref to a known struct, get the struct definition and inline it\r\n                    if let SchemaRef::Ref(ref_ref) = \u0026field_schema {\r\n                        // Try to extract type name from ref path (e.g., \"#/components/schemas/User\" -\u003e \"User\")\r\n                        if let Some(type_name) =\r\n                            ref_ref.ref_path.strip_prefix(\"#/components/schemas/\")\r\n                            \u0026\u0026 let Some(struct_def) = struct_definitions.get(type_name)\r\n                            \u0026\u0026 let Ok(nested_struct_item) =\r\n                                syn::parse_str::\u003csyn::ItemStruct\u003e(struct_def)\r\n                        {\r\n                            // Parse the nested struct to schema (inline)\r\n                            let nested_schema = parse_struct_to_schema(\r\n                                \u0026nested_struct_item,\r\n                                known_schemas,\r\n                                struct_definitions,\r\n                            );\r\n                            field_schema = SchemaRef::Inline(Box::new(nested_schema));\r\n                        }\r\n                    }\r\n\r\n                    // If it's Option\u003cT\u003e, make it nullable\r\n                    let final_schema = if is_optional {\r\n                        if let SchemaRef::Inline(mut schema) = field_schema {\r\n                            schema.nullable = Some(true);\r\n                            SchemaRef::Inline(schema)\r\n                        } else {\r\n                            // If still a ref, convert to inline object with nullable\r\n                            SchemaRef::Inline(Box::new(Schema {\r\n                                schema_type: Some(SchemaType::Object),\r\n                                nullable: Some(true),\r\n                                ..Schema::object()\r\n                            }))\r\n                        }\r\n                    } else {\r\n                        // If it's still a ref, convert to inline object\r\n                        match field_schema {\r\n                            SchemaRef::Ref(_) =\u003e {\r\n                                SchemaRef::Inline(Box::new(Schema::new(SchemaType::Object)))\r\n                            }\r\n                            SchemaRef::Inline(schema) =\u003e SchemaRef::Inline(schema),\r\n                        }\r\n                    };\r\n\r\n                    let required = !is_optional;\r\n\r\n                    parameters.push(Parameter {\r\n                        name: field_name,\r\n                        r#in: ParameterLocation::Query,\r\n                        description: None,\r\n                        required: Some(required),\r\n                        schema: Some(final_schema),\r\n                        example: None,\r\n                    });\r\n                }\r\n            }\r\n\r\n            if !parameters.is_empty() {\r\n                return Some(parameters);\r\n            }\r\n        }\r\n    }\r\n    None\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use insta::{assert_debug_snapshot, with_settings};\r\n    use rstest::rstest;\r\n    use std::collections::HashMap;\r\n    use vespera_core::route::ParameterLocation;\r\n\r\n    fn setup_test_data(func_src: \u0026str) -\u003e (HashMap\u003cString, String\u003e, HashMap\u003cString, String\u003e) {\r\n        let mut struct_definitions = HashMap::new();\r\n        let known_schemas: HashMap\u003cString, String\u003e = HashMap::new();\r\n\r\n        if func_src.contains(\"QueryParams\") {\r\n            struct_definitions.insert(\r\n                \"QueryParams\".to_string(),\r\n                r#\"\r\n                pub struct QueryParams {\r\n                    pub page: i32,\r\n                    pub limit: Option\u003ci32\u003e,\r\n                }\r\n                \"#\r\n                .to_string(),\r\n            );\r\n        }\r\n\r\n        if func_src.contains(\"User\") {\r\n            struct_definitions.insert(\r\n                \"User\".to_string(),\r\n                r#\"\r\n                pub struct User {\r\n                    pub id: i32,\r\n                    pub name: String,\r\n                }\r\n                \"#\r\n                .to_string(),\r\n            );\r\n        }\r\n\r\n        (known_schemas, struct_definitions)\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\r\n        \"fn test(params: Path\u003c(String, i32)\u003e) {}\",\r\n        vec![\"user_id\".to_string(), \"count\".to_string()],\r\n        vec![vec![ParameterLocation::Path, ParameterLocation::Path]],\r\n        \"path_tuple\"\r\n    )]\r\n    #[case(\r\n        \"fn show(Path(id): Path\u003ci32\u003e) {}\",\r\n        vec![\"item_id\".to_string()],\r\n        vec![vec![ParameterLocation::Path]],\r\n        \"path_single\"\r\n    )]\r\n    #[case(\r\n        \"fn test(Query(params): Query\u003cHashMap\u003cString, String\u003e\u003e) {}\",\r\n        vec![],\r\n        vec![vec![]],\r\n        \"query_hashmap\"\r\n    )]\r\n    #[case(\r\n        \"fn test(TypedHeader(user_agent): TypedHeader\u003cUserAgent\u003e, count: i32) {}\",\r\n        vec![],\r\n        vec![\r\n            vec![ParameterLocation::Header],\r\n            vec![],\r\n        ],\r\n        \"typed_header_and_arg\"\r\n    )]\r\n    #[case(\r\n        \"fn test(TypedHeader(user_agent): TypedHeader\u003cUserAgent\u003e, content_type: Option\u003cTypedHeader\u003cContentType\u003e\u003e, authorization: Option\u003cTypedHeader\u003cAuthorization\u003cBearer\u003e\u003e\u003e) {}\",\r\n        vec![],\r\n        vec![\r\n            vec![ParameterLocation::Header],\r\n            vec![ParameterLocation::Header],\r\n            vec![ParameterLocation::Header],\r\n        ],\r\n        \"typed_header_multi\"\r\n    )]\r\n    #[case(\r\n        \"fn test(user_agent: TypedHeader\u003cUserAgent\u003e, count: i32) {}\",\r\n        vec![],\r\n        vec![\r\n            vec![ParameterLocation::Header],\r\n            vec![],\r\n        ],\r\n        \"header_value_and_arg\"\r\n    )]\r\n    #[case(\r\n        \"fn test(\u0026self, id: i32) {}\",\r\n        vec![],\r\n        vec![\r\n            vec![],\r\n            vec![],\r\n        ],\r\n        \"method_receiver\"\r\n    )]\r\n    #[case(\r\n        \"fn test(Path((a, b)): Path\u003c(i32, String)\u003e) {}\",\r\n        vec![],\r\n        vec![vec![]],\r\n        \"path_tuple_destructure\"\r\n    )]\r\n    #[case(\r\n        \"fn test(params: Query\u003cQueryParams\u003e) {}\",\r\n        vec![],\r\n        vec![vec![ParameterLocation::Query, ParameterLocation::Query]],\r\n        \"query_struct\"\r\n    )]\r\n    #[case(\r\n        \"fn test(body: Json\u003cUser\u003e) {}\",\r\n        vec![],\r\n        vec![vec![]],\r\n        \"json_body\"\r\n    )]\r\n    #[case(\r\n        \"fn test(params: Query\u003cUnknownType\u003e) {}\",\r\n        vec![],\r\n        vec![vec![]],\r\n        \"query_unknown\"\r\n    )]\r\n    #[case(\r\n        \"fn test(params: Query\u003cBTreeMap\u003cString, String\u003e\u003e) {}\",\r\n        vec![],\r\n        vec![vec![]],\r\n        \"query_map\"\r\n    )]\r\n    #[case(\r\n        \"fn test(user: Query\u003cUser\u003e) {}\",\r\n        vec![],\r\n        vec![vec![ParameterLocation::Query, ParameterLocation::Query]],\r\n        \"query_user\"\r\n    )]\r\n    #[case(\r\n        \"fn test(custom: Header\u003cCustomHeader\u003e) {}\",\r\n        vec![],\r\n        vec![vec![ParameterLocation::Header]],\r\n        \"header_custom\"\r\n    )]\r\n    fn test_parse_function_parameter_cases(\r\n        #[case] func_src: \u0026str,\r\n        #[case] path_params: Vec\u003cString\u003e,\r\n        #[case] expected_locations: Vec\u003cVec\u003cParameterLocation\u003e\u003e,\r\n        #[case] suffix: \u0026str,\r\n    ) {\r\n        let func: syn::ItemFn = syn::parse_str(func_src).unwrap();\r\n        let (known_schemas, struct_definitions) = setup_test_data(func_src);\r\n        let mut parameters = Vec::new();\r\n\r\n        for (idx, arg) in func.sig.inputs.iter().enumerate() {\r\n            let result =\r\n                parse_function_parameter(arg, \u0026path_params, \u0026known_schemas, \u0026struct_definitions);\r\n            let expected = expected_locations\r\n                .get(idx)\r\n                .unwrap_or_else(|| expected_locations.last().unwrap());\r\n\r\n            if expected.is_empty() {\r\n                assert!(\r\n                    result.is_none(),\r\n                    \"Expected None at arg index {}, func: {}\",\r\n                    idx,\r\n                    func_src\r\n                );\r\n                continue;\r\n            }\r\n\r\n            let params = result.as_ref().expect(\"Expected Some parameters\");\r\n            let got_locs: Vec\u003cParameterLocation\u003e = params.iter().map(|p| p.r#in.clone()).collect();\r\n            assert_eq!(\r\n                got_locs, *expected,\r\n                \"Location mismatch at arg index {idx}, func: {func_src}\"\r\n            );\r\n            parameters.extend(params.clone());\r\n        }\r\n        with_settings!({ snapshot_suffix =\u003e format!(\"params_{}\", suffix) }, {\r\n            assert_debug_snapshot!(parameters);\r\n        });\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\r\n        \"fn test(id: Query\u003ci32\u003e) {}\",\r\n        vec![],\r\n    )]\r\n    #[case(\r\n        \"fn test(auth: Header\u003cString\u003e) {}\",\r\n        vec![],\r\n    )]\r\n    #[case(\r\n        \"fn test(params: Query\u003cVec\u003ci32\u003e\u003e) {}\",\r\n        vec![],\r\n    )]\r\n    #[case(\r\n        \"fn test(params: Query\u003cOption\u003cString\u003e\u003e) {}\",\r\n        vec![],\r\n    )]\r\n    #[case(\r\n        \"fn test(Path([a]): Path\u003c[i32; 1]\u003e) {}\",\r\n        vec![],\r\n    )]\r\n    #[case(\r\n        \"fn test(id: Path\u003ci32\u003e) {}\",\r\n        vec![\"user_id\".to_string(), \"post_id\".to_string()],\r\n    )]\r\n    #[case(\r\n        \"fn test((x, y): (i32, i32)) {}\",\r\n        vec![],\r\n    )]\r\n    fn test_parse_function_parameter_wrong_cases(\r\n        #[case] func_src: \u0026str,\r\n        #[case] path_params: Vec\u003cString\u003e,\r\n    ) {\r\n        let func: syn::ItemFn = syn::parse_str(func_src).unwrap();\r\n        let (known_schemas, struct_definitions) = setup_test_data(func_src);\r\n\r\n        // Provide custom types for header/query known schemas/structs\r\n        let mut struct_definitions = struct_definitions;\r\n        struct_definitions.insert(\r\n            \"User\".to_string(),\r\n            \"pub struct User { pub id: i32 }\".to_string(),\r\n        );\r\n        let mut known_schemas = known_schemas;\r\n        known_schemas.insert(\r\n            \"CustomHeader\".to_string(),\r\n            \"#/components/schemas/CustomHeader\".to_string(),\r\n        );\r\n\r\n        for (idx, arg) in func.sig.inputs.iter().enumerate() {\r\n            let result =\r\n                parse_function_parameter(arg, \u0026path_params, \u0026known_schemas, \u0026struct_definitions);\r\n            assert!(\r\n                result.is_none(),\r\n                \"Expected None at arg index {}, func: {}, got: {:?}\",\r\n                idx,\r\n                func_src,\r\n                result\r\n            );\r\n        }\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\"i32\", true)]\r\n    #[case(\"Vec\u003cString\u003e\", true)]\r\n    #[case(\"Option\u003cbool\u003e\", true)]\r\n    #[case(\"CustomType\", false)]\r\n    fn test_is_primitive_like_fn(#[case] type_str: \u0026str, #[case] expected: bool) {\r\n        let ty: Type = syn::parse_str(type_str).unwrap();\r\n        assert_eq!(is_primitive_like(\u0026ty), expected, \"type_str={}\", type_str);\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\"HashMap\u003cString, String\u003e\", true)]\r\n    #[case(\"BTreeMap\u003cString, String\u003e\", true)]\r\n    #[case(\"String\", false)]\r\n    #[case(\"Vec\u003ci32\u003e\", false)]\r\n    fn test_is_map_type(#[case] type_str: \u0026str, #[case] expected: bool) {\r\n        let ty: Type = syn::parse_str(type_str).unwrap();\r\n        assert_eq!(is_map_type(\u0026ty), expected, \"type_str={}\", type_str);\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\"i32\", HashMap::new(), HashMap::new(), true)] // primitive type\r\n    #[case(\r\n        \"User\",\r\n        HashMap::new(),\r\n        {\r\n            let mut map = HashMap::new();\r\n            map.insert(\"User\".to_string(), \"pub struct User { id: i32 }\".to_string());\r\n            map\r\n        },\r\n        true\r\n    )] // known struct\r\n    #[case(\r\n        \"Product\",\r\n        {\r\n            let mut map = HashMap::new();\r\n            map.insert(\"Product\".to_string(), \"Product\".to_string());\r\n            map\r\n        },\r\n        HashMap::new(),\r\n        true\r\n    )] // known schema\r\n    #[case(\"Vec\u003ci32\u003e\", HashMap::new(), HashMap::new(), true)] // Vec\u003cT\u003e with known inner type\r\n    #[case(\"Option\u003cString\u003e\", HashMap::new(), HashMap::new(), true)] // Option\u003cT\u003e with known inner type\r\n    #[case(\"UnknownType\", HashMap::new(), HashMap::new(), false)] // unknown type\r\n    fn test_is_known_type(\r\n        #[case] type_str: \u0026str,\r\n        #[case] known_schemas: HashMap\u003cString, String\u003e,\r\n        #[case] struct_definitions: HashMap\u003cString, String\u003e,\r\n        #[case] expected: bool,\r\n    ) {\r\n        let ty: Type = syn::parse_str(type_str).unwrap();\r\n        assert_eq!(\r\n            is_known_type(\u0026ty, \u0026known_schemas, \u0026struct_definitions),\r\n            expected,\r\n            \"Type: {}\",\r\n            type_str\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_parse_query_struct_to_parameters() {\r\n        let mut struct_definitions = HashMap::new();\r\n        let mut known_schemas = HashMap::new();\r\n\r\n        // Test with struct that has fields\r\n        struct_definitions.insert(\r\n            \"QueryParams\".to_string(),\r\n            r#\"\r\n            #[serde(rename_all = \"camelCase\")]\r\n            pub struct QueryParams {\r\n                pub page: i32,\r\n                #[serde(rename = \"per_page\")]\r\n                pub limit: Option\u003ci32\u003e,\r\n                pub search: String,\r\n            }\r\n            \"#\r\n            .to_string(),\r\n        );\r\n\r\n        let ty: Type = syn::parse_str(\"QueryParams\").unwrap();\r\n        let result = parse_query_struct_to_parameters(\u0026ty, \u0026known_schemas, \u0026struct_definitions);\r\n        assert!(result.is_some());\r\n        let params = result.unwrap();\r\n        assert_eq!(params.len(), 3);\r\n        assert_eq!(params[0].name, \"page\");\r\n        assert_eq!(params[0].r#in, ParameterLocation::Query);\r\n        assert_eq!(params[1].name, \"per_page\");\r\n        assert_eq!(params[1].r#in, ParameterLocation::Query);\r\n        assert_eq!(params[2].name, \"search\");\r\n        assert_eq!(params[2].r#in, ParameterLocation::Query);\r\n\r\n        // Test with struct that has nested struct (ref to inline conversion)\r\n        struct_definitions.insert(\r\n            \"NestedQuery\".to_string(),\r\n            r#\"\r\n            pub struct NestedQuery {\r\n                pub user: User,\r\n            }\r\n            \"#\r\n            .to_string(),\r\n        );\r\n        struct_definitions.insert(\r\n            \"User\".to_string(),\r\n            r#\"\r\n            pub struct User {\r\n                pub id: i32,\r\n            }\r\n            \"#\r\n            .to_string(),\r\n        );\r\n        known_schemas.insert(\"User\".to_string(), \"#/components/schemas/User\".to_string());\r\n\r\n        let ty: Type = syn::parse_str(\"NestedQuery\").unwrap();\r\n        let result = parse_query_struct_to_parameters(\u0026ty, \u0026known_schemas, \u0026struct_definitions);\r\n        assert!(result.is_some());\r\n\r\n        // Test with non-struct type\r\n        let ty: Type = syn::parse_str(\"i32\").unwrap();\r\n        let result = parse_query_struct_to_parameters(\u0026ty, \u0026known_schemas, \u0026struct_definitions);\r\n        assert!(result.is_none());\r\n\r\n        // Test with unknown struct\r\n        let ty: Type = syn::parse_str(\"UnknownStruct\").unwrap();\r\n        let result = parse_query_struct_to_parameters(\u0026ty, \u0026known_schemas, \u0026struct_definitions);\r\n        assert!(result.is_none());\r\n\r\n        // Test with struct that has Option\u003cT\u003e fields\r\n        struct_definitions.insert(\r\n            \"OptionalQuery\".to_string(),\r\n            r#\"\r\n            pub struct OptionalQuery {\r\n                pub required: i32,\r\n                pub optional: Option\u003cString\u003e,\r\n            }\r\n            \"#\r\n            .to_string(),\r\n        );\r\n\r\n        let ty: Type = syn::parse_str(\"OptionalQuery\").unwrap();\r\n        let result = parse_query_struct_to_parameters(\u0026ty, \u0026known_schemas, \u0026struct_definitions);\r\n        assert!(result.is_some());\r\n        let params = result.unwrap();\r\n        assert_eq!(params.len(), 2);\r\n        assert_eq!(params[0].required, Some(true));\r\n        assert_eq!(params[1].required, Some(false));\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":23,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":27,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":28,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":29,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":31,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":32,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":34,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":36,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":39,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":43,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":44,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":45,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":46,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":47,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":50,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":51,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":52,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":53,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":54,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":56,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":57,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":59,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":61,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":62,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":63,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":64,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":65,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":76,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":77,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":78,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":80,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":81,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":83,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":84,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":86,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":87,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":88,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":91,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":93,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":94,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":97,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":98,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":99,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":100,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":101,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":102,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":103,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":104,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":105,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":106,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":107,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":108,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":111,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":116,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":117,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":122,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":123,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":125,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":127,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":129,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":130,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":131,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":132,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":133,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":134,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":136,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":141,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":143,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":144,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":145,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":148,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":149,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":154,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":155,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":156,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":158,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":162,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":163,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":168,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":169,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":189,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":190,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":191,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":194,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":195,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":197,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":198,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":199,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":200,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":201,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":202,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":203,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":204,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":205,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":207,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":211,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":214,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":215,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":216,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":217,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":218,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":219,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":220,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":223,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":225,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":227,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":233,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":254,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":255,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":256,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":257,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":258,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":259,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":260,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":267,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":268,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":270,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":271,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":273,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":274,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":275,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":276,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":277,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":279,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":282,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":285,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":291,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":292,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":296,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":297,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":298,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":303,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":308,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":309,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":313,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":314,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":315,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":316,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":317,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":330,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":336,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":337,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":338,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":343,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":348,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":349,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":351,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":354,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":356,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":357,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":358,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":359,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":361,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":362,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":365,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":366,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":369,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":372,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":375,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":376,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":377,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":378,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":379,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":380,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":381,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":382,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":383,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":389,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":390,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":391,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":396,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":398,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":399,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":400,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":401,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":402,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":406,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":407,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":408,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":410,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":415,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":416,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":417,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":418,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":437,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":439,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":440,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":441,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":442,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":443,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":444,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":445,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":450,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":451,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":455,"address":[],"length":0,"stats":{"Line":432345564227567616}}],"covered":210,"coverable":239},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","path.rs"],"content":"/// Extract path parameters from a path string\r\npub fn extract_path_parameters(path: \u0026str) -\u003e Vec\u003cString\u003e {\r\n    let mut params = Vec::new();\r\n    let segments: Vec\u003c\u0026str\u003e = path.split('/').collect();\r\n\r\n    for segment in segments {\r\n        if segment.starts_with('{') \u0026\u0026 segment.ends_with('}') {\r\n            let param = segment.trim_start_matches('{').trim_end_matches('}');\r\n            params.push(param.to_string());\r\n        } else if segment.starts_with(':') {\r\n            let param = segment.trim_start_matches(':');\r\n            params.push(param.to_string());\r\n        }\r\n    }\r\n\r\n    params\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use rstest::rstest;\r\n\r\n    #[rstest]\r\n    #[case(\"/test\", vec![])]\r\n    #[case(\"/test/{id}\", vec![\"id\"])]\r\n    #[case(\"/test/{id}/test/{test_id}\", vec![\"id\", \"test_id\"])]\r\n    #[case(\"/test/:id/test/:test_id\", vec![\"id\", \"test_id\"])]\r\n    fn test_extract_path_parameters(#[case] path: \u0026str, #[case] expected: Vec\u003c\u0026str\u003e) {\r\n        assert_eq!(extract_path_parameters(path), expected);\r\n    }\r\n}\r\n","traces":[{"line":2,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":3,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":4,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":6,"address":[],"length":0,"stats":{"Line":10304235947423694848}},{"line":7,"address":[],"length":0,"stats":{"Line":11601272640106397696}},{"line":8,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":9,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":10,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":11,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":12,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":16,"address":[],"length":0,"stats":{"Line":1513209474796486656}}],"covered":11,"coverable":11},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","request_body.rs"],"content":"use std::collections::BTreeMap;\r\n\r\nuse syn::{FnArg, PatType, Type};\r\nuse vespera_core::route::{MediaType, RequestBody};\r\n\r\nuse super::schema::parse_type_to_schema_ref_with_schemas;\r\n\r\nfn is_string_like(ty: \u0026Type) -\u003e bool {\r\n    match ty {\r\n        Type::Path(type_path) =\u003e type_path\r\n            .path\r\n            .segments\r\n            .last()\r\n            .map(|seg| seg.ident == \"String\" || seg.ident == \"str\")\r\n            .unwrap_or(false),\r\n        Type::Reference(type_ref) =\u003e is_string_like(\u0026type_ref.elem),\r\n        _ =\u003e false,\r\n    }\r\n}\r\n\r\n/// Analyze function signature and extract RequestBody\r\npub fn parse_request_body(\r\n    arg: \u0026FnArg,\r\n    known_schemas: \u0026std::collections::HashMap\u003cString, String\u003e,\r\n    struct_definitions: \u0026std::collections::HashMap\u003cString, String\u003e,\r\n) -\u003e Option\u003cRequestBody\u003e {\r\n    match arg {\r\n        FnArg::Receiver(_) =\u003e None,\r\n        FnArg::Typed(PatType { ty, .. }) =\u003e {\r\n            if let Type::Path(type_path) = ty.as_ref() {\r\n                let path = \u0026type_path.path;\r\n\r\n                // Check the last segment (handles both Json\u003cT\u003e and vespera::axum::Json\u003cT\u003e)\r\n                let segment = path.segments.last().unwrap();\r\n                let ident_str = segment.ident.to_string();\r\n\r\n                if ident_str == \"Json\"\r\n                    \u0026\u0026 let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n                    \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first()\r\n                {\r\n                    let schema = parse_type_to_schema_ref_with_schemas(\r\n                        inner_ty,\r\n                        known_schemas,\r\n                        struct_definitions,\r\n                    );\r\n                    let mut content = BTreeMap::new();\r\n                    content.insert(\r\n                        \"application/json\".to_string(),\r\n                        MediaType {\r\n                            schema: Some(schema),\r\n                            example: None,\r\n                            examples: None,\r\n                        },\r\n                    );\r\n                    return Some(RequestBody {\r\n                        description: None,\r\n                        required: Some(true),\r\n                        content,\r\n                    });\r\n                }\r\n            }\r\n\r\n            if is_string_like(ty.as_ref()) {\r\n                let schema =\r\n                    parse_type_to_schema_ref_with_schemas(ty, known_schemas, struct_definitions);\r\n                let mut content = BTreeMap::new();\r\n                content.insert(\r\n                    \"text/plain\".to_string(),\r\n                    MediaType {\r\n                        schema: Some(schema),\r\n                        example: None,\r\n                        examples: None,\r\n                    },\r\n                );\r\n\r\n                return Some(RequestBody {\r\n                    description: None,\r\n                    required: Some(true),\r\n                    content,\r\n                });\r\n            }\r\n            None\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use insta::{assert_debug_snapshot, with_settings};\r\n    use rstest::rstest;\r\n    use std::collections::HashMap;\r\n\r\n    #[rstest]\r\n    #[case(\"String\", true)]\r\n    #[case(\"str\", true)]\r\n    #[case(\"\u0026String\", true)]\r\n    #[case(\"\u0026str\", true)]\r\n    #[case(\"i32\", false)]\r\n    #[case(\"Vec\u003cString\u003e\", false)]\r\n    #[case(\"!\", false)]\r\n    fn test_is_string_like_cases(#[case] ty_src: \u0026str, #[case] expected: bool) {\r\n        let ty: Type = syn::parse_str(ty_src).expect(\"type parse failed\");\r\n        assert_eq!(is_string_like(\u0026ty), expected);\r\n    }\r\n\r\n    #[rstest]\r\n    #[case::json(\"fn test(Json(payload): Json\u003cUser\u003e) {}\", true, \"json\")]\r\n    #[case::string(\"fn test(just_string: String) {}\", true, \"string\")]\r\n    #[case::str(\"fn test(just_str: \u0026str) {}\", true, \"str\")]\r\n    #[case::i32(\"fn test(just_i32: i32) {}\", false, \"i32\")]\r\n    #[case::vec_string(\"fn test(just_vec_string: Vec\u003cString\u003e) {}\", false, \"vec_string\")]\r\n    #[case::self_ref(\"fn test(\u0026self) {}\", false, \"self_ref\")]\r\n    fn test_parse_request_body_cases(\r\n        #[case] func_src: \u0026str,\r\n        #[case] has_body: bool,\r\n        #[case] suffix: \u0026str,\r\n    ) {\r\n        let func: syn::ItemFn = syn::parse_str(func_src).unwrap();\r\n        let arg = func.sig.inputs.first().unwrap();\r\n        let body = parse_request_body(arg, \u0026HashMap::new(), \u0026HashMap::new());\r\n        assert_eq!(body.is_some(), has_body);\r\n        with_settings!({ snapshot_suffix =\u003e format!(\"req_body_{}\", suffix) }, {\r\n            assert_debug_snapshot!(body);\r\n        });\r\n    }\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":9,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":10,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":11,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":12,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":14,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":16,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":17,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":27,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":28,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":29,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":30,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":31,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":34,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":35,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":37,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":38,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":39,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":43,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":44,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":46,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":48,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":49,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":50,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":52,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":55,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":56,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":58,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":63,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":64,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":65,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":66,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":67,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":68,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":69,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":70,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":71,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":72,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":76,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":77,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":78,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":79,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":82,"address":[],"length":0,"stats":{"Line":360287970189639680}}],"covered":48,"coverable":48},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","response.rs"],"content":"use std::collections::{BTreeMap, HashMap};\r\n\r\nuse syn::{ReturnType, Type};\r\nuse vespera_core::route::{Header, MediaType, Response};\r\n\r\nuse crate::parser::is_keyword_type::{KeywordType, is_keyword_type, is_keyword_type_by_type_path};\r\n\r\nuse super::schema::parse_type_to_schema_ref_with_schemas;\r\n\r\n/// Unwrap Json\u003cT\u003e to get T\r\n/// Handles both Json\u003cT\u003e and vespera::axum::Json\u003cT\u003e by checking the last segment\r\nfn unwrap_json(ty: \u0026Type) -\u003e \u0026Type {\r\n    if let Type::Path(type_path) = ty {\r\n        let path = \u0026type_path.path;\r\n        if !path.segments.is_empty() {\r\n            // Check the last segment (handles both Json\u003cT\u003e and vespera::axum::Json\u003cT\u003e)\r\n            let segment = path.segments.last().unwrap();\r\n            if segment.ident == \"Json\"\r\n                \u0026\u0026 let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n                \u0026\u0026 let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first()\r\n            {\r\n                return inner_ty;\r\n            }\r\n        }\r\n    }\r\n    ty\r\n}\r\n\r\n/// Extract Ok and Err types from Result\u003cT, E\u003e or Result\u003cJson\u003cT\u003e, E\u003e\r\n/// Handles both Result and std::result::Result, and unwraps references\r\nfn extract_result_types(ty: \u0026Type) -\u003e Option\u003c(Type, Type)\u003e {\r\n    // First unwrap Json if present\r\n    let unwrapped = unwrap_json(ty);\r\n\r\n    // Handle both Type::Path and Type::Reference (for \u0026Result\u003c...\u003e)\r\n    let result_type = if let Type::Path(type_path) = unwrapped {\r\n        type_path\r\n    } else if let Type::Reference(type_ref) = unwrapped\r\n        \u0026\u0026 let Type::Path(type_path) = type_ref.elem.as_ref()\r\n    {\r\n        type_path\r\n    } else {\r\n        return None;\r\n    };\r\n\r\n    let path = \u0026result_type.path;\r\n    if path.segments.is_empty() {\r\n        return None;\r\n    }\r\n\r\n    if is_keyword_type_by_type_path(result_type, \u0026KeywordType::Result)\r\n        \u0026\u0026 let Some(segment) = path.segments.last()\r\n        \u0026\u0026 let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments\r\n        \u0026\u0026 args.args.len() \u003e= 2\r\n        \u0026\u0026 let (Some(syn::GenericArgument::Type(ok_ty)), Some(syn::GenericArgument::Type(err_ty))) =\r\n            (args.args.first(), args.args.get(1))\r\n    {\r\n        // Get the last segment (Result) to check for generics\r\n        // Unwrap Json from Ok type if present\r\n        let ok_ty_unwrapped = unwrap_json(ok_ty);\r\n        return Some((ok_ty_unwrapped.clone(), err_ty.clone()));\r\n    }\r\n    None\r\n}\r\n\r\n/// Check if error type is a tuple (StatusCode, E) or (StatusCode, Json\u003cE\u003e)\r\n/// Returns the error type E and a default status code (400)\r\nfn extract_status_code_tuple(err_ty: \u0026Type) -\u003e Option\u003c(u16, Type)\u003e {\r\n    if let Type::Tuple(tuple) = err_ty\r\n        \u0026\u0026 tuple\r\n            .elems\r\n            .iter()\r\n            .any(|ty| is_keyword_type(ty, \u0026KeywordType::StatusCode))\r\n    {\r\n        Some((400, unwrap_json(tuple.elems.last().unwrap()).clone()))\r\n    } else {\r\n        None\r\n    }\r\n}\r\n\r\n/// Extract payload type from an Ok tuple and track if headers exist.\r\n/// The last element of the tuple is always treated as the response body.\r\n/// Any presence of HeaderMap in the tuple marks headers as present.\r\nfn extract_ok_payload_and_headers(ok_ty: \u0026Type) -\u003e (Type, Option\u003cHashMap\u003cString, Header\u003e\u003e) {\r\n    if let Type::Tuple(tuple) = ok_ty {\r\n        let payload_ty = tuple.elems.last().map(|ty| unwrap_json(ty).clone());\r\n\r\n        if let Some(payload_ty) = payload_ty {\r\n            let headers = if tuple\r\n                .elems\r\n                .iter()\r\n                .any(|ty| is_keyword_type(ty, \u0026KeywordType::HeaderMap))\r\n            {\r\n                Some(HashMap::new())\r\n            } else {\r\n                None\r\n            };\r\n            return (payload_ty, headers);\r\n        }\r\n    }\r\n\r\n    (ok_ty.clone(), None)\r\n}\r\n\r\n/// Analyze return type and convert to Responses map\r\npub fn parse_return_type(\r\n    return_type: \u0026ReturnType,\r\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\r\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\r\n) -\u003e BTreeMap\u003cString, Response\u003e {\r\n    let mut responses = BTreeMap::new();\r\n\r\n    match return_type {\r\n        ReturnType::Default =\u003e {\r\n            // No return type - just 200 with no content\r\n            responses.insert(\r\n                \"200\".to_string(),\r\n                Response {\r\n                    description: \"Successful response\".to_string(),\r\n                    headers: None,\r\n                    content: None,\r\n                },\r\n            );\r\n        }\r\n        ReturnType::Type(_, ty) =\u003e {\r\n            // Check if it's a Result\u003cT, E\u003e\r\n            if let Some((ok_ty, err_ty)) = extract_result_types(ty) {\r\n                // Handle success response (200)\r\n                let (ok_payload_ty, ok_headers) = extract_ok_payload_and_headers(\u0026ok_ty);\r\n                let ok_schema = parse_type_to_schema_ref_with_schemas(\r\n                    \u0026ok_payload_ty,\r\n                    known_schemas,\r\n                    struct_definitions,\r\n                );\r\n                let mut ok_content = BTreeMap::new();\r\n                ok_content.insert(\r\n                    \"application/json\".to_string(),\r\n                    MediaType {\r\n                        schema: Some(ok_schema),\r\n                        example: None,\r\n                        examples: None,\r\n                    },\r\n                );\r\n\r\n                responses.insert(\r\n                    \"200\".to_string(),\r\n                    Response {\r\n                        description: \"Successful response\".to_string(),\r\n                        headers: ok_headers,\r\n                        content: Some(ok_content),\r\n                    },\r\n                );\r\n\r\n                // Handle error response\r\n                // Check if error is (StatusCode, E) tuple\r\n                if let Some((status_code, error_type)) = extract_status_code_tuple(\u0026err_ty) {\r\n                    // Use the status code from the tuple\r\n                    let err_schema = parse_type_to_schema_ref_with_schemas(\r\n                        \u0026error_type,\r\n                        known_schemas,\r\n                        struct_definitions,\r\n                    );\r\n                    let mut err_content = BTreeMap::new();\r\n                    err_content.insert(\r\n                        \"application/json\".to_string(),\r\n                        MediaType {\r\n                            schema: Some(err_schema),\r\n                            example: None,\r\n                            examples: None,\r\n                        },\r\n                    );\r\n\r\n                    responses.insert(\r\n                        status_code.to_string(),\r\n                        Response {\r\n                            description: \"Error response\".to_string(),\r\n                            headers: None,\r\n                            content: Some(err_content),\r\n                        },\r\n                    );\r\n                } else {\r\n                    // Regular error type - use default 400\r\n                    // Unwrap Json if present\r\n                    let err_ty_unwrapped = unwrap_json(\u0026err_ty);\r\n                    let err_schema = parse_type_to_schema_ref_with_schemas(\r\n                        err_ty_unwrapped,\r\n                        known_schemas,\r\n                        struct_definitions,\r\n                    );\r\n                    let mut err_content = BTreeMap::new();\r\n                    err_content.insert(\r\n                        \"application/json\".to_string(),\r\n                        MediaType {\r\n                            schema: Some(err_schema),\r\n                            example: None,\r\n                            examples: None,\r\n                        },\r\n                    );\r\n\r\n                    responses.insert(\r\n                        \"400\".to_string(),\r\n                        Response {\r\n                            description: \"Error response\".to_string(),\r\n                            headers: None,\r\n                            content: Some(err_content),\r\n                        },\r\n                    );\r\n                }\r\n            } else {\r\n                // Not a Result type - regular response\r\n                // Unwrap Json\u003cT\u003e if present\r\n                let unwrapped_ty = unwrap_json(ty);\r\n                let schema = parse_type_to_schema_ref_with_schemas(\r\n                    unwrapped_ty,\r\n                    known_schemas,\r\n                    struct_definitions,\r\n                );\r\n                let mut content = BTreeMap::new();\r\n                content.insert(\r\n                    \"application/json\".to_string(),\r\n                    MediaType {\r\n                        schema: Some(schema),\r\n                        example: None,\r\n                        examples: None,\r\n                    },\r\n                );\r\n\r\n                responses.insert(\r\n                    \"200\".to_string(),\r\n                    Response {\r\n                        description: \"Successful response\".to_string(),\r\n                        headers: None,\r\n                        content: Some(content),\r\n                    },\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    responses\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use rstest::rstest;\r\n    use std::collections::HashMap;\r\n    use vespera_core::schema::{SchemaRef, SchemaType};\r\n\r\n    #[derive(Debug)]\r\n    struct ExpectedSchema {\r\n        schema_type: SchemaType,\r\n        nullable: bool,\r\n        items_schema_type: Option\u003cSchemaType\u003e,\r\n    }\r\n\r\n    #[derive(Debug)]\r\n    struct ExpectedResponse {\r\n        status: \u0026'static str,\r\n        schema: ExpectedSchema,\r\n    }\r\n\r\n    fn parse_return_type_str(return_type_str: \u0026str) -\u003e syn::ReturnType {\r\n        if return_type_str.is_empty() {\r\n            syn::ReturnType::Default\r\n        } else {\r\n            let full_signature = format!(\"fn test() {}\", return_type_str);\r\n            syn::parse_str::\u003csyn::Signature\u003e(\u0026full_signature)\r\n                .expect(\"Failed to parse return type\")\r\n                .output\r\n        }\r\n    }\r\n\r\n    fn assert_schema_matches(schema_ref: \u0026SchemaRef, expected: \u0026ExpectedSchema) {\r\n        match schema_ref {\r\n            SchemaRef::Inline(schema) =\u003e {\r\n                assert_eq!(schema.schema_type, Some(expected.schema_type.clone()));\r\n                assert_eq!(schema.nullable.unwrap_or(false), expected.nullable);\r\n                if let Some(item_ty) = \u0026expected.items_schema_type {\r\n                    let items = schema\r\n                        .items\r\n                        .as_ref()\r\n                        .expect(\"items should be present for array\");\r\n                    match items.as_ref() {\r\n                        SchemaRef::Inline(item_schema) =\u003e {\r\n                            assert_eq!(item_schema.schema_type, Some(item_ty.clone()));\r\n                        }\r\n                        SchemaRef::Ref(_) =\u003e panic!(\"expected inline schema for array items\"),\r\n                    }\r\n                }\r\n            }\r\n            SchemaRef::Ref(_) =\u003e panic!(\"expected inline schema\"),\r\n        }\r\n    }\r\n\r\n    #[rstest]\r\n    #[case(\"\", None, None, None)]\r\n    #[case(\r\n        \"-\u003e String\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        None,\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e \u0026str\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        None,\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e i32\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::Integer, nullable: false, items_schema_type: None }),\r\n        None,\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e bool\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::Boolean, nullable: false, items_schema_type: None }),\r\n        None,\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Vec\u003cString\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::Array, nullable: false, items_schema_type: Some(SchemaType::String) }),\r\n        None,\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Option\u003cString\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: true, items_schema_type: None }),\r\n        None,\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003cString, String\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003ci32, String\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::Integer, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003cJson\u003cUser\u003e, String\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::Object, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003c\u0026str, String\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003cString, (StatusCode, String)\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003cString, (StatusCode, Json\u003cString\u003e)\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003c(HeaderMap\u003cString, String\u003e, Json\u003ci32\u003e), String\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::Integer, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None } }),\r\n        Some(true)\r\n    )]\r\n    #[case(\r\n        \"-\u003e Result\u003cString, (axum::http::StatusCode, Json\u003ci32\u003e)\u003e\",\r\n        Some(ExpectedSchema { schema_type: SchemaType::String, nullable: false, items_schema_type: None }),\r\n        Some(ExpectedResponse { status: \"400\", schema: ExpectedSchema { schema_type: SchemaType::Integer, nullable: false, items_schema_type: None } }),\r\n        None\r\n    )]\r\n    fn test_parse_return_type(\r\n        #[case] return_type_str: \u0026str,\r\n        #[case] ok_expectation: Option\u003cExpectedSchema\u003e,\r\n        #[case] err_expectation: Option\u003cExpectedResponse\u003e,\r\n        #[case] ok_headers_expected: Option\u003cbool\u003e,\r\n    ) {\r\n        let known_schemas = HashMap::new();\r\n        let struct_definitions = HashMap::new();\r\n        let return_type = parse_return_type_str(return_type_str);\r\n\r\n        let responses = parse_return_type(\u0026return_type, \u0026known_schemas, \u0026struct_definitions);\r\n\r\n        // Validate success response\r\n        let ok_response = responses.get(\"200\").expect(\"200 response should exist\");\r\n        assert_eq!(ok_response.description, \"Successful response\");\r\n        match \u0026ok_expectation {\r\n            None =\u003e {\r\n                assert!(ok_response.content.is_none());\r\n            }\r\n            Some(expected_schema) =\u003e {\r\n                let content = ok_response\r\n                    .content\r\n                    .as_ref()\r\n                    .expect(\"ok content should exist\");\r\n                let media_type = content\r\n                    .get(\"application/json\")\r\n                    .expect(\"ok media type should exist\");\r\n                let schema_ref = media_type.schema.as_ref().expect(\"ok schema should exist\");\r\n                assert_schema_matches(schema_ref, expected_schema);\r\n            }\r\n        }\r\n        if let Some(expect_headers) = ok_headers_expected {\r\n            assert_eq!(ok_response.headers.is_some(), expect_headers);\r\n        }\r\n\r\n        // Validate error response (if any)\r\n        match \u0026err_expectation {\r\n            None =\u003e assert_eq!(responses.len(), 1),\r\n            Some(err) =\u003e {\r\n                assert_eq!(responses.len(), 2);\r\n                let err_response = responses\r\n                    .get(err.status)\r\n                    .expect(\"error response should exist\");\r\n                assert_eq!(err_response.description, \"Error response\");\r\n                let content = err_response\r\n                    .content\r\n                    .as_ref()\r\n                    .expect(\"error content should exist\");\r\n                let media_type = content\r\n                    .get(\"application/json\")\r\n                    .expect(\"error media type should exist\");\r\n                let schema_ref = media_type\r\n                    .schema\r\n                    .as_ref()\r\n                    .expect(\"error schema should exist\");\r\n                assert_schema_matches(schema_ref, \u0026err.schema);\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":13,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":14,"address":[],"length":0,"stats":{"Line":10088063165309911040}},{"line":15,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":17,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":18,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":19,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":20,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":22,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":26,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":31,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":33,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":36,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":37,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":41,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":47,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":52,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":53,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":54,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":55,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":56,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":60,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":61,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":63,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":68,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":69,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":71,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":72,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":73,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":75,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":77,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":84,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":85,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":86,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":89,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":90,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":92,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":94,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":102,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":106,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":111,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":113,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":114,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":116,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":117,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":118,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":119,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":120,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":121,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":125,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":127,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":129,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":131,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":132,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":133,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":135,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":136,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":137,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":138,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":139,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":140,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":141,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":145,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":146,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":147,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":148,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":149,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":150,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":156,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":159,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":160,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":161,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":163,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":164,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":165,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":166,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":167,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":168,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":169,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":173,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":174,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":175,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":176,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":177,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":178,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":184,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":186,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":187,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":188,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":190,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":191,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":192,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":193,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":194,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":195,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":196,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":200,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":201,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":202,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":203,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":204,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":205,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":212,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":214,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":215,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":216,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":218,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":219,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":220,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":221,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":222,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":223,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":224,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":228,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":229,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":230,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":231,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":232,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":233,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":240,"address":[],"length":0,"stats":{"Line":2305843009213693952}}],"covered":127,"coverable":130},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","parser","schema.rs"],"content":"use std::collections::{BTreeMap, HashMap};\n\nuse syn::{Fields, Type};\nuse vespera_core::schema::{Reference, Schema, SchemaRef, SchemaType};\n\npub fn extract_rename_all(attrs: \u0026[syn::Attribute]) -\u003e Option\u003cString\u003e {\n    for attr in attrs {\n        if attr.path().is_ident(\"serde\") {\n            // Try using parse_nested_meta for robust parsing\n            let mut found_rename_all = None;\n            let _ = attr.parse_nested_meta(|meta| {\n                if meta.path.is_ident(\"rename_all\")\n                    \u0026\u0026 let Ok(value) = meta.value()\n                    \u0026\u0026 let Ok(syn::Expr::Lit(syn::ExprLit {\n                        lit: syn::Lit::Str(s),\n                        ..\n                    })) = value.parse::\u003csyn::Expr\u003e()\n                {\n                    found_rename_all = Some(s.value());\n                }\n                Ok(())\n            });\n            if found_rename_all.is_some() {\n                return found_rename_all;\n            }\n\n            // Fallback: manual token parsing\n            let tokens = match attr.meta.require_list() {\n                Ok(t) =\u003e t,\n                Err(_) =\u003e continue,\n            };\n            let token_str = tokens.tokens.to_string();\n\n            // Look for rename_all = \"...\" pattern\n            if let Some(start) = token_str.find(\"rename_all\") {\n                let remaining = \u0026token_str[start + \"rename_all\".len()..];\n                if let Some(equals_pos) = remaining.find('=') {\n                    let value_part = remaining[equals_pos + 1..].trim();\n                    // Extract string value - find the closing quote\n                    if let Some(quote_start) = value_part.find('\"') {\n                        let after_quote = \u0026value_part[quote_start + 1..];\n                        if let Some(quote_end) = after_quote.find('\"') {\n                            let value = \u0026after_quote[..quote_end];\n                            return Some(value.to_string());\n                        }\n                    }\n                }\n            }\n        }\n    }\n    None\n}\n\npub fn extract_field_rename(attrs: \u0026[syn::Attribute]) -\u003e Option\u003cString\u003e {\n    for attr in attrs {\n        if attr.path().is_ident(\"serde\")\n            \u0026\u0026 let syn::Meta::List(meta_list) = \u0026attr.meta\n        {\n            // Use parse_nested_meta to parse nested attributes\n            let mut found_rename = None;\n            let _ = attr.parse_nested_meta(|meta| {\n                if meta.path.is_ident(\"rename\")\n                    \u0026\u0026 let Ok(value) = meta.value()\n                    \u0026\u0026 let Ok(syn::Expr::Lit(syn::ExprLit {\n                        lit: syn::Lit::Str(s),\n                        ..\n                    })) = value.parse::\u003csyn::Expr\u003e()\n                {\n                    found_rename = Some(s.value());\n                }\n                Ok(())\n            });\n            if let Some(rename_value) = found_rename {\n                return Some(rename_value);\n            }\n\n            // Fallback: manual token parsing with regex-like approach\n            let tokens = meta_list.tokens.to_string();\n            // Look for pattern: rename = \"value\" (with proper word boundaries)\n            if let Some(start) = tokens.find(\"rename\") {\n                // Avoid false positives from rename_all\n                if tokens[start..].starts_with(\"rename_all\") {\n                    continue;\n                }\n                // Check that \"rename\" is a standalone word (not part of another word)\n                let before = if start \u003e 0 { \u0026tokens[..start] } else { \"\" };\n                let after_start = start + \"rename\".len();\n                let after = if after_start \u003c tokens.len() {\n                    \u0026tokens[after_start..]\n                } else {\n                    \"\"\n                };\n\n                let before_char = before.chars().last().unwrap_or(' ');\n                let after_char = after.chars().next().unwrap_or(' ');\n\n                // Check if rename is a standalone word (preceded by space/comma/paren, followed by space/equals)\n                if (before_char == ' ' || before_char == ',' || before_char == '(')\n                    \u0026\u0026 (after_char == ' ' || after_char == '=')\n                {\n                    // Find the equals sign and extract the quoted value\n                    if let Some(equals_pos) = after.find('=') {\n                        let value_part = \u0026after[equals_pos + 1..].trim();\n                        // Extract string value (remove quotes)\n                        if let Some(quote_start) = value_part.find('\"') {\n                            let after_quote = \u0026value_part[quote_start + 1..];\n                            if let Some(quote_end) = after_quote.find('\"') {\n                                let value = \u0026after_quote[..quote_end];\n                                return Some(value.to_string());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    None\n}\n\n/// Extract skip attribute from field attributes\n/// Returns true if #[serde(skip)] is present\npub(super) fn extract_skip(attrs: \u0026[syn::Attribute]) -\u003e bool {\n    for attr in attrs {\n        if attr.path().is_ident(\"serde\")\n            \u0026\u0026 let syn::Meta::List(meta_list) = \u0026attr.meta\n        {\n            let tokens = meta_list.tokens.to_string();\n            // Check for \"skip\" (not part of skip_serializing_if or skip_deserializing)\n            if tokens.contains(\"skip\") {\n                // Make sure it's not skip_serializing_if or skip_deserializing\n                if !tokens.contains(\"skip_serializing_if\") \u0026\u0026 !tokens.contains(\"skip_deserializing\")\n                {\n                    // Check if it's a standalone \"skip\"\n                    let skip_pos = tokens.find(\"skip\");\n                    if let Some(pos) = skip_pos {\n                        let before = if pos \u003e 0 { \u0026tokens[..pos] } else { \"\" };\n                        let after = \u0026tokens[pos + \"skip\".len()..];\n                        // Check if skip is not part of another word\n                        let before_char = before.chars().last().unwrap_or(' ');\n                        let after_char = after.chars().next().unwrap_or(' ');\n                        if (before_char == ' ' || before_char == ',' || before_char == '(')\n                            \u0026\u0026 (after_char == ' ' || after_char == ',' || after_char == ')')\n                        {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    false\n}\n\n/// Extract skip_serializing_if attribute from field attributes\n/// Returns true if #[serde(skip_serializing_if = \"...\")] is present\npub fn extract_skip_serializing_if(attrs: \u0026[syn::Attribute]) -\u003e bool {\n    for attr in attrs {\n        if attr.path().is_ident(\"serde\")\n            \u0026\u0026 let syn::Meta::List(meta_list) = \u0026attr.meta\n        {\n            let mut found = false;\n            let _ = attr.parse_nested_meta(|meta| {\n                if meta.path.is_ident(\"skip_serializing_if\") {\n                    found = true;\n                }\n                Ok(())\n            });\n            if found {\n                return true;\n            }\n\n            // Fallback: check tokens string\n            let tokens = meta_list.tokens.to_string();\n            if tokens.contains(\"skip_serializing_if\") {\n                return true;\n            }\n        }\n    }\n    false\n}\n\n/// Extract default attribute from field attributes\n/// Returns:\n/// - Some(None) if #[serde(default)] is present (no function)\n/// - Some(Some(function_name)) if #[serde(default = \"function_name\")] is present\n/// - None if no default attribute is present\npub fn extract_default(attrs: \u0026[syn::Attribute]) -\u003e Option\u003cOption\u003cString\u003e\u003e {\n    for attr in attrs {\n        if attr.path().is_ident(\"serde\")\n            \u0026\u0026 let syn::Meta::List(meta_list) = \u0026attr.meta\n        {\n            let mut found_default: Option\u003cOption\u003cString\u003e\u003e = None;\n            let _ = attr.parse_nested_meta(|meta| {\n                if meta.path.is_ident(\"default\") {\n                    // Check if it has a value (default = \"function_name\")\n                    if let Ok(value) = meta.value() {\n                        if let Ok(syn::Expr::Lit(syn::ExprLit {\n                            lit: syn::Lit::Str(s),\n                            ..\n                        })) = value.parse::\u003csyn::Expr\u003e()\n                        {\n                            found_default = Some(Some(s.value()));\n                        }\n                    } else {\n                        // Just \"default\" without value\n                        found_default = Some(None);\n                    }\n                }\n                Ok(())\n            });\n            if let Some(default_value) = found_default {\n                return Some(default_value);\n            }\n\n            // Fallback: manual token parsing\n            let tokens = meta_list.tokens.to_string();\n            if let Some(start) = tokens.find(\"default\") {\n                let remaining = \u0026tokens[start + \"default\".len()..];\n                if remaining.trim_start().starts_with('=') {\n                    // default = \"function_name\"\n                    let value_part = remaining.trim_start()[1..].trim();\n                    if value_part.starts_with('\"') \u0026\u0026 value_part.ends_with('\"') {\n                        let function_name = \u0026value_part[1..value_part.len() - 1];\n                        return Some(Some(function_name.to_string()));\n                    }\n                } else {\n                    // Just \"default\" without = (standalone)\n                    let before = if start \u003e 0 { \u0026tokens[..start] } else { \"\" };\n                    let after = \u0026remaining;\n                    let before_char = before.chars().last().unwrap_or(' ');\n                    let after_char = after.chars().next().unwrap_or(' ');\n                    if (before_char == ' ' || before_char == ',' || before_char == '(')\n                        \u0026\u0026 (after_char == ' ' || after_char == ',' || after_char == ')')\n                    {\n                        return Some(None);\n                    }\n                }\n            }\n        }\n    }\n    None\n}\n\npub fn rename_field(field_name: \u0026str, rename_all: Option\u003c\u0026str\u003e) -\u003e String {\n    // \"lowercase\", \"UPPERCASE\", \"PascalCase\", \"camelCase\", \"snake_case\", \"SCREAMING_SNAKE_CASE\", \"kebab-case\", \"SCREAMING-KEBAB-CASE\"\n    match rename_all {\n        Some(\"camelCase\") =\u003e {\n            // Convert snake_case or PascalCase to camelCase\n            let mut result = String::new();\n            let mut capitalize_next = false;\n            let mut in_first_word = true;\n            let chars: Vec\u003cchar\u003e = field_name.chars().collect();\n\n            for (i, \u0026ch) in chars.iter().enumerate() {\n                if ch == '_' {\n                    capitalize_next = true;\n                    in_first_word = false;\n                } else if in_first_word {\n                    // In first word: lowercase until we hit a word boundary\n                    // Word boundary: uppercase char followed by lowercase (e.g., \"XMLParser\" -\u003e \"P\" starts new word)\n                    let next_is_lower = chars.get(i + 1).is_some_and(|c| c.is_lowercase());\n                    if ch.is_uppercase() \u0026\u0026 next_is_lower \u0026\u0026 i \u003e 0 {\n                        // This uppercase starts a new word (e.g., 'P' in \"XMLParser\")\n                        in_first_word = false;\n                        result.push(ch);\n                    } else {\n                        // Still in first word, lowercase it\n                        result.push(ch.to_lowercase().next().unwrap_or(ch));\n                    }\n                } else if capitalize_next {\n                    result.push(ch.to_uppercase().next().unwrap_or(ch));\n                    capitalize_next = false;\n                } else {\n                    result.push(ch);\n                }\n            }\n            result\n        }\n        Some(\"snake_case\") =\u003e {\n            // Convert camelCase to snake_case\n            let mut result = String::new();\n            for (i, ch) in field_name.chars().enumerate() {\n                if ch.is_uppercase() \u0026\u0026 i \u003e 0 {\n                    result.push('_');\n                }\n                result.push(ch.to_lowercase().next().unwrap_or(ch));\n            }\n            result\n        }\n        Some(\"kebab-case\") =\u003e {\n            // Convert snake_case or Camel/PascalCase to kebab-case (lowercase with hyphens)\n            let mut result = String::new();\n            for (i, ch) in field_name.chars().enumerate() {\n                if ch.is_uppercase() {\n                    if i \u003e 0 \u0026\u0026 !result.ends_with('-') {\n                        result.push('-');\n                    }\n                    result.push(ch.to_lowercase().next().unwrap_or(ch));\n                } else if ch == '_' {\n                    result.push('-');\n                } else {\n                    result.push(ch);\n                }\n            }\n            result\n        }\n        Some(\"PascalCase\") =\u003e {\n            // Convert snake_case to PascalCase\n            let mut result = String::new();\n            let mut capitalize_next = true;\n            for ch in field_name.chars() {\n                if ch == '_' {\n                    capitalize_next = true;\n                } else if capitalize_next {\n                    result.push(ch.to_uppercase().next().unwrap_or(ch));\n                    capitalize_next = false;\n                } else {\n                    result.push(ch);\n                }\n            }\n            result\n        }\n        Some(\"lowercase\") =\u003e {\n            // Convert to lowercase\n            field_name.to_lowercase()\n        }\n        Some(\"UPPERCASE\") =\u003e {\n            // Convert to UPPERCASE\n            field_name.to_uppercase()\n        }\n        Some(\"SCREAMING_SNAKE_CASE\") =\u003e {\n            // Convert to SCREAMING_SNAKE_CASE\n            // If already in SCREAMING_SNAKE_CASE format, return as is\n            if field_name.chars().all(|c| c.is_uppercase() || c == '_') \u0026\u0026 field_name.contains('_')\n            {\n                return field_name.to_string();\n            }\n            // First convert to snake_case if needed, then uppercase\n            let mut snake_case = String::new();\n            for (i, ch) in field_name.chars().enumerate() {\n                if ch.is_uppercase() \u0026\u0026 i \u003e 0 \u0026\u0026 !snake_case.ends_with('_') {\n                    snake_case.push('_');\n                }\n                if ch != '_' \u0026\u0026 ch != '-' {\n                    snake_case.push(ch.to_lowercase().next().unwrap_or(ch));\n                } else if ch == '_' {\n                    snake_case.push('_');\n                }\n            }\n            snake_case.to_uppercase()\n        }\n        Some(\"SCREAMING-KEBAB-CASE\") =\u003e {\n            // Convert to SCREAMING-KEBAB-CASE\n            // First convert to kebab-case if needed, then uppercase\n            let mut kebab_case = String::new();\n            for (i, ch) in field_name.chars().enumerate() {\n                if ch.is_uppercase()\n                    \u0026\u0026 i \u003e 0\n                    \u0026\u0026 !kebab_case.ends_with('-')\n                    \u0026\u0026 !kebab_case.ends_with('_')\n                {\n                    kebab_case.push('-');\n                }\n                if ch == '_' {\n                    kebab_case.push('-');\n                } else if ch != '-' {\n                    kebab_case.push(ch.to_lowercase().next().unwrap_or(ch));\n                } else {\n                    kebab_case.push('-');\n                }\n            }\n            kebab_case.to_uppercase()\n        }\n        _ =\u003e field_name.to_string(),\n    }\n}\n\npub fn parse_enum_to_schema(\n    enum_item: \u0026syn::ItemEnum,\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Schema {\n    // Extract rename_all attribute from enum\n    let rename_all = extract_rename_all(\u0026enum_item.attrs);\n\n    // Check if all variants are unit variants\n    let all_unit = enum_item\n        .variants\n        .iter()\n        .all(|v| matches!(v.fields, syn::Fields::Unit));\n\n    if all_unit {\n        // Simple enum with string values\n        let mut enum_values = Vec::new();\n\n        for variant in \u0026enum_item.variants {\n            let variant_name = variant.ident.to_string();\n\n            // Check for variant-level rename attribute first (takes precedence)\n            let enum_value = if let Some(renamed) = extract_field_rename(\u0026variant.attrs) {\n                renamed\n            } else {\n                // Apply rename_all transformation if present\n                rename_field(\u0026variant_name, rename_all.as_deref())\n            };\n\n            enum_values.push(serde_json::Value::String(enum_value));\n        }\n\n        Schema {\n            schema_type: Some(SchemaType::String),\n            r#enum: if enum_values.is_empty() {\n                None\n            } else {\n                Some(enum_values)\n            },\n            ..Schema::string()\n        }\n    } else {\n        // Enum with data - use oneOf\n        let mut one_of_schemas = Vec::new();\n\n        for variant in \u0026enum_item.variants {\n            let variant_name = variant.ident.to_string();\n\n            // Check for variant-level rename attribute first (takes precedence)\n            let variant_key = if let Some(renamed) = extract_field_rename(\u0026variant.attrs) {\n                renamed\n            } else {\n                // Apply rename_all transformation if present\n                rename_field(\u0026variant_name, rename_all.as_deref())\n            };\n\n            let variant_schema = match \u0026variant.fields {\n                syn::Fields::Unit =\u003e {\n                    // Unit variant: {\"const\": \"VariantName\"}\n                    Schema {\n                        r#enum: Some(vec![serde_json::Value::String(variant_key)]),\n                        ..Schema::string()\n                    }\n                }\n                syn::Fields::Unnamed(fields_unnamed) =\u003e {\n                    // Tuple variant: {\"VariantName\": \u003cinner_type\u003e}\n                    // For single field: {\"VariantName\": \u003ctype\u003e}\n                    // For multiple fields: {\"VariantName\": [\u003ctype1\u003e, \u003ctype2\u003e, ...]}\n                    if fields_unnamed.unnamed.len() == 1 {\n                        // Single field tuple variant\n                        let inner_type = \u0026fields_unnamed.unnamed[0].ty;\n                        let inner_schema =\n                            parse_type_to_schema_ref(inner_type, known_schemas, struct_definitions);\n\n                        let mut properties = BTreeMap::new();\n                        properties.insert(variant_key.clone(), inner_schema);\n\n                        Schema {\n                            properties: Some(properties),\n                            required: Some(vec![variant_key]),\n                            ..Schema::object()\n                        }\n                    } else {\n                        // Multiple fields tuple variant - serialize as array\n                        // serde serializes tuple variants as: {\"VariantName\": [value1, value2, ...]}\n                        // For OpenAPI 3.1, we use prefixItems to represent tuple arrays\n                        let mut tuple_item_schemas = Vec::new();\n                        for field in \u0026fields_unnamed.unnamed {\n                            let field_schema = parse_type_to_schema_ref(\n                                \u0026field.ty,\n                                known_schemas,\n                                struct_definitions,\n                            );\n                            tuple_item_schemas.push(field_schema);\n                        }\n\n                        let tuple_len = tuple_item_schemas.len();\n\n                        // Create array schema with prefixItems for tuple arrays (OpenAPI 3.1)\n                        let array_schema = Schema {\n                            prefix_items: Some(tuple_item_schemas),\n                            min_items: Some(tuple_len),\n                            max_items: Some(tuple_len),\n                            items: None, // Do not use prefixItems and items together\n                            ..Schema::new(SchemaType::Array)\n                        };\n\n                        let mut properties = BTreeMap::new();\n                        properties.insert(\n                            variant_key.clone(),\n                            SchemaRef::Inline(Box::new(array_schema)),\n                        );\n\n                        Schema {\n                            properties: Some(properties),\n                            required: Some(vec![variant_key]),\n                            ..Schema::object()\n                        }\n                    }\n                }\n                syn::Fields::Named(fields_named) =\u003e {\n                    // Struct variant: {\"VariantName\": {field1: type1, field2: type2, ...}}\n                    let mut variant_properties = BTreeMap::new();\n                    let mut variant_required = Vec::new();\n                    let variant_rename_all = extract_rename_all(\u0026variant.attrs);\n\n                    for field in \u0026fields_named.named {\n                        let rust_field_name = field\n                            .ident\n                            .as_ref()\n                            .map(|i| i.to_string())\n                            .unwrap_or_else(|| \"unknown\".to_string());\n\n                        // Check for field-level rename attribute first (takes precedence)\n                        let field_name = if let Some(renamed) = extract_field_rename(\u0026field.attrs) {\n                            renamed\n                        } else {\n                            // Apply rename_all transformation if present\n                            rename_field(\n                                \u0026rust_field_name,\n                                variant_rename_all.as_deref().or(rename_all.as_deref()),\n                            )\n                        };\n\n                        let field_type = \u0026field.ty;\n                        let schema_ref =\n                            parse_type_to_schema_ref(field_type, known_schemas, struct_definitions);\n\n                        variant_properties.insert(field_name.clone(), schema_ref);\n\n                        // Check if field is Option\u003cT\u003e\n                        let is_optional = matches!(\n                            field_type,\n                            Type::Path(type_path)\n                                if type_path\n                                    .path\n                                    .segments\n                                    .first()\n                                    .map(|s| s.ident == \"Option\")\n                                    .unwrap_or(false)\n                        );\n\n                        if !is_optional {\n                            variant_required.push(field_name);\n                        }\n                    }\n\n                    // Wrap struct variant in an object with the variant name as key\n                    let inner_struct_schema = Schema {\n                        properties: if variant_properties.is_empty() {\n                            None\n                        } else {\n                            Some(variant_properties)\n                        },\n                        required: if variant_required.is_empty() {\n                            None\n                        } else {\n                            Some(variant_required)\n                        },\n                        ..Schema::object()\n                    };\n\n                    let mut properties = BTreeMap::new();\n                    properties.insert(\n                        variant_key.clone(),\n                        SchemaRef::Inline(Box::new(inner_struct_schema)),\n                    );\n\n                    Schema {\n                        properties: Some(properties),\n                        required: Some(vec![variant_key]),\n                        ..Schema::object()\n                    }\n                }\n            };\n\n            one_of_schemas.push(SchemaRef::Inline(Box::new(variant_schema)));\n        }\n\n        Schema {\n            schema_type: None, // oneOf doesn't have a single type\n            one_of: if one_of_schemas.is_empty() {\n                None\n            } else {\n                Some(one_of_schemas)\n            },\n            ..Schema::new(SchemaType::Object)\n        }\n    }\n}\n\npub fn parse_struct_to_schema(\n    struct_item: \u0026syn::ItemStruct,\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Schema {\n    let mut properties = BTreeMap::new();\n    let mut required = Vec::new();\n\n    // Extract rename_all attribute from struct\n    let rename_all = extract_rename_all(\u0026struct_item.attrs);\n\n    match \u0026struct_item.fields {\n        Fields::Named(fields_named) =\u003e {\n            for field in \u0026fields_named.named {\n                // Check if field should be skipped\n                if extract_skip(\u0026field.attrs) {\n                    continue;\n                }\n\n                let rust_field_name = field\n                    .ident\n                    .as_ref()\n                    .map(|i| i.to_string())\n                    .unwrap_or_else(|| \"unknown\".to_string());\n\n                // Check for field-level rename attribute first (takes precedence)\n                let field_name = if let Some(renamed) = extract_field_rename(\u0026field.attrs) {\n                    renamed\n                } else {\n                    // Apply rename_all transformation if present\n                    rename_field(\u0026rust_field_name, rename_all.as_deref())\n                };\n\n                let field_type = \u0026field.ty;\n\n                let mut schema_ref =\n                    parse_type_to_schema_ref(field_type, known_schemas, struct_definitions);\n\n                // Check for default attribute\n                let has_default = extract_default(\u0026field.attrs).is_some();\n\n                // Check for skip_serializing_if attribute\n                let has_skip_serializing_if = extract_skip_serializing_if(\u0026field.attrs);\n\n                // If default or skip_serializing_if is present, mark field as optional (not required)\n                // and set default value if it's a simple default (not a function)\n                if has_default || has_skip_serializing_if {\n                    // For default = \"function_name\", we'll handle it in openapi_generator\n                    // For now, just mark as optional\n                    if let SchemaRef::Inline(ref mut _schema) = schema_ref {\n                        // Default will be set later in openapi_generator if it's a function\n                        // For simple default, we could set it here, but serde handles it\n                    }\n                } else {\n                    // Check if field is Option\u003cT\u003e\n                    let is_optional = matches!(\n                        field_type,\n                        Type::Path(type_path)\n                            if type_path\n                                .path\n                                .segments\n                                .first()\n                                .map(|s| s.ident == \"Option\")\n                                .unwrap_or(false)\n                    );\n\n                    if !is_optional {\n                        required.push(field_name.clone());\n                    }\n                }\n\n                properties.insert(field_name, schema_ref);\n            }\n        }\n        Fields::Unnamed(_) =\u003e {\n            // Tuple structs are not supported for now\n        }\n        Fields::Unit =\u003e {\n            // Unit structs have no fields\n        }\n    }\n\n    Schema {\n        schema_type: Some(SchemaType::Object),\n        properties: if properties.is_empty() {\n            None\n        } else {\n            Some(properties)\n        },\n        required: if required.is_empty() {\n            None\n        } else {\n            Some(required)\n        },\n        ..Schema::object()\n    }\n}\n\nfn substitute_type(ty: \u0026Type, generic_params: \u0026[String], concrete_types: \u0026[\u0026Type]) -\u003e Type {\n    // Check if this is a generic parameter\n    if let Type::Path(type_path) = ty\n        \u0026\u0026 let Some(segment) = type_path.path.segments.last()\n    {\n        let ident_str = segment.ident.to_string();\n        if generic_params.contains(\u0026ident_str) \u0026\u0026 segment.arguments.is_none() {\n            // Find the index and substitute\n            if let Some(index) = generic_params.iter().position(|p| p == \u0026ident_str)\n                \u0026\u0026 let Some(concrete_ty) = concrete_types.get(index)\n            {\n                return (*concrete_ty).clone();\n            }\n        }\n    }\n\n    // For complex types, use quote! to regenerate with substitutions\n    let tokens = quote::quote! { #ty };\n    let mut new_tokens = tokens.to_string();\n\n    // Replace generic parameter names with concrete types\n    for (param, concrete_ty) in generic_params.iter().zip(concrete_types.iter()) {\n        // Replace standalone generic parameter (not part of another identifier)\n        let pattern = format!(r\"\\b{}\\b\", param);\n        let replacement = quote::quote! { #concrete_ty }.to_string();\n        new_tokens = new_tokens.replace(\u0026pattern, \u0026replacement);\n    }\n\n    // Parse the substituted type\n    syn::parse_str::\u003cType\u003e(\u0026new_tokens).unwrap_or_else(|_| ty.clone())\n}\n\npub(super) fn is_primitive_type(ty: \u0026Type) -\u003e bool {\n    match ty {\n        Type::Path(type_path) =\u003e {\n            let path = \u0026type_path.path;\n            if path.segments.len() == 1 {\n                let ident = path.segments[0].ident.to_string();\n                matches!(\n                    ident.as_str(),\n                    \"i8\" | \"i16\"\n                        | \"i32\"\n                        | \"i64\"\n                        | \"u8\"\n                        | \"u16\"\n                        | \"u32\"\n                        | \"u64\"\n                        | \"f32\"\n                        | \"f64\"\n                        | \"bool\"\n                        | \"String\"\n                        | \"str\"\n                )\n            } else {\n                false\n            }\n        }\n        _ =\u003e false,\n    }\n}\n\npub fn parse_type_to_schema_ref(\n    ty: \u0026Type,\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\n) -\u003e SchemaRef {\n    parse_type_to_schema_ref_with_schemas(ty, known_schemas, struct_definitions)\n}\n\npub(super) fn parse_type_to_schema_ref_with_schemas(\n    ty: \u0026Type,\n    known_schemas: \u0026HashMap\u003cString, String\u003e,\n    struct_definitions: \u0026HashMap\u003cString, String\u003e,\n) -\u003e SchemaRef {\n    match ty {\n        Type::Path(type_path) =\u003e {\n            let path = \u0026type_path.path;\n            if path.segments.is_empty() {\n                return SchemaRef::Inline(Box::new(Schema::new(SchemaType::Object)));\n            }\n\n            // Get the last segment as the type name (handles paths like crate::TestStruct)\n            let segment = path.segments.last().unwrap();\n            let ident_str = segment.ident.to_string();\n\n            // Handle generic types\n            if let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments {\n                match ident_str.as_str() {\n                    \"Vec\" | \"Option\" =\u003e {\n                        if let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first() {\n                            let inner_schema = parse_type_to_schema_ref(\n                                inner_ty,\n                                known_schemas,\n                                struct_definitions,\n                            );\n                            if ident_str == \"Vec\" {\n                                return SchemaRef::Inline(Box::new(Schema::array(inner_schema)));\n                            } else {\n                                // Option\u003cT\u003e -\u003e nullable schema\n                                match inner_schema {\n                                    SchemaRef::Inline(mut schema) =\u003e {\n                                        schema.nullable = Some(true);\n                                        return SchemaRef::Inline(schema);\n                                    }\n                                    SchemaRef::Ref(reference) =\u003e {\n                                        // Wrap reference in an inline schema to attach nullable flag\n                                        return SchemaRef::Inline(Box::new(Schema {\n                                            ref_path: Some(reference.ref_path),\n                                            schema_type: None,\n                                            nullable: Some(true),\n                                            ..Schema::new(SchemaType::Object)\n                                        }));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    \"HashMap\" | \"BTreeMap\" =\u003e {\n                        // HashMap\u003cK, V\u003e or BTreeMap\u003cK, V\u003e -\u003e object with additionalProperties\n                        // K is typically String, we use V as the value type\n                        if args.args.len() \u003e= 2\n                            \u0026\u0026 let (\n                                Some(syn::GenericArgument::Type(_key_ty)),\n                                Some(syn::GenericArgument::Type(value_ty)),\n                            ) = (args.args.get(0), args.args.get(1))\n                        {\n                            let value_schema = parse_type_to_schema_ref(\n                                value_ty,\n                                known_schemas,\n                                struct_definitions,\n                            );\n                            // Convert SchemaRef to serde_json::Value for additional_properties\n                            let additional_props_value = match value_schema {\n                                SchemaRef::Ref(ref_ref) =\u003e {\n                                    serde_json::json!({ \"$ref\": ref_ref.ref_path })\n                                }\n                                SchemaRef::Inline(schema) =\u003e {\n                                    serde_json::to_value(\u0026*schema).unwrap_or(serde_json::json!({}))\n                                }\n                            };\n                            return SchemaRef::Inline(Box::new(Schema {\n                                schema_type: Some(SchemaType::Object),\n                                additional_properties: Some(additional_props_value),\n                                ..Schema::object()\n                            }));\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n\n            // Handle primitive types\n            match ident_str.as_str() {\n                \"i8\" | \"i16\" | \"i32\" | \"i64\" | \"u8\" | \"u16\" | \"u32\" | \"u64\" =\u003e {\n                    SchemaRef::Inline(Box::new(Schema::integer()))\n                }\n                \"f32\" | \"f64\" =\u003e SchemaRef::Inline(Box::new(Schema::number())),\n                \"bool\" =\u003e SchemaRef::Inline(Box::new(Schema::boolean())),\n                \"String\" | \"str\" =\u003e SchemaRef::Inline(Box::new(Schema::string())),\n                // Standard library types that should not be referenced\n                // Note: HashMap and BTreeMap are handled above in generic types\n                \"Vec\" | \"Option\" | \"Result\" | \"Json\" | \"Path\" | \"Query\" | \"Header\" =\u003e {\n                    // These are not schema types, return object schema\n                    SchemaRef::Inline(Box::new(Schema::new(SchemaType::Object)))\n                }\n                _ =\u003e {\n                    // Check if this is a known schema (struct with Schema derive)\n                    // Try both the full path and just the type name\n                    let type_name = if path.segments.len() \u003e 1 {\n                        // For paths like crate::TestStruct, use just the type name\n                        ident_str.clone()\n                    } else {\n                        ident_str.clone()\n                    };\n\n                    if known_schemas.contains_key(\u0026type_name) {\n                        // Check if this is a generic type with type parameters\n                        if let syn::PathArguments::AngleBracketed(args) = \u0026segment.arguments {\n                            // This is a concrete generic type like GenericStruct\u003cString\u003e\n                            // Inline the schema by substituting generic parameters with concrete types\n                            if let Some(base_def) = struct_definitions.get(\u0026type_name)\n                                \u0026\u0026 let Ok(mut parsed) = syn::parse_str::\u003csyn::ItemStruct\u003e(base_def)\n                            {\n                                // Extract generic parameter names from the struct definition\n                                let generic_params: Vec\u003cString\u003e = parsed\n                                    .generics\n                                    .params\n                                    .iter()\n                                    .filter_map(|param| {\n                                        if let syn::GenericParam::Type(type_param) = param {\n                                            Some(type_param.ident.to_string())\n                                        } else {\n                                            None\n                                        }\n                                    })\n                                    .collect();\n\n                                // Extract concrete type arguments\n                                let concrete_types: Vec\u003c\u0026Type\u003e = args\n                                    .args\n                                    .iter()\n                                    .filter_map(|arg| {\n                                        if let syn::GenericArgument::Type(ty) = arg {\n                                            Some(ty)\n                                        } else {\n                                            None\n                                        }\n                                    })\n                                    .collect();\n\n                                // Substitute generic parameters with concrete types in all fields\n                                if generic_params.len() == concrete_types.len() {\n                                    if let syn::Fields::Named(fields_named) = \u0026mut parsed.fields {\n                                        for field in \u0026mut fields_named.named {\n                                            field.ty = substitute_type(\n                                                \u0026field.ty,\n                                                \u0026generic_params,\n                                                \u0026concrete_types,\n                                            );\n                                        }\n                                    }\n\n                                    // Remove generics from the struct (it's now concrete)\n                                    parsed.generics.params.clear();\n                                    parsed.generics.where_clause = None;\n\n                                    // Parse the substituted struct to schema (inline)\n                                    let schema = parse_struct_to_schema(\n                                        \u0026parsed,\n                                        known_schemas,\n                                        struct_definitions,\n                                    );\n                                    return SchemaRef::Inline(Box::new(schema));\n                                }\n                            }\n                        }\n                        // Non-generic type or generic without parameters - use reference\n                        SchemaRef::Ref(Reference::schema(\u0026type_name))\n                    } else {\n                        // For unknown custom types, return object schema instead of reference\n                        // This prevents creating invalid references to non-existent schemas\n                        SchemaRef::Inline(Box::new(Schema::new(SchemaType::Object)))\n                    }\n                }\n            }\n        }\n        Type::Reference(type_ref) =\u003e {\n            // Handle \u0026T, \u0026mut T, etc.\n            parse_type_to_schema_ref_with_schemas(\u0026type_ref.elem, known_schemas, struct_definitions)\n        }\n        _ =\u003e SchemaRef::Inline(Box::new(Schema::new(SchemaType::Object))),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use insta::{assert_debug_snapshot, with_settings};\n    use rstest::rstest;\n    use std::collections::HashMap;\n    use vespera_core::schema::{SchemaRef, SchemaType};\n\n    #[rstest]\n    #[case(\"HashMap\u003cString, i32\u003e\", Some(SchemaType::Object), true)]\n    #[case(\"Option\u003cString\u003e\", Some(SchemaType::String), false)] // nullable check\n    fn test_parse_type_to_schema_ref_cases(\n        #[case] ty_src: \u0026str,\n        #[case] expected_type: Option\u003cSchemaType\u003e,\n        #[case] expect_additional_props: bool,\n    ) {\n        let ty: syn::Type = syn::parse_str(ty_src).unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026HashMap::new(), \u0026HashMap::new());\n        if let SchemaRef::Inline(schema) = schema_ref {\n            assert_eq!(schema.schema_type, expected_type);\n            if expect_additional_props {\n                assert!(schema.additional_properties.is_some());\n            }\n            if ty_src.starts_with(\"Option\") {\n                assert_eq!(schema.nullable, Some(true));\n            }\n        } else {\n            panic!(\"Expected inline schema for {}\", ty_src);\n        }\n    }\n\n    #[test]\n    fn test_parse_type_to_schema_ref_option_ref_nullable() {\n        let mut known = HashMap::new();\n        known.insert(\"User\".to_string(), \"struct User;\".to_string());\n\n        let ty: syn::Type = syn::parse_str(\"Option\u003cUser\u003e\").unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026known, \u0026HashMap::new());\n\n        match schema_ref {\n            SchemaRef::Inline(schema) =\u003e {\n                assert_eq!(\n                    schema.ref_path,\n                    Some(\"#/components/schemas/User\".to_string())\n                );\n                assert_eq!(schema.nullable, Some(true));\n                assert_eq!(schema.schema_type, None);\n            }\n            _ =\u003e panic!(\"Expected inline schema for Option\u003cUser\u003e\"),\n        }\n    }\n\n    #[rstest]\n    #[case(\n        r#\"\n        #[serde(rename_all = \"kebab-case\")]\n        enum Status {\n            #[serde(rename = \"ok-status\")]\n            Ok,\n            ErrorCode,\n        }\n        \"#,\n        SchemaType::String,\n        vec![\"ok-status\", \"error-code\"], // rename_all is not applied in this path\n        \"status\"\n    )]\n    #[case(\n        r#\"\n        enum Simple {\n            First,\n            Second,\n        }\n        \"#,\n        SchemaType::String,\n        vec![\"First\", \"Second\"],\n        \"simple\"\n    )]\n    #[case(\n        r#\"\n        #[serde(rename_all = \"snake_case\")]\n        enum Simple {\n            FirstItem,\n            SecondItem,\n        }\n        \"#,\n        SchemaType::String,\n        vec![\"first_item\", \"second_item\"],\n        \"simple_snake\"\n    )]\n    fn test_parse_enum_to_schema_unit_variants(\n        #[case] enum_src: \u0026str,\n        #[case] expected_type: SchemaType,\n        #[case] expected_enum: Vec\u003c\u0026str\u003e,\n        #[case] suffix: \u0026str,\n    ) {\n        let enum_item: syn::ItemEnum = syn::parse_str(enum_src).unwrap();\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        assert_eq!(schema.schema_type, Some(expected_type));\n        let got = schema\n            .clone()\n            .r#enum\n            .unwrap()\n            .iter()\n            .map(|v| v.as_str().unwrap().to_string())\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        assert_eq!(got, expected_enum);\n        with_settings!({ snapshot_suffix =\u003e format!(\"unit_{}\", suffix) }, {\n            assert_debug_snapshot!(schema);\n        });\n    }\n\n    #[rstest]\n    #[case(\n        r#\"\n        enum Event {\n            Data(String),\n        }\n        \"#,\n        1,\n        Some(SchemaType::String),\n        0, // single-field tuple variant stored as object with inline schema\n        \"tuple_single\"\n    )]\n    #[case(\n        r#\"\n        enum Pair {\n            Values(i32, String),\n        }\n        \"#,\n        1,\n        Some(SchemaType::Array),\n        2, // tuple array prefix_items length\n        \"tuple_multi\"\n    )]\n    #[case(\n        r#\"\n        enum Msg {\n            Detail { id: i32, note: Option\u003cString\u003e },\n        }\n        \"#,\n        1,\n        Some(SchemaType::Object),\n        0, // not an array; ignore prefix_items length\n        \"named_object\"\n    )]\n    fn test_parse_enum_to_schema_tuple_and_named_variants(\n        #[case] enum_src: \u0026str,\n        #[case] expected_one_of_len: usize,\n        #[case] expected_inner_type: Option\u003cSchemaType\u003e,\n        #[case] expected_prefix_items_len: usize,\n        #[case] suffix: \u0026str,\n    ) {\n        let enum_item: syn::ItemEnum = syn::parse_str(enum_src).unwrap();\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.clone().one_of.expect(\"one_of missing\");\n        assert_eq!(one_of.len(), expected_one_of_len);\n\n        if let Some(inner_expected) = expected_inner_type.clone() {\n            if let SchemaRef::Inline(obj) = \u0026one_of[0] {\n                let props = obj.properties.as_ref().expect(\"props missing\");\n                // take first property value\n                let inner_schema = props.values().next().expect(\"no property value\");\n                match inner_expected {\n                    SchemaType::Array =\u003e {\n                        if let SchemaRef::Inline(array_schema) = inner_schema {\n                            assert_eq!(array_schema.schema_type, Some(SchemaType::Array));\n                            if expected_prefix_items_len \u003e 0 {\n                                assert_eq!(\n                                    array_schema.prefix_items.as_ref().unwrap().len(),\n                                    expected_prefix_items_len\n                                );\n                            }\n                        } else {\n                            panic!(\"Expected inline array schema\");\n                        }\n                    }\n                    SchemaType::Object =\u003e {\n                        if let SchemaRef::Inline(inner_obj) = inner_schema {\n                            assert_eq!(inner_obj.schema_type, Some(SchemaType::Object));\n                            let inner_props = inner_obj.properties.as_ref().unwrap();\n                            assert!(inner_props.contains_key(\"id\"));\n                            assert!(inner_props.contains_key(\"note\"));\n                            assert!(\n                                inner_obj\n                                    .required\n                                    .as_ref()\n                                    .unwrap()\n                                    .contains(\u0026\"id\".to_string())\n                            );\n                        } else {\n                            panic!(\"Expected inline object schema\");\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            } else {\n                panic!(\"Expected inline schema in one_of\");\n            }\n        }\n\n        with_settings!({ snapshot_suffix =\u003e format!(\"tuple_named_{}\", suffix) }, {\n            assert_debug_snapshot!(schema);\n        });\n    }\n\n    #[rstest]\n    #[case(\n        r#\"\n        enum Mixed {\n            Ready,\n            Data(String),\n        }\n        \"#,\n        2,\n        SchemaType::String,\n        \"Ready\"\n    )]\n    fn test_parse_enum_to_schema_mixed_unit_variant(\n        #[case] enum_src: \u0026str,\n        #[case] expected_one_of_len: usize,\n        #[case] expected_unit_type: SchemaType,\n        #[case] expected_unit_value: \u0026str,\n    ) {\n        let enum_item: syn::ItemEnum = syn::parse_str(enum_src).unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.one_of.expect(\"one_of missing for mixed enum\");\n        assert_eq!(one_of.len(), expected_one_of_len);\n\n        let unit_schema = match \u0026one_of[0] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema for unit variant\"),\n        };\n        assert_eq!(unit_schema.schema_type, Some(expected_unit_type));\n        let unit_enum = unit_schema.r#enum.as_ref().expect(\"enum values missing\");\n        assert_eq!(unit_enum[0].as_str().unwrap(), expected_unit_value);\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_rename_all_for_data_variant() {\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"kebab-case\")]\n            enum Payload {\n                DataItem(String),\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.one_of.expect(\"one_of missing\");\n        let variant_obj = match \u0026one_of[0] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema\"),\n        };\n        let props = variant_obj\n            .properties\n            .as_ref()\n            .expect(\"variant props missing\");\n        assert!(props.contains_key(\"data-item\"));\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_field_uses_enum_rename_all() {\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"snake_case\")]\n            enum Event {\n                Detail { UserId: i32 },\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.one_of.expect(\"one_of missing\");\n        let variant_obj = match \u0026one_of[0] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema\"),\n        };\n        let props = variant_obj\n            .properties\n            .as_ref()\n            .expect(\"variant props missing\");\n        let inner = match props.get(\"detail\").expect(\"variant key missing\") {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline inner schema\"),\n        };\n        let inner_props = inner.properties.as_ref().expect(\"inner props missing\");\n        assert!(inner_props.contains_key(\"user_id\"));\n        assert!(!inner_props.contains_key(\"UserId\"));\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_variant_rename_overrides_rename_all() {\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"snake_case\")]\n            enum Payload {\n                #[serde(rename = \"Explicit\")]\n                DataItem(i32),\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.one_of.expect(\"one_of missing\");\n        let variant_obj = match \u0026one_of[0] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema\"),\n        };\n        let props = variant_obj\n            .properties\n            .as_ref()\n            .expect(\"variant props missing\");\n        assert!(props.contains_key(\"Explicit\"));\n        assert!(!props.contains_key(\"data_item\"));\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_field_rename_overrides_variant_rename_all() {\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"snake_case\")]\n            enum Payload {\n                #[serde(rename_all = \"kebab-case\")]\n                Detail { #[serde(rename = \"ID\")] user_id: i32 },\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.one_of.expect(\"one_of missing\");\n        let variant_obj = match \u0026one_of[0] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema\"),\n        };\n        let props = variant_obj\n            .properties\n            .as_ref()\n            .expect(\"variant props missing\");\n        let inner = match props\n            .get(\"detail\")\n            .or_else(|| props.get(\"Detail\"))\n            .expect(\"variant key missing\")\n        {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline inner schema\"),\n        };\n        let inner_props = inner.properties.as_ref().expect(\"inner props missing\");\n        assert!(inner_props.contains_key(\"ID\")); // field-level rename wins\n        assert!(!inner_props.contains_key(\"user-id\")); // variant rename_all ignored for this field\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_rename_all_with_other_attrs_unit() {\n        // Test rename_all combined with other serde attributes for unit variants\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"kebab-case\", default)]\n            enum Status {\n                ActiveUser,\n                InactiveUser,\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let enum_values = schema.r#enum.expect(\"enum values missing\");\n        assert_eq!(enum_values[0].as_str().unwrap(), \"active-user\");\n        assert_eq!(enum_values[1].as_str().unwrap(), \"inactive-user\");\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_rename_all_with_other_attrs_data() {\n        // Test rename_all combined with other serde attributes for data variants\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"camelCase\", deny_unknown_fields)]\n            enum Event {\n                UserCreated { user_name: String, created_at: i64 },\n                UserDeleted(i32),\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let one_of = schema.one_of.expect(\"one_of missing\");\n\n        // Check UserCreated variant key is camelCase\n        let variant_obj = match \u0026one_of[0] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema\"),\n        };\n        let props = variant_obj\n            .properties\n            .as_ref()\n            .expect(\"variant props missing\");\n        assert!(props.contains_key(\"userCreated\"));\n        assert!(!props.contains_key(\"UserCreated\"));\n        assert!(!props.contains_key(\"user_created\"));\n\n        // Check UserDeleted variant key is camelCase\n        let variant_obj2 = match \u0026one_of[1] {\n            SchemaRef::Inline(s) =\u003e s,\n            _ =\u003e panic!(\"Expected inline schema\"),\n        };\n        let props2 = variant_obj2\n            .properties\n            .as_ref()\n            .expect(\"variant props missing\");\n        assert!(props2.contains_key(\"userDeleted\"));\n    }\n\n    #[test]\n    fn test_parse_enum_to_schema_rename_all_not_first_attr() {\n        // Test rename_all when it's not the first attribute\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(default, rename_all = \"SCREAMING_SNAKE_CASE\")]\n            enum Priority {\n                HighPriority,\n                LowPriority,\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_enum_to_schema(\u0026enum_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let enum_values = schema.r#enum.expect(\"enum values missing\");\n        assert_eq!(enum_values[0].as_str().unwrap(), \"HIGH_PRIORITY\");\n        assert_eq!(enum_values[1].as_str().unwrap(), \"LOW_PRIORITY\");\n    }\n\n    #[test]\n    fn test_parse_struct_to_schema_required_optional() {\n        let struct_item: syn::ItemStruct = syn::parse_str(\n            r#\"\n            struct User {\n                id: i32,\n                name: Option\u003cString\u003e,\n            }\n        \"#,\n        )\n        .unwrap();\n        let schema = parse_struct_to_schema(\u0026struct_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let props = schema.properties.as_ref().unwrap();\n        assert!(props.contains_key(\"id\"));\n        assert!(props.contains_key(\"name\"));\n        assert!(\n            schema\n                .required\n                .as_ref()\n                .unwrap()\n                .contains(\u0026\"id\".to_string())\n        );\n        assert!(\n            !schema\n                .required\n                .as_ref()\n                .unwrap()\n                .contains(\u0026\"name\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_parse_struct_to_schema_rename_all_and_field_rename() {\n        let struct_item: syn::ItemStruct = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"camelCase\")]\n            struct Profile {\n                #[serde(rename = \"id\")]\n                user_id: i32,\n                display_name: Option\u003cString\u003e,\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let schema = parse_struct_to_schema(\u0026struct_item, \u0026HashMap::new(), \u0026HashMap::new());\n        let props = schema.properties.as_ref().expect(\"props missing\");\n        assert!(props.contains_key(\"id\")); // field-level rename wins\n        assert!(props.contains_key(\"displayName\")); // rename_all applied\n        let required = schema.required.as_ref().expect(\"required missing\");\n        assert!(required.contains(\u0026\"id\".to_string()));\n        assert!(!required.contains(\u0026\"displayName\".to_string())); // Option makes it optional\n    }\n\n    #[rstest]\n    #[case(\"struct Wrapper(i32);\")]\n    #[case(\"struct Empty;\")]\n    fn test_parse_struct_to_schema_tuple_and_unit_structs(#[case] struct_src: \u0026str) {\n        let struct_item: syn::ItemStruct = syn::parse_str(struct_src).unwrap();\n        let schema = parse_struct_to_schema(\u0026struct_item, \u0026HashMap::new(), \u0026HashMap::new());\n        assert!(schema.properties.is_none());\n        assert!(schema.required.is_none());\n    }\n\n    #[test]\n    fn test_parse_type_to_schema_ref_empty_path_and_reference() {\n        // Empty path segments returns object\n        let ty = Type::Path(syn::TypePath {\n            qself: None,\n            path: syn::Path {\n                leading_colon: None,\n                segments: syn::punctuated::Punctuated::new(),\n            },\n        });\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026HashMap::new(), \u0026HashMap::new());\n        assert!(matches!(schema_ref, SchemaRef::Inline(_)));\n\n        // Reference type delegates to inner\n        let ty: Type = syn::parse_str(\"\u0026i32\").unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026HashMap::new(), \u0026HashMap::new());\n        if let SchemaRef::Inline(schema) = schema_ref {\n            assert_eq!(schema.schema_type, Some(SchemaType::Integer));\n        } else {\n            panic!(\"Expected inline integer schema\");\n        }\n    }\n\n    #[test]\n    fn test_parse_type_to_schema_ref_known_schema_ref_and_unknown_custom() {\n        let mut known_schemas = HashMap::new();\n        known_schemas.insert(\"Known\".to_string(), \"Known\".to_string());\n\n        let ty: Type = syn::parse_str(\"Known\").unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026known_schemas, \u0026HashMap::new());\n        assert!(matches!(schema_ref, SchemaRef::Ref(_)));\n\n        let ty: Type = syn::parse_str(\"UnknownType\").unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026known_schemas, \u0026HashMap::new());\n        assert!(matches!(schema_ref, SchemaRef::Inline(_)));\n    }\n\n    #[test]\n    fn test_parse_type_to_schema_ref_generic_substitution() {\n        // Ensure generic struct Wrapper\u003cT\u003e { value: T } is substituted to concrete type\n        let mut known_schemas = HashMap::new();\n        known_schemas.insert(\"Wrapper\".to_string(), \"Wrapper\".to_string());\n\n        let mut struct_definitions = HashMap::new();\n        struct_definitions.insert(\n            \"Wrapper\".to_string(),\n            \"struct Wrapper\u003cT\u003e { value: T }\".to_string(),\n        );\n\n        let ty: syn::Type = syn::parse_str(\"Wrapper\u003cString\u003e\").unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026known_schemas, \u0026struct_definitions);\n\n        if let SchemaRef::Inline(schema) = schema_ref {\n            let props = schema.properties.as_ref().unwrap();\n            let value = props.get(\"value\").unwrap();\n            if let SchemaRef::Inline(inner) = value {\n                assert_eq!(inner.schema_type, Some(SchemaType::String));\n            } else {\n                panic!(\"Expected inline schema for value\");\n            }\n        } else {\n            panic!(\"Expected inline schema for generic substitution\");\n        }\n    }\n\n    #[rstest]\n    #[case(\"$invalid\", \"String\")]\n    fn test_substitute_type_parse_failure_uses_original(\n        #[case] invalid: \u0026str,\n        #[case] concrete_src: \u0026str,\n    ) {\n        use proc_macro2::TokenStream;\n        use std::str::FromStr;\n\n        let ty = Type::Verbatim(TokenStream::from_str(invalid).unwrap());\n        let concrete: Type = syn::parse_str(concrete_src).unwrap();\n        let substituted = substitute_type(\u0026ty, \u0026[String::from(\"T\")], \u0026[\u0026concrete]);\n        assert_eq!(substituted, ty);\n    }\n\n    #[rstest]\n    #[case(\"\u0026i32\")]\n    #[case(\"std::string::String\")]\n    fn test_is_primitive_type_non_path_variants(#[case] ty_src: \u0026str) {\n        let ty: Type = syn::parse_str(ty_src).unwrap();\n        assert!(!is_primitive_type(\u0026ty));\n    }\n\n    #[rstest]\n    #[case(\n        \"HashMap\u003cString, Value\u003e\",\n        true,\n        None,\n        Some(\"#/components/schemas/Value\")\n    )]\n    #[case(\"Result\u003cString, i32\u003e\", false, Some(SchemaType::Object), None)]\n    #[case(\"crate::Value\", false, None, None)]\n    #[case(\"(i32, bool)\", false, Some(SchemaType::Object), None)]\n    fn test_parse_type_to_schema_ref_additional_cases(\n        #[case] ty_src: \u0026str,\n        #[case] expect_additional_props: bool,\n        #[case] expected_type: Option\u003cSchemaType\u003e,\n        #[case] expected_ref: Option\u003c\u0026str\u003e,\n    ) {\n        let mut known_schemas = HashMap::new();\n        known_schemas.insert(\"Value\".to_string(), \"Value\".to_string());\n\n        let ty: Type = syn::parse_str(ty_src).unwrap();\n        let schema_ref = parse_type_to_schema_ref(\u0026ty, \u0026known_schemas, \u0026HashMap::new());\n        match expected_ref {\n            Some(expected) =\u003e {\n                let SchemaRef::Inline(schema) = schema_ref else {\n                    panic!(\"Expected inline schema for {}\", ty_src);\n                };\n                let additional = schema\n                    .additional_properties\n                    .as_ref()\n                    .expect(\"additional_properties missing\");\n                assert_eq!(additional.get(\"$ref\").unwrap(), expected);\n            }\n            None =\u003e match schema_ref {\n                SchemaRef::Inline(schema) =\u003e {\n                    if expect_additional_props {\n                        assert!(schema.additional_properties.is_some());\n                    } else {\n                        assert_eq!(schema.schema_type, expected_type);\n                    }\n                }\n                SchemaRef::Ref(_) =\u003e {\n                    assert!(ty_src.contains(\"Value\"));\n                }\n            },\n        }\n    }\n\n    #[rstest]\n    // camelCase tests (snake_case input)\n    #[case(\"user_name\", Some(\"camelCase\"), \"userName\")]\n    #[case(\"first_name\", Some(\"camelCase\"), \"firstName\")]\n    #[case(\"last_name\", Some(\"camelCase\"), \"lastName\")]\n    #[case(\"user_id\", Some(\"camelCase\"), \"userId\")]\n    #[case(\"api_key\", Some(\"camelCase\"), \"apiKey\")]\n    #[case(\"already_camel\", Some(\"camelCase\"), \"alreadyCamel\")]\n    // camelCase tests (PascalCase input)\n    #[case(\"UserName\", Some(\"camelCase\"), \"userName\")]\n    #[case(\"UserCreated\", Some(\"camelCase\"), \"userCreated\")]\n    #[case(\"FirstName\", Some(\"camelCase\"), \"firstName\")]\n    #[case(\"ID\", Some(\"camelCase\"), \"id\")]\n    #[case(\"XMLParser\", Some(\"camelCase\"), \"xmlParser\")]\n    #[case(\"HTTPSConnection\", Some(\"camelCase\"), \"httpsConnection\")]\n    // snake_case tests\n    #[case(\"userName\", Some(\"snake_case\"), \"user_name\")]\n    #[case(\"firstName\", Some(\"snake_case\"), \"first_name\")]\n    #[case(\"lastName\", Some(\"snake_case\"), \"last_name\")]\n    #[case(\"userId\", Some(\"snake_case\"), \"user_id\")]\n    #[case(\"apiKey\", Some(\"snake_case\"), \"api_key\")]\n    #[case(\"already_snake\", Some(\"snake_case\"), \"already_snake\")]\n    // kebab-case tests\n    #[case(\"user_name\", Some(\"kebab-case\"), \"user-name\")]\n    #[case(\"first_name\", Some(\"kebab-case\"), \"first-name\")]\n    #[case(\"last_name\", Some(\"kebab-case\"), \"last-name\")]\n    #[case(\"user_id\", Some(\"kebab-case\"), \"user-id\")]\n    #[case(\"api_key\", Some(\"kebab-case\"), \"api-key\")]\n    #[case(\"already-kebab\", Some(\"kebab-case\"), \"already-kebab\")]\n    // PascalCase tests\n    #[case(\"user_name\", Some(\"PascalCase\"), \"UserName\")]\n    #[case(\"first_name\", Some(\"PascalCase\"), \"FirstName\")]\n    #[case(\"last_name\", Some(\"PascalCase\"), \"LastName\")]\n    #[case(\"user_id\", Some(\"PascalCase\"), \"UserId\")]\n    #[case(\"api_key\", Some(\"PascalCase\"), \"ApiKey\")]\n    #[case(\"AlreadyPascal\", Some(\"PascalCase\"), \"AlreadyPascal\")]\n    // lowercase tests\n    #[case(\"UserName\", Some(\"lowercase\"), \"username\")]\n    #[case(\"FIRST_NAME\", Some(\"lowercase\"), \"first_name\")]\n    #[case(\"lastName\", Some(\"lowercase\"), \"lastname\")]\n    #[case(\"User_ID\", Some(\"lowercase\"), \"user_id\")]\n    #[case(\"API_KEY\", Some(\"lowercase\"), \"api_key\")]\n    #[case(\"already_lower\", Some(\"lowercase\"), \"already_lower\")]\n    // UPPERCASE tests\n    #[case(\"user_name\", Some(\"UPPERCASE\"), \"USER_NAME\")]\n    #[case(\"firstName\", Some(\"UPPERCASE\"), \"FIRSTNAME\")]\n    #[case(\"LastName\", Some(\"UPPERCASE\"), \"LASTNAME\")]\n    #[case(\"user_id\", Some(\"UPPERCASE\"), \"USER_ID\")]\n    #[case(\"apiKey\", Some(\"UPPERCASE\"), \"APIKEY\")]\n    #[case(\"ALREADY_UPPER\", Some(\"UPPERCASE\"), \"ALREADY_UPPER\")]\n    // SCREAMING_SNAKE_CASE tests\n    #[case(\"user_name\", Some(\"SCREAMING_SNAKE_CASE\"), \"USER_NAME\")]\n    #[case(\"firstName\", Some(\"SCREAMING_SNAKE_CASE\"), \"FIRST_NAME\")]\n    #[case(\"LastName\", Some(\"SCREAMING_SNAKE_CASE\"), \"LAST_NAME\")]\n    #[case(\"user_id\", Some(\"SCREAMING_SNAKE_CASE\"), \"USER_ID\")]\n    #[case(\"apiKey\", Some(\"SCREAMING_SNAKE_CASE\"), \"API_KEY\")]\n    #[case(\"ALREADY_SCREAMING\", Some(\"SCREAMING_SNAKE_CASE\"), \"ALREADY_SCREAMING\")]\n    // SCREAMING-KEBAB-CASE tests\n    #[case(\"user_name\", Some(\"SCREAMING-KEBAB-CASE\"), \"USER-NAME\")]\n    #[case(\"firstName\", Some(\"SCREAMING-KEBAB-CASE\"), \"FIRST-NAME\")]\n    #[case(\"LastName\", Some(\"SCREAMING-KEBAB-CASE\"), \"LAST-NAME\")]\n    #[case(\"user_id\", Some(\"SCREAMING-KEBAB-CASE\"), \"USER-ID\")]\n    #[case(\"apiKey\", Some(\"SCREAMING-KEBAB-CASE\"), \"API-KEY\")]\n    #[case(\"already-kebab\", Some(\"SCREAMING-KEBAB-CASE\"), \"ALREADY-KEBAB\")]\n    // None tests (no transformation)\n    #[case(\"user_name\", None, \"user_name\")]\n    #[case(\"firstName\", None, \"firstName\")]\n    #[case(\"LastName\", None, \"LastName\")]\n    #[case(\"user-id\", None, \"user-id\")]\n    fn test_rename_field(\n        #[case] field_name: \u0026str,\n        #[case] rename_all: Option\u003c\u0026str\u003e,\n        #[case] expected: \u0026str,\n    ) {\n        assert_eq!(rename_field(field_name, rename_all), expected);\n    }\n\n    #[rstest]\n    #[case(r#\"#[serde(rename_all = \"camelCase\")] struct Foo;\"#, Some(\"camelCase\"))]\n    #[case(\n        r#\"#[serde(rename_all = \"snake_case\")] struct Foo;\"#,\n        Some(\"snake_case\")\n    )]\n    #[case(\n        r#\"#[serde(rename_all = \"kebab-case\")] struct Foo;\"#,\n        Some(\"kebab-case\")\n    )]\n    #[case(\n        r#\"#[serde(rename_all = \"PascalCase\")] struct Foo;\"#,\n        Some(\"PascalCase\")\n    )]\n    // Multiple attributes - this is the bug case\n    #[case(\n        r#\"#[serde(rename_all = \"camelCase\", default)] struct Foo;\"#,\n        Some(\"camelCase\")\n    )]\n    #[case(\n        r#\"#[serde(default, rename_all = \"snake_case\")] struct Foo;\"#,\n        Some(\"snake_case\")\n    )]\n    #[case(r#\"#[serde(rename_all = \"kebab-case\", skip_serializing_if = \"Option::is_none\")] struct Foo;\"#, Some(\"kebab-case\"))]\n    // No rename_all\n    #[case(r#\"#[serde(default)] struct Foo;\"#, None)]\n    #[case(r#\"#[derive(Debug)] struct Foo;\"#, None)]\n    fn test_extract_rename_all(#[case] item_src: \u0026str, #[case] expected: Option\u003c\u0026str\u003e) {\n        let item: syn::ItemStruct = syn::parse_str(item_src).unwrap();\n        let result = extract_rename_all(\u0026item.attrs);\n        assert_eq!(result.as_deref(), expected);\n    }\n\n    #[test]\n    fn test_extract_rename_all_enum_with_deny_unknown_fields() {\n        let enum_item: syn::ItemEnum = syn::parse_str(\n            r#\"\n            #[serde(rename_all = \"camelCase\", deny_unknown_fields)]\n            enum Foo { A, B }\n        \"#,\n        )\n        .unwrap();\n        let result = extract_rename_all(\u0026enum_item.attrs);\n        assert_eq!(result.as_deref(), Some(\"camelCase\"));\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":7,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":8,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":11,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":12,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":15,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":16,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":17,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":18,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":20,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":21,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":22,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":28,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":31,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":32,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":33,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":34,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":37,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":38,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":39,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":40,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":42,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":44,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":46,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":48,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":50,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":51,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":55,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":59,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":60,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":99,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":100,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":101,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":102,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":104,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":133,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":134,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":135,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":136,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":138,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":139,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":140,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":145,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":151,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":164,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":165,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":166,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":167,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":169,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":170,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":171,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":188,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":194,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":221,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":223,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":224,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":226,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":227,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":228,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":229,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":230,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":231,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":232,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":233,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":235,"address":[],"length":0,"stats":{"Line":9079256848778919936}},{"line":238,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":240,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":242,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":243,"address":[],"length":0,"stats":{"Line":14915921965851082752}},{"line":244,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":245,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":247,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":249,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":251,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":253,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":254,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":255,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":256,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":257,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":259,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":260,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":261,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":263,"address":[],"length":0,"stats":{"Line":9079256848778919936}},{"line":266,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":268,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":270,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":271,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":272,"address":[],"length":0,"stats":{"Line":4827858800541171712}},{"line":273,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":274,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":275,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":276,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":277,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":279,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":282,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":284,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":286,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":288,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":290,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":292,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":295,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":297,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":300,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":301,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":302,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":303,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":305,"address":[],"length":0,"stats":{"Line":8142508126285856768}},{"line":306,"address":[],"length":0,"stats":{"Line":13330654897016668160}},{"line":307,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":308,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":311,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":313,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":316,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":317,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":318,"address":[],"length":0,"stats":{"Line":7493989779944505344}},{"line":319,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":320,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":321,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":323,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":325,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":326,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":327,"address":[],"length":0,"stats":{"Line":7277816997830721536}},{"line":328,"address":[],"length":0,"stats":{"Line":17654110539292344320}},{"line":330,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":333,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":335,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":339,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":345,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":348,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":349,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":351,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":353,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":355,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":357,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":358,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":361,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":362,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":365,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":368,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":372,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":373,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":382,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":384,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":385,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":388,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":389,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":392,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":395,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":399,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":403,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":407,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":409,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":410,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":411,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":413,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":414,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":417,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":418,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":425,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":426,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":428,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":429,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":430,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":432,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":435,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":439,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":440,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":441,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":446,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":447,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":448,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":449,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":453,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":454,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":459,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":461,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":462,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":463,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":465,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":466,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":467,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":469,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":470,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":473,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":474,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":478,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":479,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":483,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":484,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":485,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":487,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":490,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":491,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":492,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":493,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":494,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":495,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":496,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":497,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":498,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":501,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":502,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":508,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":513,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":521,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":522,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":523,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":524,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":528,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":529,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":535,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":540,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":550,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":555,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":556,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":559,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":561,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":562,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":563,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":565,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":570,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":572,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":573,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":576,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":577,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":580,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":583,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":585,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":586,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":589,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":592,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":596,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":606,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":607,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":608,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":609,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":610,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":611,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":612,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":613,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":616,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":617,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":621,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":624,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":627,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":633,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":634,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":639,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":648,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":650,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":651,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":653,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":654,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":656,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":657,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":659,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":665,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":666,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":669,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":671,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":672,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":673,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":677,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":680,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":681,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":682,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":683,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":684,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":685,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":686,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":687,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":702,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":705,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":709,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":714,"address":[],"length":0,"stats":{"Line":13546827679130451968}},{"line":717,"address":[],"length":0,"stats":{"Line":9007199254740992000}},{"line":722,"address":[],"length":0,"stats":{"Line":9007199254740992000}},{"line":723,"address":[],"length":0,"stats":{"Line":8574853690513424384}},{"line":724,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":725,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":726,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":730,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":731,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":734,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":735,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":736,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":737,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":739,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":740,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":741,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":743,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":744,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":747,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":748,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":749,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":750,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":752,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":754,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":755,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":756,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":757,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":758,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":765,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":768,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":770,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":771,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":772,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":775,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":776,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":777,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":780,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":781,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":782,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":784,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":785,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":788,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":789,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":790,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":791,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":795,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":800,"address":[],"length":0,"stats":{"Line":7638104968020361216}},{"line":801,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":802,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":804,"address":[],"length":0,"stats":{"Line":11385099857992613888}},{"line":805,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":806,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":809,"address":[],"length":0,"stats":{"Line":6773413839565225984}},{"line":811,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":816,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":818,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":820,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":823,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":825,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":828,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":829,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":832,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":833,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":834,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":836,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":837,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":838,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":847,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":849,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":850,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":851,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":860,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":861,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":862,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":863,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":864,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":865,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":871,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":872,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":876,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":877,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":878,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":880,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":885,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":889,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":894,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":896,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":898,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":376,"coverable":428},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","route","mod.rs"],"content":"mod utils;\n\npub use utils::*;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","crates","vespera_macro","src","route","utils.rs"],"content":"use crate::args::RouteArgs;\n\n/// Extract doc comments from attributes\n/// Returns concatenated doc comment string or None if no doc comments\npub fn extract_doc_comment(attrs: \u0026[syn::Attribute]) -\u003e Option\u003cString\u003e {\n    let mut doc_lines = Vec::new();\n\n    for attr in attrs {\n        if attr.path().is_ident(\"doc\")\n            \u0026\u0026 let syn::Meta::NameValue(meta_nv) = \u0026attr.meta\n            \u0026\u0026 let syn::Expr::Lit(syn::ExprLit {\n                lit: syn::Lit::Str(lit_str),\n                ..\n            }) = \u0026meta_nv.value\n        {\n            let line = lit_str.value();\n            // Trim leading space that rustdoc adds\n            let trimmed = line.strip_prefix(' ').unwrap_or(\u0026line);\n            doc_lines.push(trimmed.to_string());\n        }\n    }\n\n    if doc_lines.is_empty() {\n        None\n    } else {\n        Some(doc_lines.join(\"\\n\"))\n    }\n}\n\n#[derive(Debug)]\npub struct RouteInfo {\n    pub method: String,\n    pub path: Option\u003cString\u003e,\n    pub error_status: Option\u003cVec\u003cu16\u003e\u003e,\n    pub tags: Option\u003cVec\u003cString\u003e\u003e,\n    pub description: Option\u003cString\u003e,\n}\n\npub fn check_route_by_meta(meta: \u0026syn::Meta) -\u003e bool {\n    match meta {\n        syn::Meta::List(meta_list) =\u003e {\n            (meta_list.path.segments.len() == 2\n                \u0026\u0026 meta_list.path.segments[0].ident == \"vespera\"\n                \u0026\u0026 meta_list.path.segments[1].ident == \"route\")\n                || (meta_list.path.segments.len() == 1\n                    \u0026\u0026 meta_list.path.segments[0].ident == \"route\")\n        }\n        syn::Meta::Path(path) =\u003e {\n            (path.segments.len() == 2\n                \u0026\u0026 path.segments[0].ident == \"vespera\"\n                \u0026\u0026 path.segments[1].ident == \"route\")\n                || (path.segments.len() == 1 \u0026\u0026 path.segments[0].ident == \"route\")\n        }\n        syn::Meta::NameValue(meta_nv) =\u003e {\n            (meta_nv.path.segments.len() == 2\n                \u0026\u0026 meta_nv.path.segments[0].ident == \"vespera\"\n                \u0026\u0026 meta_nv.path.segments[1].ident == \"route\")\n                || (meta_nv.path.segments.len() == 1 \u0026\u0026 meta_nv.path.segments[0].ident == \"route\")\n        }\n    }\n}\n\npub fn extract_route_info(attrs: \u0026[syn::Attribute]) -\u003e Option\u003cRouteInfo\u003e {\n    for attr in attrs {\n        // Check if attribute path is \"vespera\" or \"route\"\n        if check_route_by_meta(\u0026attr.meta) {\n            match \u0026attr.meta {\n                syn::Meta::List(meta_list) =\u003e {\n                    // Try to parse as RouteArgs\n                    if let Ok(route_args) = meta_list.parse_args::\u003cRouteArgs\u003e() {\n                        let method = route_args\n                            .method\n                            .as_ref()\n                            .map(syn::Ident::to_string)\n                            .unwrap_or_else(|| \"get\".to_string());\n                        let path = route_args.path.as_ref().map(syn::LitStr::value);\n\n                        // Parse error_status array if present\n                        let error_status = route_args.error_status.as_ref().and_then(|array| {\n                            let mut status_codes = Vec::new();\n                            for elem in \u0026array.elems {\n                                if let syn::Expr::Lit(syn::ExprLit {\n                                    lit: syn::Lit::Int(lit_int),\n                                    ..\n                                }) = elem\n                                    \u0026\u0026 let Ok(code) = lit_int.base10_parse::\u003cu16\u003e()\n                                {\n                                    status_codes.push(code);\n                                }\n                            }\n                            if status_codes.is_empty() {\n                                None\n                            } else {\n                                Some(status_codes)\n                            }\n                        });\n\n                        // Parse tags array if present\n                        let tags = route_args.tags.as_ref().and_then(|array| {\n                            let mut tag_list = Vec::new();\n                            for elem in \u0026array.elems {\n                                if let syn::Expr::Lit(syn::ExprLit {\n                                    lit: syn::Lit::Str(lit_str),\n                                    ..\n                                }) = elem\n                                {\n                                    tag_list.push(lit_str.value());\n                                }\n                            }\n                            if tag_list.is_empty() {\n                                None\n                            } else {\n                                Some(tag_list)\n                            }\n                        });\n\n                        // Parse description if present\n                        let description = route_args.description.as_ref().map(|s| s.value());\n\n                        return Some(RouteInfo {\n                            method,\n                            path,\n                            error_status,\n                            tags,\n                            description,\n                        });\n                    }\n                }\n                // Try to parse as Meta::NameValue (e.g., #[route = \"patch\"])\n                syn::Meta::NameValue(meta_nv) =\u003e {\n                    if let syn::Expr::Lit(syn::ExprLit {\n                        lit: syn::Lit::Str(lit_str),\n                        ..\n                    }) = \u0026meta_nv.value\n                    {\n                        let method_str = lit_str.value().to_lowercase();\n                        if method_str == \"get\"\n                            || method_str == \"post\"\n                            || method_str == \"put\"\n                            || method_str == \"patch\"\n                            || method_str == \"delete\"\n                            || method_str == \"head\"\n                            || method_str == \"options\"\n                        {\n                            return Some(RouteInfo {\n                                method: method_str,\n                                path: None,\n                                error_status: None,\n                                tags: None,\n                                description: None,\n                            });\n                        }\n                    }\n                }\n                // Try to parse as Meta::Path (e.g., #[route])\n                syn::Meta::Path(_) =\u003e {\n                    return Some(RouteInfo {\n                        method: \"get\".to_string(),\n                        path: None,\n                        error_status: None,\n                        tags: None,\n                        description: None,\n                    });\n                }\n            }\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rstest::rstest;\n\n    fn parse_meta_from_attr(attr_str: \u0026str) -\u003e syn::Meta {\n        // Parse attribute from string like \"#[route()]\" or \"#[vespera::route(get)]\"\n        let full_code = format!(\"{} fn test() {{}}\", attr_str);\n        let file: syn::File = syn::parse_str(\u0026full_code).expect(\"Failed to parse with attribute\");\n\n        // Extract the first attribute from the function\n        if let Some(syn::Item::Fn(fn_item)) = file.items.first()\n            \u0026\u0026 let Some(attr) = fn_item.attrs.first()\n        {\n            return attr.meta.clone();\n        }\n\n        panic!(\"Failed to extract meta from attribute: {}\", attr_str);\n    }\n\n    #[rstest]\n    // Valid route attributes (List meta)\n    #[case(\"#[route()]\", true)]\n    #[case(\"#[vespera::route()]\", true)]\n    #[case(\"#[route(get)]\", true)]\n    #[case(\"#[vespera::route(get)]\", true)]\n    #[case(\"#[route(post)]\", true)]\n    #[case(\"#[vespera::route(post)]\", true)]\n    #[case(\"#[route(get, path = \\\"/api\\\")]\", true)]\n    #[case(\"#[vespera::route(get, path = \\\"/api\\\")]\", true)]\n    // Path meta (without parentheses) should return true\n    #[case(\"#[route]\", true)]\n    #[case(\"#[vespera::route]\", true)]\n    // NameValue meta should return true\n    #[case(\"#[route = \\\"get\\\"]\", true)]\n    #[case(\"#[vespera::route = \\\"get\\\"]\", true)]\n    // Invalid route attributes\n    #[case(\"#[other()]\", false)]\n    #[case(\"#[vespera::other()]\", false)]\n    #[case(\"#[other(get)]\", false)]\n    #[case(\"#[vespera::other(get)]\", false)]\n    #[case(\"#[derive(Schema)]\", false)]\n    #[case(\"#[serde(rename_all = \\\"camelCase\\\")]\", false)]\n    #[case(\"#[test]\", false)]\n    // Nested paths with more than 2 segments should return false\n    #[case(\"#[vespera::route::something]\", false)]\n    #[case(\"#[vespera::route::something()]\", false)]\n    fn test_check_route_by_meta(#[case] attr_str: \u0026str, #[case] expected: bool) {\n        let meta = parse_meta_from_attr(attr_str);\n        let result = check_route_by_meta(\u0026meta);\n        assert_eq!(\n            result, expected,\n            \"Failed for attribute: {}, expected: {}\",\n            attr_str, expected\n        );\n    }\n\n    fn parse_attrs_from_code(code: \u0026str) -\u003e Vec\u003csyn::Attribute\u003e {\n        let file: syn::File = syn::parse_str(code).expect(\"Failed to parse code\");\n        if let Some(syn::Item::Fn(fn_item)) = file.items.first() {\n            return fn_item.attrs.clone();\n        }\n        vec![]\n    }\n\n    #[rstest]\n    // Route with method only\n    #[case(\"#[route(get)] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    #[case(\"#[route(post)] fn test() {}\", Some((\"post\".to_string(), None, None)))]\n    #[case(\"#[route(put)] fn test() {}\", Some((\"put\".to_string(), None, None)))]\n    #[case(\"#[route(patch)] fn test() {}\", Some((\"patch\".to_string(), None, None)))]\n    #[case(\"#[route(delete)] fn test() {}\", Some((\"delete\".to_string(), None, None)))]\n    #[case(\"#[route(head)] fn test() {}\", Some((\"head\".to_string(), None, None)))]\n    #[case(\"#[route(options)] fn test() {}\", Some((\"options\".to_string(), None, None)))]\n    #[case(\"#[vespera::route(get)] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    // Route with method and path\n    #[case(\"#[route(get, path = \\\"/api\\\")] fn test() {}\", Some((\"get\".to_string(), Some(\"/api\".to_string()), None)))]\n    #[case(\"#[route(post, path = \\\"/users\\\")] fn test() {}\", Some((\"post\".to_string(), Some(\"/users\".to_string()), None)))]\n    #[case(\"#[route(get, path = \\\"/api/v1\\\")] fn test() {}\", Some((\"get\".to_string(), Some(\"/api/v1\".to_string()), None)))]\n    // Route with method and error_status\n    #[case(\"#[route(get, error_status = [400])] fn test() {}\", Some((\"get\".to_string(), None, Some(vec![400]))))]\n    #[case(\"#[route(get, error_status = [400, 404])] fn test() {}\", Some((\"get\".to_string(), None, Some(vec![400, 404]))))]\n    #[case(\"#[route(get, error_status = [400, 404, 500])] fn test() {}\", Some((\"get\".to_string(), None, Some(vec![400, 404, 500]))))]\n    // Route with method, path, and error_status\n    #[case(\"#[route(get, path = \\\"/api\\\", error_status = [400])] fn test() {}\", Some((\"get\".to_string(), Some(\"/api\".to_string()), Some(vec![400]))))]\n    #[case(\"#[route(post, path = \\\"/users\\\", error_status = [400, 404])] fn test() {}\", Some((\"post\".to_string(), Some(\"/users\".to_string()), Some(vec![400, 404]))))]\n    // Route without method (defaults to \"get\")\n    #[case(\"#[route()] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    #[case(\"#[route(path = \\\"/api\\\")] fn test() {}\", Some((\"get\".to_string(), Some(\"/api\".to_string()), None)))]\n    // Route with Path meta (e.g., #[route])\n    #[case(\"#[route] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    #[case(\"#[vespera::route] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    // Route with empty error_status array (should return None for error_status)\n    #[case(\"#[route(get, error_status = [])] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    // NameValue format (should work now)\n    #[case(\"#[route = \\\"get\\\"] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    #[case(\"#[route = \\\"post\\\"] fn test() {}\", Some((\"post\".to_string(), None, None)))]\n    #[case(\"#[route = \\\"put\\\"] fn test() {}\", Some((\"put\".to_string(), None, None)))]\n    #[case(\"#[route = \\\"patch\\\"] fn test() {}\", Some((\"patch\".to_string(), None, None)))]\n    #[case(\"#[route = \\\"delete\\\"] fn test() {}\", Some((\"delete\".to_string(), None, None)))]\n    #[case(\"#[route = \\\"head\\\"] fn test() {}\", Some((\"head\".to_string(), None, None)))]\n    #[case(\"#[route = \\\"options\\\"] fn test() {}\", Some((\"options\".to_string(), None, None)))]\n    #[case(\"#[vespera::route = \\\"get\\\"] fn test() {}\", Some((\"get\".to_string(), None, None)))]\n    // Invalid cases (should return None)\n    #[case(\"#[other(get)] fn test() {}\", None)]\n    #[case(\"#[derive(Schema)] fn test() {}\", None)]\n    #[case(\"#[test] fn test() {}\", None)]\n    #[case(\"fn test() {}\", None)]\n    // Invalid method in NameValue format\n    #[case(\"#[route = \\\"invalid\\\"] fn test() {}\", None)]\n    #[case(\"#[route = \\\"GET\\\"] fn test() {}\", Some((\"get\".to_string(), None, None)))] // lowercase conversion\n    // Multiple attributes - should find route attribute\n    #[case(\"#[derive(Debug)] #[route(get, path = \\\"/api\\\")] #[test] fn test() {}\", Some((\"get\".to_string(), Some(\"/api\".to_string()), None)))]\n    // Multiple route attributes - first one wins\n    #[case(\"#[route(get, path = \\\"/first\\\")] #[route(post, path = \\\"/second\\\")] fn test() {}\", Some((\"get\".to_string(), Some(\"/first\".to_string()), None)))]\n    // Explicit tests for method.as_ref() and path.as_ref().map() coverage\n    #[case(\"#[route(path = \\\"/test\\\")] fn test() {}\", Some((\"get\".to_string(), Some(\"/test\".to_string()), None)))] // method None, path Some\n    #[case(\"#[route()] fn test() {}\", Some((\"get\".to_string(), None, None)))] // method None, path None\n    #[case(\"#[route(post)] fn test() {}\", Some((\"post\".to_string(), None, None)))] // method Some, path None\n    #[case(\"#[route(put, path = \\\"/test\\\")] fn test() {}\", Some((\"put\".to_string(), Some(\"/test\".to_string()), None)))] // method Some, path Some\n    fn test_extract_route_info(\n        #[case] code: \u0026str,\n        #[case] expected: Option\u003c(String, Option\u003cString\u003e, Option\u003cVec\u003cu16\u003e\u003e)\u003e,\n    ) {\n        let attrs = parse_attrs_from_code(code);\n        let result = extract_route_info(\u0026attrs);\n\n        match expected {\n            Some((exp_method, exp_path, exp_error_status)) =\u003e {\n                assert!(\n                    result.is_some(),\n                    \"Expected Some but got None for code: {}\",\n                    code\n                );\n                let route_info = result.unwrap();\n                assert_eq!(\n                    route_info.method, exp_method,\n                    \"Method mismatch for code: {}\",\n                    code\n                );\n                assert_eq!(\n                    route_info.path, exp_path,\n                    \"Path mismatch for code: {}\",\n                    code\n                );\n                assert_eq!(\n                    route_info.error_status, exp_error_status,\n                    \"Error status mismatch for code: {}\",\n                    code\n                );\n            }\n            None =\u003e {\n                assert!(\n                    result.is_none(),\n                    \"Expected None but got Some({:?}) for code: {}\",\n                    result,\n                    code\n                );\n            }\n        }\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":7133701809754865664}},{"line":12,"address":[],"length":0,"stats":{"Line":7133701809754865664}},{"line":13,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":14,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":15,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":16,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":17,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":18,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":20,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":21,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":22,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":23,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":24,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":26,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":27,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":28,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":29,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":30,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":35,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":36,"address":[],"length":0,"stats":{"Line":11601272640106397696}},{"line":38,"address":[],"length":0,"stats":{"Line":11240984669916758016}},{"line":39,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":40,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":42,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":52,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":53,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":55,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":57,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":58,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":60,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":63,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":64,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":66,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":100,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":102,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":104,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":105,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":106,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":107,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":108,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":109,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":110,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":111,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":113,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":114,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":115,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":116,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":117,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":124,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":125,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":126,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":127,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":134,"address":[],"length":0,"stats":{"Line":360287970189639680}}],"covered":57,"coverable":75},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","lib.rs"],"content":"mod routes;\n\nuse std::sync::Arc;\n\nuse serde::{Deserialize, Serialize};\nuse vespera::{Schema, axum, vespera};\n\npub struct AppState {\n    pub config: String,\n}\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct TestStruct {\n    pub name: String,\n    pub age: u32,\n}\n\n/// Create the application router for testing\npub fn create_app() -\u003e axum::Router {\n    vespera!(\n        openapi = [\"examples/axum-example/openapi.json\", \"openapi.json\"],\n        docs_url = \"/docs\",\n        redoc_url = \"/redoc\"\n    )\n    .with_state(Arc::new(AppState {\n        config: \"test\".to_string(),\n    }))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","main.rs"],"content":"use axum_example::create_app;\nuse vespera::axum;\n\n#[tokio::main]\nasync fn main() {\n    let app = create_app();\n\n    let addr = std::net::SocketAddr::from(([0, 0, 0, 0], 3000));\n    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();\n\n    println!(\" Server running on http://localhost:3000\");\n\n    axum::serve(listener, app).await.unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","enums.rs"],"content":"use std::collections::{BTreeMap, HashMap};\n\nuse serde::{Deserialize, Serialize};\nuse vespera::{Schema, axum::Json};\n\nuse crate::TestStruct;\n\n#[derive(Serialize, Deserialize, Schema)]\npub enum Enum {\n    A,\n    B,\n    C,\n}\n\n#[vespera::route(get)]\npub async fn enum_endpoint() -\u003e Json\u003cEnum\u003e {\n    Json(Enum::A)\n}\n\n#[derive(Serialize, Deserialize, Schema)]\npub enum Enum2 {\n    A(String),\n    B { name: String, age: i32 },\n    C(i32),\n    D(bool),\n    E(Vec\u003cString\u003e),\n    F(String, i32),\n    G(HashMap\u003cString, String\u003e),\n    H(BTreeMap\u003cString, String\u003e),\n    I(TestStruct),\n    J(Vec\u003cTestStruct\u003e),\n    K(TestStruct, TestStruct),\n    L(Option\u003cString\u003e),\n    M(Vec\u003cOption\u003cString\u003e\u003e),\n    N(HashMap\u003cString, Option\u003cString\u003e\u003e),\n}\n\n#[vespera::route(get, path = \"/enum2\")]\npub async fn enum_endpoint2() -\u003e Json\u003cEnum2\u003e {\n    Json(Enum2::A(\"a\".to_string()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","error.rs"],"content":"use serde::{Deserialize, Serialize};\nuse vespera::{\n    Schema,\n    axum::{Json, http::StatusCode, http::header::HeaderMap, response::IntoResponse},\n};\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct ErrorResponse {\n    pub error: String,\n    pub code: u32,\n}\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct ErrorResponse2 {\n    pub error: String,\n    pub code: u32,\n}\n\nimpl IntoResponse for ErrorResponse2 {\n    fn into_response(self) -\u003e vespera::axum::response::Response {\n        (StatusCode::INTERNAL_SERVER_ERROR, Json(self)).into_response()\n    }\n}\n\n#[vespera::route()]\npub async fn error_endpoint() -\u003e Result\u003c\u0026'static str, Json\u003cErrorResponse\u003e\u003e {\n    Err(Json(ErrorResponse {\n        error: \"Internal server error\".to_string(),\n        code: 500,\n    }))\n}\n\n#[vespera::route(path = \"/error-with-status\")]\npub async fn error_endpoint_with_status_code()\n-\u003e Result\u003c\u0026'static str, (StatusCode, Json\u003cErrorResponse\u003e)\u003e {\n    Err((\n        StatusCode::INTERNAL_SERVER_ERROR,\n        Json(ErrorResponse {\n            error: \"Internal server error\".to_string(),\n            code: 500,\n        }),\n    ))\n}\n\n#[vespera::route(path = \"/error2\")]\npub async fn error_endpoint2() -\u003e Result\u003c\u0026'static str, ErrorResponse2\u003e {\n    Err(ErrorResponse2 {\n        error: \"Internal server error\".to_string(),\n        code: 500,\n    })\n}\n\n#[vespera::route(path = \"/error-with-status2\", error_status = [500, 400, 404])]\npub async fn error_endpoint_with_status_code2() -\u003e Result\u003c\u0026'static str, (StatusCode, ErrorResponse2)\u003e\n{\n    Err((\n        StatusCode::INTERNAL_SERVER_ERROR,\n        ErrorResponse2 {\n            error: \"Internal server error\".to_string(),\n            code: 500,\n        },\n    ))\n}\n\n#[vespera::route(path = \"/header-map\")]\npub async fn header_map_endpoint() -\u003e Result\u003c(HeaderMap, \u0026'static str), ErrorResponse2\u003e {\n    let headers = HeaderMap::new();\n    println!(\"headers: {:?}\", headers);\n    Ok((headers, \"ok\"))\n}\n\n#[vespera::route(path = \"/header-map2\")]\npub async fn header_map_endpoint2() -\u003e Result\u003c(StatusCode, HeaderMap, \u0026'static str), ErrorResponse2\u003e\n{\n    let headers = HeaderMap::new();\n    println!(\"headers: {:?}\", headers);\n    Ok((StatusCode::INTERNAL_SERVER_ERROR, headers, \"ok\"))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","foo","mod.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::sync::Arc;\nuse vespera::{\n    Schema,\n    axum::{Json, extract::State},\n};\n\nuse crate::AppState;\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct SignupRequest {\n    pub email: String,\n    pub password: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Schema)]\n#[serde(rename_all = \"camelCase\")]\npub struct SignupResponse {\n    pub id: i32,\n    pub email: String,\n    pub name: String,\n    #[serde(rename = \"phoneNumber23\")]\n    pub phone_number: String,\n    pub nickname: Option\u003cString\u003e,\n    pub birthday: Option\u003cString\u003e,\n    pub gender: Option\u003cString\u003e,\n    pub job: Option\u003cString\u003e,\n    #[serde(rename = \"createdAt\")]\n    pub created_at: String,\n}\n\n#[vespera::route(post, path = \"/foo\")]\npub async fn signup(\n    State(app_state): State\u003cArc\u003cAppState\u003e\u003e,\n    Json(request): Json\u003cSignupRequest\u003e,\n) -\u003e Result\u003cJson\u003cSignupResponse\u003e, String\u003e {\n    println!(\"app_state: {:?}\", app_state.config);\n    let response = SignupResponse {\n        id: 1,\n        email: request.email,\n        name: \"John Doe\".to_string(),\n        phone_number: \"1234567890\".to_string(),\n        nickname: Some(\"John\".to_string()),\n        birthday: Some(\"1990-01-01\".to_string()),\n        gender: Some(\"male\".to_string()),\n        job: Some(\"engineer\".to_string()),\n        created_at: \"2021-01-01\".to_string(),\n    };\n    Ok(Json(response))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","generic.rs"],"content":"use serde::Serialize;\nuse vespera::axum::Json;\n\nuse crate::TestStruct;\n\n#[derive(Serialize, vespera::Schema)]\npub struct GenericStruct\u003cT: Serialize\u003e {\n    pub value: T,\n    pub name: String,\n}\n\n#[derive(Serialize, vespera::Schema)]\npub struct GenericStruct2\u003cT, T2\u003e {\n    pub value: T,\n    pub name: String,\n    pub value2: T2,\n}\n\n#[vespera::route(get, path = \"/generic/{value}\")]\npub async fn generic_endpoint(\n    vespera::axum::extract::Path(value): vespera::axum::extract::Path\u003cString\u003e,\n) -\u003e Json\u003cGenericStruct\u003cString\u003e\u003e {\n    Json(GenericStruct {\n        value,\n        name: \"John Doe\".to_string(),\n    })\n}\n\n#[vespera::route(get, path = \"/generic2\")]\npub async fn generic_endpoint2() -\u003e Json\u003cGenericStruct\u003cTestStruct\u003e\u003e {\n    Json(GenericStruct {\n        value: TestStruct {\n            name: \"test\".to_string(),\n            age: 20,\n        },\n        name: \"John Doe\".to_string(),\n    })\n}\n\n#[vespera::route(get, path = \"/generic3\")]\npub async fn generic_endpoint3() -\u003e Json\u003cGenericStruct2\u003cTestStruct, String\u003e\u003e {\n    Json(GenericStruct2 {\n        value: TestStruct {\n            name: \"test\".to_string(),\n            age: 20,\n        },\n        value2: \"test2\".to_string(),\n        name: \"John Doe\".to_string(),\n    })\n}\n\n#[vespera::route(get, path = \"/generic4\")]\npub async fn generic_endpoint4() -\u003e Json\u003cGenericStruct2\u003cbool, bool\u003e\u003e {\n    Json(GenericStruct2 {\n        value: true,\n        value2: false,\n        name: \"John Doe\".to_string(),\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","health.rs"],"content":"#[vespera::route(get)]\npub async fn health() -\u003e \u0026'static str {\n    \"ok\"\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","mod.rs"],"content":"use std::collections::HashMap;\n\nuse serde::Deserialize;\nuse vespera::{\n    Schema,\n    axum::{Json, extract::Query},\n};\n\nuse crate::TestStruct;\n\npub mod enums;\npub mod error;\npub mod foo;\npub mod generic;\npub mod health;\npub mod path;\npub mod typed_header;\npub mod users;\n\n/// Health check endpoint\n#[vespera::route(get)]\npub async fn root_endpoint() -\u003e \u0026'static str {\n    \"root endpoint\"\n}\n\n/// Hello!!\n#[vespera::route(get, path = \"/hello\", tags = [\"hello\"])]\npub async fn mod_file_endpoint() -\u003e \u0026'static str {\n    \"mod file endpoint\"\n}\n\n#[derive(Deserialize, Schema, Debug)]\npub struct MapQuery {\n    pub name: String,\n    pub age: u32,\n    pub optional_age: Option\u003cu32\u003e,\n}\n#[vespera::route(get, path = \"/map-query\")]\npub async fn mod_file_with_map_query(Query(query): Query\u003cMapQuery\u003e) -\u003e \u0026'static str {\n    println!(\"map query: {:?}\", query.age);\n    println!(\"map query: {:?}\", query.name);\n    println!(\"map query: {:?}\", query.optional_age);\n    \"mod file endpoint\"\n}\n\n#[derive(Deserialize, Debug)]\npub struct NoSchemaQuery {\n    pub name: String,\n    pub age: u32,\n    pub optional_age: Option\u003cu32\u003e,\n}\n\n#[vespera::route(get, path = \"/no-schema-query\")]\npub async fn mod_file_with_no_schema_query(Query(query): Query\u003cNoSchemaQuery\u003e) -\u003e \u0026'static str {\n    println!(\"no schema query: {:?}\", query.age);\n    println!(\"no schema query: {:?}\", query.name);\n    println!(\"no schema query: {:?}\", query.optional_age);\n    \"mod file endpoint\"\n}\n\n#[derive(Deserialize, Schema)]\npub struct StructQuery {\n    pub name: String,\n    pub age: u32,\n}\n\n#[vespera::route(get, path = \"/struct-query\")]\npub async fn mod_file_with_struct_query(Query(query): Query\u003cStructQuery\u003e) -\u003e String {\n    format!(\"name: {}, age: {}\", query.name, query.age)\n}\n\n#[derive(Deserialize, Schema)]\npub struct StructBody {\n    pub name: String,\n    pub age: u32,\n}\n\n#[vespera::route(post, path = \"/struct-body\")]\npub async fn mod_file_with_struct_body(Json(body): Json\u003cStructBody\u003e) -\u003e String {\n    format!(\"name: {}, age: {}\", body.name, body.age)\n}\n\n#[derive(Deserialize, Schema, Debug)]\npub struct StructBodyWithOptional {\n    pub name: Option\u003cString\u003e,\n    pub age: Option\u003cu32\u003e,\n}\n\n#[vespera::route(post, path = \"/struct-body-with-optional\")]\npub async fn mod_file_with_struct_body_with_optional(\n    Json(body): Json\u003cStructBodyWithOptional\u003e,\n) -\u003e String {\n    format!(\"name: {:?}, age: {:?}\", body.name, body.age)\n}\n\n#[derive(Deserialize, Schema)]\npub struct ComplexStructBody {\n    pub name: String,\n    pub age: u32,\n    pub nested_struct: StructBodyWithOptional,\n    pub array: Vec\u003cString\u003e,\n    pub map: HashMap\u003cString, String\u003e,\n    pub nested_array: Vec\u003cStructBodyWithOptional\u003e,\n    pub nested_map: HashMap\u003cString, StructBodyWithOptional\u003e,\n    pub nested_struct_array: Vec\u003cStructBodyWithOptional\u003e,\n    pub nested_struct_map: HashMap\u003cString, StructBodyWithOptional\u003e,\n    pub nested_struct_array_map: Vec\u003cHashMap\u003cString, StructBodyWithOptional\u003e\u003e,\n    pub nested_struct_map_array: HashMap\u003cString, Vec\u003cStructBodyWithOptional\u003e\u003e,\n}\n\n#[vespera::route(post, path = \"/complex-struct-body\")]\npub async fn mod_file_with_complex_struct_body(Json(body): Json\u003cComplexStructBody\u003e) -\u003e String {\n    format!(\n        \"name: {}, age: {}, nested_struct: {:?}, array: {:?}, map: {:?}, nested_array: {:?}, nested_map: {:?}, nested_struct_array: {:?}, nested_struct_map: {:?}, nested_struct_array_map: {:?}, nested_struct_map_array: {:?}\",\n        body.name,\n        body.age,\n        body.nested_struct,\n        body.array,\n        body.map,\n        body.nested_array,\n        body.nested_map,\n        body.nested_struct_array,\n        body.nested_struct_map,\n        body.nested_struct_array_map,\n        body.nested_struct_map_array\n    )\n}\n\n#[derive(Deserialize, Schema)]\n#[serde(rename_all = \"camelCase\")]\npub struct ComplexStructBodyWithRename {\n    pub name: String,\n    pub age: u32,\n    pub nested_struct: StructBodyWithOptional,\n    pub array: Vec\u003cString\u003e,\n    pub map: HashMap\u003cString, String\u003e,\n    pub nested_array: Vec\u003cStructBodyWithOptional\u003e,\n    pub nested_map: HashMap\u003cString, StructBodyWithOptional\u003e,\n    pub nested_struct_array: Vec\u003cStructBodyWithOptional\u003e,\n    pub nested_struct_map: HashMap\u003cString, StructBodyWithOptional\u003e,\n    pub nested_struct_array_map: Vec\u003cHashMap\u003cString, StructBodyWithOptional\u003e\u003e,\n    pub nested_struct_map_array: HashMap\u003cString, Vec\u003cStructBodyWithOptional\u003e\u003e,\n}\n\n#[vespera::route(post, path = \"/complex-struct-body-with-rename\")]\npub async fn mod_file_with_complex_struct_body_with_rename(\n    Json(body): Json\u003cComplexStructBodyWithRename\u003e,\n) -\u003e String {\n    format!(\n        \"name: {}, age: {}, nested_struct: {:?}, array: {:?}, map: {:?}, nested_array: {:?}, nested_map: {:?}, nested_struct_array: {:?}, nested_struct_map: {:?}, nested_struct_array_map: {:?}, nested_struct_map_array: {:?}\",\n        body.name,\n        body.age,\n        body.nested_struct,\n        body.array,\n        body.map,\n        body.nested_array,\n        body.nested_map,\n        body.nested_struct_array,\n        body.nested_struct_map,\n        body.nested_struct_array_map,\n        body.nested_struct_map_array\n    )\n}\n\n#[vespera::route(get, path = \"/test_struct\")]\npub async fn mod_file_with_test_struct(Query(query): Query\u003cTestStruct\u003e) -\u003e Json\u003cTestStruct\u003e {\n    Json(query)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","path","mod.rs"],"content":"pub mod prefix;\n\n#[vespera::route(get, path = \"/multi-path/{var1}\")]\npub async fn mod_file_with_test_struct(\n    vespera::axum::extract::Path(var1): vespera::axum::extract::Path\u003cString\u003e,\n) -\u003e \u0026'static str {\n    println!(\"var1: {}\", var1);\n    \"multi path\"\n}\n\n// multi path\n#[vespera::route(get, path = \"/multi-path/{arg}/{var1}/{var2}\")]\npub async fn mod_file_with_multi_path(\n    vespera::axum::extract::Path((arg2, var1, var2)): vespera::axum::extract::Path\u003c(\n        String,\n        String,\n        String,\n    )\u003e,\n) -\u003e \u0026'static str {\n    println!(\"arg: {}\", arg2);\n    println!(\"var1: {}\", var1);\n    println!(\"var2: {}\", var2);\n    \"multi path\"\n}\n\n// multi path\n#[vespera::route(get, path = \"/multi-path2/{arg}/{var1}/{var2}\")]\npub async fn mod_file_with_multi_path_2(\n    vespera::axum::extract::Path(path): vespera::axum::extract::Path\u003c(String, String, String)\u003e,\n) -\u003e \u0026'static str {\n    println!(\"arg: {:?}\", path);\n    \"multi path\"\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","path","prefix","mod.rs"],"content":"use vespera::axum::extract::Path;\n\n#[vespera::route(path = \"/{var}\")]\npub async fn prefix_variable(Path(var): Path\u003cString\u003e) -\u003e String {\n    format!(\"prefix variable: {}\", var)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","typed_header.rs"],"content":"use vespera::axum_extra::{\r\n    TypedHeader,\r\n    headers::{Authorization, ContentType, UserAgent, authorization::Bearer},\r\n};\r\n\r\n#[vespera::route(post)]\r\npub async fn typed_header(\r\n    TypedHeader(user_agent): TypedHeader\u003cUserAgent\u003e,\r\n    content_type: Option\u003cTypedHeader\u003cContentType\u003e\u003e,\r\n) -\u003e \u0026'static str {\r\n    println!(\"user_agent: {:?}\", user_agent);\r\n    println!(\"content_type: {:?}\", content_type);\r\n    \"ok\"\r\n}\r\n\r\n#[vespera::route()]\r\npub async fn typed_header_jwt(\r\n    TypedHeader(authorization): TypedHeader\u003cAuthorization\u003cBearer\u003e\u003e,\r\n) -\u003e \u0026'static str {\r\n    println!(\"authorization: {:?}\", authorization);\r\n    \"ok\"\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","src","routes","users.rs"],"content":"use std::collections::{BTreeMap, HashMap};\n\nuse serde::{Deserialize, Serialize};\nuse vespera::{\n    Schema,\n    axum::{Json, extract::Path},\n};\n\n#[derive(Serialize, Deserialize, Clone, Schema)]\npub struct User {\n    pub id: u32,\n    pub name: String,\n    pub email: String,\n}\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct CreateUserRequest {\n    pub name: String,\n    pub email: String,\n}\n\n/// Get all users\n#[vespera::route(get)]\npub async fn get_users() -\u003e Json\u003cVec\u003cUser\u003e\u003e {\n    Json(vec![\n        User {\n            id: 1,\n            name: \"Alice\".to_string(),\n            email: \"alice@example.com\".to_string(),\n        },\n        User {\n            id: 2,\n            name: \"Bob\".to_string(),\n            email: \"bob@example.com\".to_string(),\n        },\n    ])\n}\n\n/// Get user by ID\n#[vespera::route(get, path = \"/{id}\")]\npub async fn get_user(Path(id): Path\u003cu32\u003e) -\u003e Json\u003cUser\u003e {\n    Json(User {\n        id,\n        name: format!(\"User {}\", id),\n        email: format!(\"user{}@example.com\", id),\n    })\n}\n\n/// Create a new user\n#[vespera::route(post)]\npub async fn create_user(Json(user): Json\u003cCreateUserRequest\u003e) -\u003e Json\u003cUser\u003e {\n    Json(User {\n        id: 100,\n        name: user.name,\n        email: user.email,\n    })\n}\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct SkipResponse {\n    pub name: String,\n    #[serde(skip)]\n    #[allow(dead_code)]\n    pub email: String,\n\n    #[serde(skip, skip_serializing_if = \"Option::is_none\")]\n    #[allow(dead_code)]\n    pub email2: Option\u003cString\u003e,\n\n    #[serde(rename = \"email3\", skip)]\n    #[allow(dead_code)]\n    pub email3: Option\u003cString\u003e,\n\n    #[serde(rename = \"email4\", skip_serializing_if = \"Option::is_none\")]\n    pub email4: Option\u003cString\u003e,\n\n    #[serde(rename = \"email5\", default)]\n    pub email5: String,\n\n    #[serde(rename = \"email6\", default = \"default_value\")]\n    pub email6: String,\n\n    #[serde(rename = \"email7\", skip)]\n    #[allow(dead_code)]\n    pub email7: String,\n\n    #[serde(rename = \"num\", default)]\n    pub num: i32,\n\n    pub in_skip: InSkipResponse,\n    pub in_skip2: Option\u003cInSkipResponse\u003e,\n    pub in_skip3: Vec\u003cInSkipResponse\u003e,\n    pub in_skip4: Option\u003cVec\u003cInSkipResponse\u003e\u003e,\n    pub in_skip5: Option\u003cHashMap\u003cString, InSkipResponse\u003e\u003e,\n    pub in_skip6: Option\u003cBTreeMap\u003cString, InSkipResponse\u003e\u003e,\n}\n\n#[derive(Serialize, Deserialize, Schema)]\npub struct InSkipResponse {\n    pub name: String,\n}\n\nfn default_value() -\u003e String {\n    \"default42\".to_string()\n}\n\n#[vespera::route(get, path = \"/skip-response\")]\npub async fn skip_response() -\u003e Json\u003cSkipResponse\u003e {\n    Json(SkipResponse {\n        name: \"John Doe\".to_string(),\n        email: \"john.doe@example.com\".to_string(),\n        email2: Some(\"john.doe2@example.com\".to_string()),\n        email3: Some(\"john.doe3@example.com\".to_string()),\n        email4: Some(\"john.doe4@example.com\".to_string()),\n        email5: \"john.doe5@example.com\".to_string(),\n        email6: \"john.doe6@example.com\".to_string(),\n        email7: \"john.doe7@example.com\".to_string(),\n        num: 0,\n        in_skip: InSkipResponse {\n            name: \"John Doe\".to_string(),\n        },\n        in_skip2: Some(InSkipResponse {\n            name: \"John Doe\".to_string(),\n        }),\n        in_skip3: vec![InSkipResponse {\n            name: \"John Doe\".to_string(),\n        }],\n        in_skip4: Some(vec![InSkipResponse {\n            name: \"John Doe\".to_string(),\n        }]),\n        in_skip5: Some(HashMap::from([(\n            \"John Doe\".to_string(),\n            InSkipResponse {\n                name: \"John Doe\".to_string(),\n            },\n        )])),\n        in_skip6: Some(BTreeMap::from([(\n            \"John Doe\".to_string(),\n            InSkipResponse {\n                name: \"John Doe\".to_string(),\n            },\n        )])),\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","serde-291d5c27960f80df","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private228 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","serde-63bbc3c99eac9aa0","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private228 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","serde-aff10547193e0874","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private228 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","serde_core-e39d8b2cecdfa797","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","serde_core-e6de1ee7ca275495","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","thiserror-637f0ad34ab847ca","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private17 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","target","debug","build","typetag-8e6210346607692e","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private21 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","owjs3","Desktop","projects","vespera","examples","axum-example","tests","integration_test.rs"],"content":"use axum_example::create_app;\nuse axum_test::TestServer;\nuse serde_json::json;\n\n#[tokio::test]\nasync fn test_health_endpoint() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/health\").await;\n\n    response.assert_status_ok();\n    response.assert_text(\"ok\");\n}\n\n#[tokio::test]\nasync fn test_mod_file_endpoint() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/hello\").await;\n\n    response.assert_status_ok();\n    response.assert_text(\"mod file endpoint\");\n\n    let response = server.get(\"/\").await;\n\n    response.assert_status_ok();\n    response.assert_text(\"root endpoint\");\n}\n\n#[tokio::test]\nasync fn test_get_users() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/users\").await;\n\n    response.assert_status_ok();\n    let users: serde_json::Value = response.json();\n\n    assert!(users.is_array());\n    assert_eq!(users.as_array().unwrap().len(), 2);\n\n    let first_user = \u0026users[0];\n    assert_eq!(first_user[\"id\"], 1);\n    assert_eq!(first_user[\"name\"], \"Alice\");\n    assert_eq!(first_user[\"email\"], \"alice@example.com\");\n}\n\n#[tokio::test]\nasync fn test_get_user_by_id() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/users/42\").await;\n\n    response.assert_status_ok();\n    let user: serde_json::Value = response.json();\n\n    assert_eq!(user[\"id\"], 42);\n    assert_eq!(user[\"name\"], \"User 42\");\n    assert_eq!(user[\"email\"], \"user42@example.com\");\n}\n\n#[tokio::test]\nasync fn test_create_user() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let new_user = json!({\n        \"name\": \"Charlie\",\n        \"email\": \"charlie@example.com\"\n    });\n\n    let response = server.post(\"/users\").json(\u0026new_user).await;\n\n    response.assert_status_ok();\n    let created_user: serde_json::Value = response.json();\n\n    assert_eq!(created_user[\"id\"], 100);\n    assert_eq!(created_user[\"name\"], \"Charlie\");\n    assert_eq!(created_user[\"email\"], \"charlie@example.com\");\n}\n\n#[tokio::test]\nasync fn test_get_nonexistent_user() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/users/999\").await;\n\n    response.assert_status_ok();\n    let user: serde_json::Value = response.json();\n    assert_eq!(user[\"id\"], 999);\n}\n\n#[tokio::test]\nasync fn test_prefix_variable() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/path/prefix/123\").await;\n\n    response.assert_status_ok();\n    response.assert_text(\"prefix variable: 123\");\n}\n\n#[tokio::test]\nasync fn test_invalid_path() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/nonexistent\").await;\n\n    response.assert_status_not_found();\n}\n\n#[tokio::test]\nasync fn test_mod_file_with_complex_struct_body() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let complex_body = json!({\n        \"name\": \"Test User\",\n        \"age\": 30,\n        \"nested_struct\": {\n            \"name\": \"Nested Name\",\n            \"age\": 25\n        },\n        \"array\": [\"item1\", \"item2\", \"item3\"],\n        \"map\": {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        },\n        \"nested_array\": [\n            {\n                \"name\": \"Array Item 1\",\n                \"age\": 20\n            },\n            {\n                \"name\": \"Array Item 2\",\n                \"age\": 21\n            }\n        ],\n        \"nested_map\": {\n            \"map_key1\": {\n                \"name\": \"Map Value 1\",\n                \"age\": 22\n            },\n            \"map_key2\": {\n                \"name\": \"Map Value 2\",\n                \"age\": 23\n            }\n        },\n        \"nested_struct_array\": [\n            {\n                \"name\": \"Struct Array 1\",\n                \"age\": 24\n            }\n        ],\n        \"nested_struct_map\": {\n            \"struct_map_key\": {\n                \"name\": \"Struct Map Value\",\n                \"age\": 26\n            }\n        },\n        \"nested_struct_array_map\": [\n            {\n                \"array_map_key1\": {\n                    \"name\": \"Array Map Value 1\",\n                    \"age\": 27\n                },\n                \"array_map_key2\": {\n                    \"name\": \"Array Map Value 2\",\n                    \"age\": 28\n                }\n            }\n        ],\n        \"nested_struct_map_array\": {\n            \"map_array_key\": [\n                {\n                    \"name\": \"Map Array Value 1\",\n                    \"age\": 29\n                },\n                {\n                    \"name\": \"Map Array Value 2\",\n                    \"age\": null\n                }\n            ]\n        }\n    });\n\n    let response = server\n        .post(\"/complex-struct-body\")\n        .json(\u0026complex_body)\n        .await;\n\n    response.assert_status_ok();\n    let response_text = response.text();\n\n    assert!(response_text.contains(\"name: Test User\"));\n    assert!(response_text.contains(\"age: 30\"));\n    assert!(response_text.contains(\"item1\"));\n    assert!(response_text.contains(\"value1\"));\n}\n\n#[tokio::test]\nasync fn test_mod_file_with_complex_struct_body_with_rename() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let complex_body = json!({\n        \"name\": \"Test User Renamed\",\n        \"age\": 35,\n        \"nestedStruct\": {\n            \"name\": \"Nested Name Renamed\",\n            \"age\": 30\n        },\n        \"array\": [\"renamed1\", \"renamed2\", \"renamed3\"],\n        \"map\": {\n            \"key1\": \"renamed_value1\",\n            \"key2\": \"renamed_value2\"\n        },\n        \"nestedArray\": [\n            {\n                \"name\": \"Renamed Array Item 1\",\n                \"age\": 25\n            },\n            {\n                \"name\": \"Renamed Array Item 2\",\n                \"age\": 26\n            }\n        ],\n        \"nestedMap\": {\n            \"map_key1\": {\n                \"name\": \"Renamed Map Value 1\",\n                \"age\": 27\n            },\n            \"map_key2\": {\n                \"name\": \"Renamed Map Value 2\",\n                \"age\": 28\n            }\n        },\n        \"nestedStructArray\": [\n            {\n                \"name\": \"Renamed Struct Array 1\",\n                \"age\": 29\n            }\n        ],\n        \"nestedStructMap\": {\n            \"struct_map_key\": {\n                \"name\": \"Renamed Struct Map Value\",\n                \"age\": 31\n            }\n        },\n        \"nestedStructArrayMap\": [\n            {\n                \"array_map_key1\": {\n                    \"name\": \"Renamed Array Map Value 1\",\n                    \"age\": 32\n                },\n                \"array_map_key2\": {\n                    \"name\": \"Renamed Array Map Value 2\",\n                    \"age\": 33\n                }\n            }\n        ],\n        \"nestedStructMapArray\": {\n            \"map_array_key\": [\n                {\n                    \"name\": \"Renamed Map Array Value 1\",\n                    \"age\": 34\n                },\n                {\n                    \"name\": \"Renamed Map Array Value 2\",\n                    \"age\": null\n                }\n            ]\n        }\n    });\n\n    let response = server\n        .post(\"/complex-struct-body-with-rename\")\n        .json(\u0026complex_body)\n        .await;\n\n    response.assert_status_ok();\n    let response_text = response.text();\n\n    assert!(response_text.contains(\"name: Test User Renamed\"));\n    assert!(response_text.contains(\"age: 35\"));\n    assert!(response_text.contains(\"renamed1\"));\n    assert!(response_text.contains(\"renamed_value1\"));\n}\n\n#[tokio::test]\nasync fn test_openapi() {\n    insta::assert_snapshot!(\"openapi\", std::fs::read_to_string(\"openapi.json\").unwrap());\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, ''),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e(
        'code',
        {
          className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        },
        line,
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '';
    }
  });
})();
</script>
</body>
</html>